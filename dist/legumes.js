var legumes = (() => {
  var __defProp = Object.defineProperty;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {enumerable: true, configurable: true, writable: true, value}) : obj[key] = value;
  var __objSpread = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      }
    return a;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, {get: all[name], enumerable: true});
  };

  // src/main.ts
  var main_exports = {};
  __export(main_exports, {
    ACCIDENTAL: () => ACCIDENTAL,
    ARTICULATION: () => ARTICULATION,
    BARLINE: () => BARLINE,
    BRACKET: () => BRACKET,
    CLEF: () => CLEF,
    CONFIG: () => CONFIG,
    CUE: () => CUE,
    NOTE_LENGTH: () => NOTE_LENGTH,
    compile_score: () => compile_score,
    export_animated_svg: () => export_animated_svg,
    export_gif: () => export_gif,
    export_midi: () => export_midi,
    export_mock_svg: () => export_mock_svg,
    export_pdf: () => export_pdf,
    export_sketch_svg: () => export_sketch_svg,
    export_svg: () => export_svg,
    export_txt: () => export_txt,
    parse_midi: () => parse_midi,
    parse_txt: () => parse_txt,
    playhead_coords: () => playhead_coords,
    register_font: () => register_font,
    render_score: () => render_score,
    round_polylines: () => round_polylines,
    score_from_midi: () => score_from_midi,
    score_to_midi: () => score_to_midi
  });

  // src/common.ts
  var NOTE_LENGTH = {
    WHOLE: 64,
    HALF: 32,
    QUARTER: 16,
    EIGHTH: 8,
    SIXTEENTH: 4,
    THIRTYSECOND: 2,
    SIXTYFOURTH: 1
  };
  var ACCIDENTAL = {
    SHARP: 1,
    NATURAL: 0,
    FLAT: -1
  };
  var CLEF = {
    TREBLE: 0,
    BASS: 1,
    ALTO: 2,
    TENOR: 3,
    MEZZO_SOPRANO: 4,
    SOPRANO: 5,
    BARITONE: 6
  };
  var ORDER_OF_ACCIDENTALS = {
    [ACCIDENTAL.SHARP]: "FCGDAEB",
    [ACCIDENTAL.FLAT]: "BEADGCF",
    [ACCIDENTAL.NATURAL]: ""
  };
  var ARTICULATION = {
    STACCATO: 11,
    SPICCATO: 12,
    TENUTO: 13,
    FERMATA: 14,
    ACCENT: 15,
    MARCATO: 16,
    TREMBLEMENT: 17,
    TRILL: 18,
    MORDENT: 19,
    TURN: 20,
    UP_BOW: 21,
    FLAGEOLET: 22,
    ARPEGGIATED: 23,
    MORDENT_INV: -19,
    TURN_INV: -20
  };
  var CUE = {
    PEDAL_ON: "ped",
    PEDAL_OFF: "*",
    PIANISSISSIMO: "ppp",
    PIANISSIMO: "pp",
    PIANO: "p",
    MEZZO_PIANO: "mp",
    MEZZO_FORTE: "mf",
    FORTE: "f",
    FORTISSIMO: "ff",
    FORTISSISSIMO: "fff",
    SFORZANDO: "sfz"
  };
  var BARLINE = {
    NONE: 0,
    SINGLE: 1,
    DOUBLE: 2,
    END: 3,
    REPEAT_BEGIN: 4,
    REPEAT_END: 5,
    REPEAT_END_BEGIN: 6
  };
  var BRACKET = {
    NONE: 0,
    BRACE: 1,
    BRACKET: 2
  };
  function note_name_to_staff_pos(name, clef) {
    let base_name = name[0];
    let octave = Number(name.split("_")[1]);
    let i0 = {
      [CLEF.TREBLE]: 6 * 7 + 3,
      [CLEF.BASS]: 5 * 7 - 2,
      [CLEF.ALTO]: 6 * 7 - 3,
      [CLEF.TENOR]: 6 * 7 - 5,
      [CLEF.MEZZO_SOPRANO]: 6 * 7 - 1,
      [CLEF.SOPRANO]: 6 * 7 + 1,
      [CLEF.BARITONE]: 5 * 7
    }[clef];
    let idx = i0 - ("CDEFGAB".indexOf(base_name) + octave * 7);
    return idx;
  }
  function get_note_name_accidental(name) {
    return [ACCIDENTAL.FLAT, ACCIDENTAL.NATURAL, ACCIDENTAL.SHARP]["b_s".indexOf(name[1])];
  }
  function get_existing_voices(staff_notes, filt) {
    return Array.from(new Set(staff_notes.map((x) => x.voice))).filter((x) => filt.includes(x) || !filt.length);
  }
  function short_id() {
    return "_" + String.fromCharCode(...new Array(6).fill(0).map((x) => ~~(Math.random() * 26) + 65));
  }
  function get_median_staff_pos(notes) {
    let c2p = {};
    for (let n of notes) {
      if (!c2p[n.voice]) {
        c2p[n.voice] = [];
      }
      c2p[n.voice].push(n.staff_pos);
    }
    let c2p2 = {};
    for (let k in c2p) {
      c2p[k].sort((a, b) => a - b);
      let m = ~~(c2p[k].length / 2);
      if (c2p[k].length % 2) {
        c2p2[k] = c2p[k][m];
      } else {
        c2p2[k] = (c2p[k][m - 1] + c2p[k][m]) / 2;
      }
    }
    return c2p2;
  }
  function chord_and_beam_staff(staff, beat_length) {
    let beam_cnt = 1;
    let notes_beam = new Array(staff.notes.length);
    let beam_info = {};
    for (let i = 0; i < staff.notes.length; i++) {
      let note = staff.notes[i];
      let beam = 0;
      let chord = [];
      let stem_dir = note.stem_dir;
      let disp_dur = note.duration;
      if (note.tuplet) {
        disp_dur = note.tuplet.display_duration;
      }
      for (let j = 0; j < staff.notes.length; j++) {
        let own = note;
        let other = staff.notes[j];
        if (own.voice == other.voice && own.begin == other.begin && own.duration == other.duration) {
          chord.push([j, other]);
        }
      }
      chord.sort((a, b) => stem_dir * (a[1].staff_pos - b[1].staff_pos));
      let my_idx = chord.findIndex((x) => x[0] == i);
      if (chord[my_idx - 1]) {
        note.prev_in_chord = chord[my_idx - 1][0];
      }
      if (chord[my_idx + 1]) {
        note.next_in_chord = chord[my_idx + 1][0];
      } else if (disp_dur < NOTE_LENGTH.QUARTER) {
        let linked = false;
        for (let j = 0; j < i; j++) {
          let calc_consecutive = function() {
            for (let k = 0; k < i; k++) {
              if (staff.notes[k].voice != staff.notes[i].voice) {
                continue;
              }
              if (staff.notes[j].begin < staff.notes[k].begin && staff.notes[k].begin < staff.notes[i].begin) {
                consecutive = false;
                break;
              }
            }
            if (consecutive) {
              for (let k = 0; k < staff.rests.length; k++) {
                if (staff.rests[k].voice != staff.notes[i].voice) {
                  continue;
                }
                if (staff.notes[j].begin < staff.rests[k].begin && staff.rests[k].begin < staff.notes[i].begin) {
                  consecutive = false;
                  break;
                }
              }
            }
            if (consecutive) {
              for (let k = staff.notes[j].begin + staff.notes[j].duration; k <= staff.notes[i].begin; k++) {
                if (staff.grace[k]) {
                  consecutive = false;
                  break;
                }
              }
            }
          };
          let own = staff.notes[i];
          let other = staff.notes[j];
          let other_beam = notes_beam[j];
          let consecutive = true;
          if (other.voice != own.voice) {
            continue;
          }
          if (other.next_in_chord != null) {
            continue;
          }
          if (own.tuplet && other.tuplet && own.tuplet.id == other.tuplet.id) {
            calc_consecutive();
            if (consecutive) {
              beam = notes_beam[j];
              linked = true;
              break;
            }
          } else if (own.tuplet || other.tuplet) {
            continue;
          } else {
            calc_consecutive();
            let same_stem_dir = stem_dir == staff.notes[j].stem_dir;
            let same_beat = ~~(other.begin / beat_length) == ~~(own.begin / beat_length);
            if (other_beam != 0 && consecutive && same_stem_dir && same_beat) {
              beam = notes_beam[j];
              linked = true;
              break;
            }
          }
        }
        if (!linked) {
          beam = beam_cnt;
          beam_cnt++;
        }
      }
      notes_beam[i] = beam;
    }
    for (let i = 0; i < staff.voices; i++) {
      beam_info[i] = {};
    }
    for (let b = 1; b < beam_cnt; b++) {
      let children = notes_beam.map((x, i) => [x, i]).filter((x) => x[0] == b).map((x) => x[1]);
      if (children.length > 1) {
        beam_info[staff.notes[children[0]].voice][b] = [];
      }
    }
    for (let i = 0; i < staff.notes.length; i++) {
      let on_record = beam_info[staff.notes[i].voice][notes_beam[i]];
      let can_beam = notes_beam[i] > 0;
      if (can_beam && !on_record) {
      } else if (on_record) {
        beam_info[staff.notes[i].voice][notes_beam[i]].push(i);
      }
    }
    for (let a in beam_info) {
      for (let b in beam_info[a]) {
        staff.beams.push(beam_info[a][b]);
      }
    }
  }

  // src/hershey.ts
  var ordR = "R".charCodeAt(0);
  var custom_map = {};
  var custom_scale = {};
  function HERSHEY(i) {
    if (data[i] == null) {
      compile(i);
    }
    return data[i];
  }
  function compile(i) {
    var entry = raw[i];
    if (entry == null) {
      return;
    }
    var bound = entry.substring(3, 5);
    var xmin = 1 * bound.charCodeAt(0) - ordR;
    var xmax = 1 * bound.charCodeAt(1) - ordR;
    var content = entry.substring(5);
    var polylines = [[]];
    var ymin = Infinity;
    var ymax = -Infinity;
    var j = 0;
    while (j < content.length) {
      var digit = content.substring(j, j + 2);
      if (digit == " R") {
        polylines.push([]);
      } else {
        var x = digit.charCodeAt(0) - ordR;
        var y = digit.charCodeAt(1) - ordR;
        ymin = Math.min(y, ymin);
        ymax = Math.max(y, ymax);
        polylines[polylines.length - 1].push([x, y]);
      }
      j += 2;
    }
    if (custom_scale[i]) {
      let s = custom_scale[i];
      xmin *= s;
      xmax *= s;
      ymin *= s;
      ymax *= s;
      for (let i2 = 0; i2 < polylines.length; i2++) {
        for (let j2 = 0; j2 < polylines[i2].length; j2++) {
          polylines[i2][j2][0] *= s;
          polylines[i2][j2][1] *= s;
        }
      }
    }
    data[i] = {
      xmin,
      xmax,
      ymin,
      ymax,
      polylines
    };
  }
  var FONT = {
    DUPLEX: 0,
    DUPLEX_ITALIC: 1,
    TRIPLEX: 20,
    TRIPLEX_ITALIC: 21
  };
  function ascii_map(x, font = FONT.DUPLEX_ITALIC) {
    let base = 2001 + font * 50;
    let c = x.charCodeAt(0);
    if (65 <= c && c <= 90) {
      return c - 65 + base;
    }
    if (97 <= c && c <= 122) {
      return c - 97 + base + 100;
    }
    if (48 <= c && c <= 57) {
      return c - 48 + base + 199;
    }
    let symb = {
      ".": 2210,
      ",": 2211,
      ":": 2212,
      ";": 2213,
      "!": 2214,
      "?": 2215,
      "'": 2216,
      '"': 2217,
      "\xB0": 2218,
      "*": 2219,
      "/": 2220,
      "(": 2221,
      ")": 2222,
      "[": 2223,
      "]": 2224,
      "{": 2225,
      "}": 2226,
      "\u27E8": 2227,
      "\u27E9": 2228,
      "|": 2229,
      "-": 2231,
      "+": 2232,
      "=": 2238,
      "<": 2241,
      ">": 2242,
      "~": 2246,
      "`": 2249,
      "\u2019": 2251,
      "\u2018": 2252,
      "\u221A": 2255,
      "\u2192": 2261,
      "%": 2271,
      "&": 2272,
      "@": 2273,
      $: 2274,
      "#": 2275
    }[x];
    if (symb)
      return symb;
    return custom_map[x];
  }
  function get_text_width(x, font = FONT.DUPLEX_ITALIC, spacing = 0) {
    let width = -spacing;
    for (let i = 0; i < x.length; i++) {
      width += spacing;
      if (x[i] == " ") {
        width += 10;
        continue;
      }
      let a = ascii_map(x[i], font);
      if (a === void 0) {
        continue;
      }
      let e = HERSHEY(a);
      let w = e.xmax - e.xmin;
      width += w;
    }
    return width;
  }
  function register_font(map_char_to_hid, map_hid_to_data, scale = 1) {
    let cmap = {};
    if (map_char_to_hid == "unicode") {
      for (let k in map_hid_to_data) {
        cmap[String.fromCharCode(Number(k))] = Number(k);
      }
    } else {
      cmap = map_char_to_hid;
    }
    Object.assign(custom_map, cmap);
    Object.assign(raw, map_hid_to_data);
    if (scale != 1) {
      for (let k in map_hid_to_data) {
        custom_scale[k] = scale;
      }
    }
  }
  var data = {};
  var raw = {
    2001: " 18H\\RFK[ RRFY[ RRIX[ RMUVU RI[O[ RU[[[",
    2002: " 45G]LFL[ RMFM[ RIFUFXGYHZJZLYNXOUP RUFWGXHYJYLXNWOUP RMPUPXQYRZTZWYYXZU[I[ RUPWQXRYTYWXYWZU[",
    2003: " 32G\\XIYLYFXIVGSFQFNGLIKKJNJSKVLXNZQ[S[VZXXYV RQFOGMILKKNKSLVMXOZQ[",
    2004: " 30G]LFL[ RMFM[ RIFSFVGXIYKZNZSYVXXVZS[I[ RSFUGWIXKYNYSXVWXUZS[",
    2005: " 22G\\LFL[ RMFM[ RSLST RIFYFYLXF RMPSP RI[Y[YUX[",
    2006: " 20G[LFL[ RMFM[ RSLST RIFYFYLXF RMPSP RI[P[",
    2007: " 40G^XIYLYFXIVGSFQFNGLIKKJNJSKVLXNZQ[S[VZXX RQFOGMILKKNKSLVMXOZQ[ RXSX[ RYSY[ RUS\\S",
    2008: " 27F^KFK[ RLFL[ RXFX[ RYFY[ RHFOF RUF\\F RLPXP RH[O[ RU[\\[",
    2009: " 12MXRFR[ RSFS[ ROFVF RO[V[",
    2010: " 20KZUFUWTZR[P[NZMXMVNUOVNW RTFTWSZR[ RQFXF",
    2011: " 27F\\KFK[ RLFL[ RYFLS RQOY[ RPOX[ RHFOF RUF[F RH[O[ RU[[[",
    2012: " 14I[NFN[ ROFO[ RKFRF RK[Z[ZUY[",
    2013: " 30F_KFK[ RLFRX RKFR[ RYFR[ RYFY[ RZFZ[ RHFLF RYF]F RH[N[ RV[][",
    2014: " 21G^LFL[ RMFYY RMHY[ RYFY[ RIFMF RVF\\F RI[O[",
    2015: " 44G]QFNGLIKKJOJRKVLXNZQ[S[VZXXYVZRZOYKXIVGSFQF RQFOGMILKKOKRLVMXOZQ[ RS[UZWXXVYRYOXKWIUGSF",
    2016: " 29G]LFL[ RMFM[ RIFUFXGYHZJZMYOXPUQMQ RUFWGXHYJYMXOWPUQ RI[P[",
    2017: " 64G]QFNGLIKKJOJRKVLXNZQ[S[VZXXYVZRZOYKXIVGSFQF RQFOGMILKKOKRLVMXOZQ[ RS[UZWXXVYRYOXKWIUGSF RNYNXOVQURUTVUXV_W`Y`Z^Z] RUXV\\W^X_Y_Z^",
    2018: " 45G]LFL[ RMFM[ RIFUFXGYHZJZLYNXOUPMP RUFWGXHYJYLXNWOUP RI[P[ RRPTQURXYYZZZ[Y RTQUSWZX[Z[[Y[X",
    2019: " 34H\\XIYFYLXIVGSFPFMGKIKKLMMNOOUQWRYT RKKMMONUPWQXRYTYXWZT[Q[NZLXKUK[LX",
    2020: " 16I\\RFR[ RSFS[ RLFKLKFZFZLYF RO[V[",
    2021: " 23F^KFKULXNZQ[S[VZXXYUYF RLFLUMXOZQ[ RHFOF RVF\\F",
    2022: " 15H\\KFR[ RLFRX RYFR[ RIFOF RUF[F",
    2023: " 24F^JFN[ RKFNV RRFN[ RRFV[ RSFVV RZFV[ RGFNF RWF]F",
    2024: " 21H\\KFX[ RLFY[ RYFK[ RIFOF RUF[F RI[O[ RU[[[",
    2025: " 20H]KFRQR[ RLFSQS[ RZFSQ RIFOF RVF\\F RO[V[",
    2026: " 16H\\XFK[ RYFL[ RLFKLKFYF RK[Y[YUX[",
    2027: " 18H\\RFK[ RRFY[ RRIX[ RMUVU RI[O[ RU[[[",
    2028: " 45G]LFL[ RMFM[ RIFUFXGYHZJZLYNXOUP RUFWGXHYJYLXNWOUP RMPUPXQYRZTZWYYXZU[I[ RUPWQXRYTYWXYWZU[",
    2029: " 14I[NFN[ ROFO[ RKFZFZLYF RK[R[",
    2030: " 15H\\RFJ[ RRFZ[ RRIY[ RKZYZ RJ[Z[",
    2031: " 22G\\LFL[ RMFM[ RSLST RIFYFYLXF RMPSP RI[Y[YUX[",
    2032: " 16H\\XFK[ RYFL[ RLFKLKFYF RK[Y[YUX[",
    2033: " 27F^KFK[ RLFL[ RXFX[ RYFY[ RHFOF RUF\\F RLPXP RH[O[ RU[\\[",
    2034: " 56G]QFNGLIKKJOJRKVLXNZQ[S[VZXXYVZRZOYKXIVGSFQF RQFOGMILKKOKRLVMXOZQ[ RS[UZWXXVYRYOXKWIUGSF ROMOT RUMUT ROPUP ROQUQ",
    2035: " 12MXRFR[ RSFS[ ROFVF RO[V[",
    2036: " 27F\\KFK[ RLFL[ RYFLS RQOY[ RPOX[ RHFOF RUF[F RH[O[ RU[[[",
    2037: " 15H\\RFK[ RRFY[ RRIX[ RI[O[ RU[[[",
    2038: " 30F_KFK[ RLFRX RKFR[ RYFR[ RYFY[ RZFZ[ RHFLF RYF]F RH[N[ RV[][",
    2039: " 21G^LFL[ RMFYY RMHY[ RYFY[ RIFMF RVF\\F RI[O[",
    2040: " 36G]KEJJ RZEYJ RONNS RVNUS RKWJ\\ RZWY\\ RKGYG RKHYH ROPUP ROQUQ RKYYY RKZYZ",
    2041: " 44G]QFNGLIKKJOJRKVLXNZQ[S[VZXXYVZRZOYKXIVGSFQF RQFOGMILKKOKRLVMXOZQ[ RS[UZWXXVYRYOXKWIUGSF",
    2042: " 21F^KFK[ RLFL[ RXFX[ RYFY[ RHF\\F RH[O[ RU[\\[",
    2043: " 29G]LFL[ RMFM[ RIFUFXGYHZJZMYOXPUQMQ RUFWGXHYJYMXOWPUQ RI[P[",
    2044: " 20H]KFRPJ[ RJFQP RJFYFZLXF RKZXZ RJ[Y[ZUX[",
    2045: " 16I\\RFR[ RSFS[ RLFKLKFZFZLYF RO[V[",
    2046: " 33I\\KKKILGMFOFPGQIRMR[ RKIMGOGQI RZKZIYGXFVFUGTISMS[ RZIXGVGTI RO[V[",
    2047: " 48H]RFR[ RSFS[ RPKMLLMKOKRLTMUPVUVXUYTZRZOYMXLUKPK RPKNLMMLOLRMTNUPV RUVWUXTYRYOXMWLUK ROFVF RO[V[",
    2048: " 21H\\KFX[ RLFY[ RYFK[ RIFOF RUF[F RI[O[ RU[[[",
    2049: " 41G^RFR[ RSFS[ RIMJLLMMQNSOTQU RJLKMLQMSNTQUTUWTXSYQZM[L RTUVTWSXQYM[L\\M ROFVF RO[V[",
    2050: " 43G]JXK[O[MWKSJPJLKIMGPFTFWGYIZLZPYSWWU[Y[ZX RMWLTKPKLLINGPF RTFVGXIYLYPXTWW RKZNZ RVZYZ",
    2051: " 18H\\UFH[ RUFV[ RTHU[ RLUUU RF[L[ RR[X[",
    2052: " 41F^OFI[ RPFJ[ RLFWFZG[I[KZNYOVP RWFYGZIZKYNXOVP RMPVPXQYSYUXXVZR[F[ RVPWQXSXUWXUZR[",
    2053: " 34H]ZH[H\\F[L[JZHYGWFTFQGOIMLLOKSKVLYMZP[S[UZWXXV RTFRGPINLMOLSLVMYNZP[",
    2054: " 30F]OFI[ RPFJ[ RLFUFXGYHZKZOYSWWUYSZO[F[ RUFWGXHYKYOXSVWTYRZO[",
    2055: " 22F]OFI[ RPFJ[ RTLRT RLF[FZLZF RMPSP RF[U[WVT[",
    2056: " 20F\\OFI[ RPFJ[ RTLRT RLF[FZLZF RMPSP RF[M[",
    2057: " 42H^ZH[H\\F[L[JZHYGWFTFQGOIMLLOKSKVLYMZP[R[UZWXYT RTFRGPINLMOLSLVMYNZP[ RR[TZVXXT RUT\\T",
    2058: " 27E_NFH[ ROFI[ R[FU[ R\\FV[ RKFRF RXF_F RLPXP RE[L[ RR[Y[",
    2059: " 12LYUFO[ RVFP[ RRFYF RL[S[",
    2060: " 21I[XFSWRYQZO[M[KZJXJVKULVKW RWFRWQYO[ RTF[F",
    2061: " 27F]OFI[ RPFJ[ R]FLS RSOW[ RROV[ RLFSF RYF_F RF[M[ RS[Y[",
    2062: " 14H\\QFK[ RRFL[ RNFUF RH[W[YUV[",
    2063: " 30E`NFH[ RNFO[ ROFPY R\\FO[ R\\FV[ R]FW[ RKFOF R\\F`F RE[K[ RS[Z[",
    2064: " 21F_OFI[ ROFVX ROIV[ R\\FV[ RLFOF RYF_F RF[L[",
    2065: " 42G]SFPGNILLKOJSJVKYLZN[Q[TZVXXUYRZNZKYHXGVFSF RSFQGOIMLLOKSKVLYN[ RQ[SZUXWUXRYNYKXHVF",
    2066: " 27F]OFI[ RPFJ[ RLFXF[G\\I\\K[NYPUQMQ RXFZG[I[KZNXPUQ RF[M[",
    2067: " 61G]SFPGNILLKOJSJVKYLZN[Q[TZVXXUYRZNZKYHXGVFSF RSFQGOIMLLOKSKVLYN[ RQ[SZUXWUXRYNYKXHVF RLYLXMVOUPURVSXS_T`V`W^W] RSXT^U_V_W^",
    2068: " 42F^OFI[ RPFJ[ RLFWFZG[I[KZNYOVPMP RWFYGZIZKYNXOVP RRPTQURVZW[Y[ZYZX RURWYXZYZZY RF[M[",
    2069: " 35G^ZH[H\\F[L[JZHYGVFRFOGMIMKNMONVRXT RMKOMVQWRXTXWWYVZS[O[LZKYJWJUI[JYKY",
    2070: " 16H]UFO[ RVFP[ ROFLLNF]F\\L\\F RL[S[",
    2071: " 25F_NFKQJUJXKZN[R[UZWXXU\\F ROFLQKUKXLZN[ RKFRF RYF_F",
    2072: " 15H\\NFO[ ROFPY R\\FO[ RLFRF RXF^F",
    2073: " 24E_MFK[ RNFLY RUFK[ RUFS[ RVFTY R]FS[ RJFQF RZF`F",
    2074: " 21G]NFU[ ROFV[ R\\FH[ RLFRF RXF^F RF[L[ RR[X[",
    2075: " 20H]NFRPO[ ROFSPP[ R]FSP RLFRF RYF_F RL[S[",
    2076: " 16G][FH[ R\\FI[ ROFLLNF\\F RH[V[XUU[",
    2077: " 46H\\KILKXWYYY[ RLLXX RKIKKLMXYY[ RPPLTKVKXLZK[ RKVMZ RLTLVMXMZK[ RSSXN RVIVLWNYNYLWKVI RVIWLYN",
    2101: " 39I]NONPMPMONNPMTMVNWOXQXXYZZ[ RWOWXXZZ[[[ RWQVRPSMTLVLXMZP[S[UZWX RPSNTMVMXNZP[",
    2102: " 33G\\LFL[ RMFM[ RMPONQMSMVNXPYSYUXXVZS[Q[OZMX RSMUNWPXSXUWXUZS[ RIFMF",
    2103: " 28H[WPVQWRXQXPVNTMQMNNLPKSKULXNZQ[S[VZXX RQMONMPLSLUMXOZQ[",
    2104: " 36H]WFW[ RXFX[ RWPUNSMQMNNLPKSKULXNZQ[S[UZWX RQMONMPLSLUMXOZQ[ RTFXF RW[[[",
    2105: " 31H[LSXSXQWOVNTMQMNNLPKSKULXNZQ[S[VZXX RWSWPVN RQMONMPLSLUMXOZQ[",
    2106: " 22KXUGTHUIVHVGUFSFQGPIP[ RSFRGQIQ[ RMMUM RM[T[",
    2107: " 60I\\QMONNOMQMSNUOVQWSWUVVUWSWQVOUNSMQM RONNPNTOV RUVVTVPUN RVOWNYMYNWN RNUMVLXLYM[P\\U\\X]Y^ RLYMZP[U[X\\Y^Y_XaUbObLaK_K^L\\O[",
    2108: " 28G]LFL[ RMFM[ RMPONRMTMWNXPX[ RTMVNWPW[ RIFMF RI[P[ RT[[[",
    2109: " 18MXRFQGRHSGRF RRMR[ RSMS[ ROMSM RO[V[",
    2110: " 25MXSFRGSHTGSF RTMT_SaQbObNaN`O_P`Oa RSMS_RaQb RPMTM",
    2111: " 27G\\LFL[ RMFM[ RWMMW RRSX[ RQSW[ RIFMF RTMZM RI[P[ RT[Z[",
    2112: " 12MXRFR[ RSFS[ ROFSF RO[V[",
    2113: " 44BcGMG[ RHMH[ RHPJNMMOMRNSPS[ ROMQNRPR[ RSPUNXMZM]N^P^[ RZM\\N]P][ RDMHM RD[K[ RO[V[ RZ[a[",
    2114: " 28G]LML[ RMMM[ RMPONRMTMWNXPX[ RTMVNWPW[ RIMMM RI[P[ RT[[[",
    2115: " 36H\\QMNNLPKSKULXNZQ[S[VZXXYUYSXPVNSMQM RQMONMPLSLUMXOZQ[ RS[UZWXXUXSWPUNSM",
    2116: " 36G\\LMLb RMMMb RMPONQMSMVNXPYSYUXXVZS[Q[OZMX RSMUNWPXSXUWXUZS[ RIMMM RIbPb",
    2117: " 33H\\WMWb RXMXb RWPUNSMQMNNLPKSKULXNZQ[S[UZWX RQMONMPLSLUMXOZQ[ RTb[b",
    2118: " 23IZNMN[ ROMO[ ROSPPRNTMWMXNXOWPVOWN RKMOM RK[R[",
    2119: " 32J[WOXMXQWOVNTMPMNNMOMQNRPSUUWVXW RMPNQPRUTWUXVXYWZU[Q[OZNYMWM[NY",
    2120: " 16KZPFPWQZS[U[WZXX RQFQWRZS[ RMMUM",
    2121: " 28G]LMLXMZP[R[UZWX RMMMXNZP[ RWMW[ RXMX[ RIMMM RTMXM RW[[[",
    2122: " 15I[LMR[ RMMRY RXMR[ RJMPM RTMZM",
    2123: " 24F^JMN[ RKMNX RRMN[ RRMV[ RSMVX RZMV[ RGMNM RWM]M",
    2124: " 21H\\LMW[ RMMX[ RXML[ RJMPM RTMZM RJ[P[ RT[Z[",
    2125: " 22H[LMR[ RMMRY RXMR[P_NaLbKbJaK`La RJMPM RTMZM",
    2126: " 16I[WML[ RXMM[ RMMLQLMXM RL[X[XWW[",
    2127: " 40G^QMNNLPKRJUJXKZN[P[RZUWWTYPZM RQMONMPLRKUKXLZN[ RQMSMUNVPXXYZZ[ RSMTNUPWXXZZ[[[",
    2128: " 57G\\TFQGOIMMLPKTJZIb RTFRGPINMMPLTKZJb RTFVFXGYHYKXMWNTOPO RVFXHXKWMVNTO RPOTPVRWTWWVYUZR[P[NZMYLV RPOSPURVTVWUYTZR[",
    2129: " 28H\\IPKNMMOMQNROSRSVRZOb RJOLNPNRO RZMYPXRSYP^Nb RYMXPWRSY",
    2130: " 44I\\VNTMRMONMQLTLWMYNZP[R[UZWWXTXQWOSJRHRFSEUEWFYH RRMPNNQMTMXNZ RR[TZVWWTWPVNTKSISGTFVFYH",
    2131: " 32I[XPVNTMPMNNNPPRSS RPMONOPQRSS RSSNTLVLXMZP[S[UZWX RSSOTMVMXNZP[",
    2132: " 31I[TFRGQHQIRJUKZKZJWKSMPOMRLULWMYP[S]T_TaSbQbPa RULQONRMUMWNYP[",
    2133: " 32G]HQIOKMNMONOPNTL[ RMMNNNPMTK[ RNTPPRNTMVMXNYOYRXWUb RVMXOXRWWTb",
    2134: " 44F]GQHOJMMMNNNPMUMXNZO[ RLMMNMPLULXMZO[Q[SZUXWUXRYMYIXGVFTFRHRJSMUPWRZT RSZUWVUWRXMXIWGVF",
    2135: " 15LXRMPTOXOZP[S[UYVW RSMQTPXPZQ[",
    2136: " 29H\\NMJ[ ROMK[ RXMYNZNYMWMUNQROSMS ROSQTSZT[ ROSPTRZS[U[WZYW",
    2137: " 23H\\KFMFOGPHQJWXXZY[ RMFOHPJVXWZY[Z[ RRMJ[ RRMK[",
    2138: " 28F]MMGb RNMHb RMPLVLYN[P[RZTXVU RXMUXUZV[Y[[Y\\W RYMVXVZW[",
    2139: " 24H\\NML[ ROMNSMXL[ RYMXQVU RZMYPXRVUTWQYOZL[ RKMOM",
    2140: " 45IZTFRGQHQIRJUKXK RUKQLOMNONQPSSTVT RUKRLPMOOOQQSST RSTOUMVLXLZN\\S^T_TaRbPb RSTPUNVMXMZO\\S^",
    2141: " 32I[RMONMQLTLWMYNZP[R[UZWWXTXQWOVNTMRM RRMPNNQMTMXNZ RR[TZVWWTWPVN",
    2142: " 22G]PNL[ RPNM[ RVNV[ RVNW[ RIPKNNM[M RIPKONN[N",
    2143: " 31H[LVMYNZP[R[UZWWXTXQWOVNTMRMONMQLTHb RR[TZVWWTWPVN RRMPNNQMTIb",
    2144: " 35H][MQMNNLQKTKWLYMZO[Q[TZVWWTWQVOUNSM RQMONMQLTLXMZ RQ[SZUWVTVPUN RUN[N",
    2145: " 16H\\SNP[ RSNQ[ RJPLNOMZM RJPLOONZN",
    2146: " 31H\\IQJOLMOMPNPPNVNYP[ RNMONOPMVMYNZP[Q[TZVXXUYRYOXMWNXOYR RXUYO",
    2147: " 37G]ONMOKQJTJWKYLZN[Q[TZWXYUZRZOXMVMTORSPXMb RJWLYNZQZTYWWYU RZOXNVNTPRSPYNb",
    2148: " 23I[KMMMONPPU_VaWb RMMNNOPT_UaWbYb RZMYOWRM]K`Jb",
    2149: " 34F]UFOb RVFNb RGQHOJMMMNNNPMUMXOZRZTYWVYS RLMMNMPLULXMZO[R[TZVXXUYS[M",
    2150: " 44F]JQLOONNMLNJQITIWJZK[M[OZQWRT RIWJYKZMZOYQW RQTQWRZS[U[WZYWZTZQYNXMWNYOZQ RQWRYSZUZWYYW",
    2151: " 39H]XMVTUXUZV[Y[[Y\\W RYMWTVXVZW[ RVTVQUNSMQMNNLQKTKWLYMZO[Q[SZUWVT RQMONMQLTLXMZ",
    2152: " 36H[PFLSLVMYNZ RQFMS RMSNPPNRMTMVNWOXQXTWWUZR[P[NZMWMS RVNWPWTVWTZR[ RMFQF",
    2153: " 25I[WPWQXQXPWNUMRMONMQLTLWMYNZP[R[UZWW RRMPNNQMTMXNZ",
    2154: " 42H]ZFVTUXUZV[Y[[Y\\W R[FWTVXVZW[ RVTVQUNSMQMNNLQKTKWLYMZO[Q[SZUWVT RQMONMQLTLXMZ RWF[F",
    2155: " 26I[MVQUTTWRXPWNUMRMONMQLTLWMYNZP[R[UZWX RRMPNNQMTMXNZ",
    2156: " 35KZZGYHZI[H[GZFXFVGUHTJSMP[O_Na RXFVHUJTNRWQ[P^O`NaLbJbIaI`J_K`Ja ROMYM",
    2157: " 43H\\YMU[T^RaObLbJaI`I_J^K_J` RXMT[S^QaOb RVTVQUNSMQMNNLQKTKWLYMZO[Q[SZUWVT RQMONMQLTLXMZ",
    2158: " 31H]PFJ[ RQFK[ RMTOPQNSMUMWNXOXQVWVZW[ RUMWOWQUWUZV[Y[[Y\\W RMFQF",
    2159: " 26LYUFTGUHVGUF RMQNOPMSMTNTQRWRZS[ RRMSNSQQWQZR[U[WYXW",
    2160: " 32LYVFUGVHWGVF RNQOOQMTMUNUQR[Q^P`OaMbKbJaJ`K_L`Ka RSMTNTQQ[P^O`Mb",
    2161: " 34H\\PFJ[ RQFK[ RXNWOXPYOYNXMWMUNQROSMS ROSQTSZT[ ROSPTRZS[U[WZYW RMFQF",
    2162: " 18MYUFQTPXPZQ[T[VYWW RVFRTQXQZR[ RRFVF",
    2163: " 52AbBQCOEMHMINIPHTF[ RGMHNHPGTE[ RHTJPLNNMPMRNSOSQP[ RPMRORQO[ RRTTPVNXMZM\\N]O]Q[W[Z\\[ RZM\\O\\QZWZZ[[^[`YaW",
    2164: " 37F]GQHOJMMMNNNPMTK[ RLMMNMPLTJ[ RMTOPQNSMUMWNXOXQVWVZW[ RUMWOWQUWUZV[Y[[Y\\W",
    2165: " 32I[RMONMQLTLWMYNZP[R[UZWWXTXQWOVNTMRM RRMPNNQMTMXNZ RR[TZVWWTWPVN",
    2166: " 42G\\HQIOKMNMONOPNTJb RMMNNNPMTIb RNTOQQNSMUMWNXOYQYTXWVZS[Q[OZNWNT RWNXPXTWWUZS[ RFbMb",
    2167: " 33H\\XMRb RYMSb RVTVQUNSMQMNNLQKTKWLYMZO[Q[SZUWVT RQMONMQLTLXMZ RObVb",
    2168: " 26IZJQKOMMPMQNQPPTN[ ROMPNPPOTM[ RPTRPTNVMXMYNYOXPWOXN",
    2169: " 28J[XOXPYPYOXNUMRMONNONQORVVWW RNPOQVUWVWYVZS[P[MZLYLXMXMY",
    2170: " 18KYTFPTOXOZP[S[UYVW RUFQTPXPZQ[ RNMWM",
    2171: " 37F]GQHOJMMMNNNQLWLYN[ RLMMNMQKWKYLZN[P[RZTXVT RXMVTUXUZV[Y[[Y\\W RYMWTVXVZW[",
    2172: " 26H\\IQJOLMOMPNPQNWNYP[ RNMONOQMWMYNZP[Q[TZVXXUYQYMXMYO",
    2173: " 41C`DQEOGMJMKNKQIWIYK[ RIMJNJQHWHYIZK[M[OZQXRV RTMRVRYSZU[W[YZ[X\\V]R]M\\M]O RUMSVSYU[",
    2174: " 42H\\KQMNOMRMSOSR RQMRORRQVPXNZL[K[JZJYKXLYKZ RQVQYR[U[WZYW RYNXOYPZOZNYMXMVNTPSRRVRYS[",
    2175: " 41G\\HQIOKMNMONOQMWMYO[ RMMNNNQLWLYMZO[Q[SZUXWT RZMV[U^SaPbMbKaJ`J_K^L_K` RYMU[T^RaPb",
    2176: " 31H\\YMXOVQNWLYK[ RLQMOOMRMVO RMOONRNVOXO RLYNYRZUZWY RNYR[U[WYXW",
    2177: " 43G^VGUHVIWHWGUFRFOGMILLL[ RRFPGNIMLM[ R\\G[H\\I]H]G\\FZFXGWIW[ RZFYGXIX[ RIM[M RI[P[ RT[[[",
    2178: " 33G]WGVHWIXHWGUFRFOGMILLL[ RRFPGNIMLM[ RWMW[ RXMX[ RIMXM RI[P[ RT[[[",
    2179: " 35G]VGUHVIWHWGUF RXFRFOGMILLL[ RRFPGNIMLM[ RWHW[ RXFX[ RIMWM RI[P[ RT[[[",
    2180: " 54BcRGQHRISHRGPFMFJGHIGLG[ RMFKGIIHLH[ R]G\\H]I^H]G[FXFUGSIRLR[ RXFVGTISLS[ R]M][ R^M^[ RDM^M RD[K[ RO[V[ RZ[a[",
    2181: " 56BcRGQHRISHRGPFMFJGHIGLG[ RMFKGIIHLH[ R\\G[H\\I]H]G[F R^FXFUGSIRLR[ RXFVGTISLS[ R]H][ R^F^[ RDM]M RD[K[ RO[V[ RZ[a[",
    2182: " 12MXRMR[ RSMS[ ROMSM RO[V[",
    2184: " 25IZWNUMRMONMPLSLVMYNZQ[T[VZ RRMPNNPMSMVNYOZQ[ RMTUT",
    2185: " 43I\\TFQGOJNLMOLTLXMZO[Q[TZVWWUXRYMYIXGVFTF RTFRGPJOLNOMTMXNZO[ RQ[SZUWVUWRXMXIWGVF RNPWP",
    2186: " 42G]UFOb RVFNb RQMMNKPJSJVKXMZP[S[WZYXZUZRYPWNTMQM RQMNNLPKSKVLXNZP[ RS[VZXXYUYRXPVNTM",
    2187: " 27I[TMVNXPXOWNTMQMNNMOLQLSMUOWSZ RQMONNOMQMSNUSZT\\T^S_Q_",
    2190: " 45G]LMKNJPJRKUOYP[ RJRKTOXP[P]O`MbLbKaJ_J\\KXMTOQRNTMVMYNZPZTYXWZU[T[SZSXTWUXTY RVMXNYPYTXXWZ",
    2191: " 69E_YGXHYIZHYGWFTFQGOINKMNLRJ[I_Ha RTFRGPIOKNNLWK[J^I`HaFbDbCaC`D_E`Da R_G^H_I`H`G_F]F[GZHYJXMU[T_Sa R]F[HZJYNWWV[U^T`SaQbObNaN`O_P`Oa RIM^M",
    2192: " 52F^[GZH[I\\H[GXFUFRGPIOKNNMRK[J_Ia RUFSGQIPKONMWL[K^J`IaGbEbDaD`E_F`Ea RYMWTVXVZW[Z[\\Y]W RZMXTWXWZX[ RJMZM",
    2193: " 54F^YGXHYIZHZGXF R\\FUFRGPIOKNNMRK[J_Ia RUFSGQIPKONMWL[K^J`IaGbEbDaD`E_F`Ea R[FWTVXVZW[Z[\\Y]W R\\FXTWXWZX[ RJMYM",
    2194: " 86@cTGSHTIUHTGRFOFLGJIIKHNGRE[D_Ca ROFMGKIJKINGWF[E^D`CaAb?b>a>`?_@`?a R`G_H`IaH`G]FZFWGUITKSNRRP[O_Na RZFXGVIUKTNRWQ[P^O`NaLbJbIaI`J_K`Ja R^M\\T[X[Z\\[_[aYbW R_M]T\\X\\Z][ RDM_M",
    2195: " 88@cTGSHTIUHTGRFOFLGJIIKHNGRE[D_Ca ROFMGKIJKINGWF[E^D`CaAb?b>a>`?_@`?a R^G]H^I_H_G]F RaFZFWGUITKSNRRP[O_Na RZFXGVIUKTNRWQ[P^O`NaLbJbIaI`J_K`Ja R`F\\T[X[Z\\[_[aYbW RaF]T\\X\\Z][ RDM^M",
    2196: " 20LYMQNOPMSMTNTQRWRZS[ RRMSNSQQWQZR[U[WYXW",
    2200: " 40H\\QFNGLJKOKRLWNZQ[S[VZXWYRYOXJVGSFQF RQFOGNHMJLOLRMWNYOZQ[ RS[UZVYWWXRXOWJVHUGSF",
    2201: " 11H\\NJPISFS[ RRGR[ RN[W[",
    2202: " 45H\\LJMKLLKKKJLHMGPFTFWGXHYJYLXNUPPRNSLUKXK[ RTFVGWHXJXLWNTPPR RKYLXNXSZVZXYYX RNXS[W[XZYXYV",
    2203: " 47H\\LJMKLLKKKJLHMGPFTFWGXIXLWNTOQO RTFVGWIWLVNTO RTOVPXRYTYWXYWZT[P[MZLYKWKVLUMVLW RWQXTXWWYVZT[",
    2204: " 13H\\THT[ RUFU[ RUFJUZU RQ[X[",
    2205: " 39H\\MFKP RKPMNPMSMVNXPYSYUXXVZS[P[MZLYKWKVLUMVLW RSMUNWPXSXUWXUZS[ RMFWF RMGRGWF",
    2206: " 48H\\WIVJWKXJXIWGUFRFOGMILKKOKULXNZQ[S[VZXXYUYTXQVOSNRNOOMQLT RRFPGNIMKLOLUMXOZQ[ RS[UZWXXUXTWQUOSN",
    2207: " 31H\\KFKL RKJLHNFPFUIWIXHYF RLHNGPGUI RYFYIXLTQSSRVR[ RXLSQRSQVQ[",
    2208: " 63H\\PFMGLILLMNPOTOWNXLXIWGTFPF RPFNGMIMLNNPO RTOVNWLWIVGTF RPOMPLQKSKWLYMZP[T[WZXYYWYSXQWPTO RPONPMQLSLWMYNZP[ RT[VZWYXWXSWQVPTO",
    2209: " 48H\\XMWPURRSQSNRLPKMKLLINGQFSFVGXIYLYRXVWXUZR[O[MZLXLWMVNWMX RQSORMPLMLLMIOGQF RSFUGWIXLXRWVVXTZR[",
    2210: "  6MWRYQZR[SZRY",
    2211: "  8MWR[QZRYSZS\\R^Q_",
    2212: " 12MWRMQNROSNRM RRYQZR[SZRY",
    2213: " 14MWRMQNROSNRM RR[QZRYSZS\\R^Q_",
    2214: " 15MWRFQHRTSHRF RRHRN RRYQZR[SZRY",
    2215: " 32I[MJNKMLLKLJMHNGPFSFVGWHXJXLWNVORQRT RSFUGVHWJWLVNTP RRYQZR[SZRY",
    2216: "  6NVRFQM RSFQM",
    2217: " 12JZNFMM ROFMM RVFUM RWFUM",
    2218: " 14KYQFOGNINKOMQNSNUMVKVIUGSFQF",
    2219: "  9JZRFRR RMIWO RWIMO",
    2220: "  3G][BIb",
    2221: " 20KYVBTDRGPKOPOTPYR]T`Vb RTDRHQKPPPTQYR\\T`",
    2222: " 20KYNBPDRGTKUPUTTYR]P`Nb RPDRHSKTPTTSYR\\P`",
    2223: " 12KYOBOb RPBPb ROBVB RObVb",
    2224: " 12KYTBTb RUBUb RNBUB RNbUb",
    2225: " 40KYTBRCQDPFPHQJRKSMSOQQ RRCQEQGRISJTLTNSPORSTTVTXSZR[Q]Q_Ra RQSSUSWRYQZP\\P^Q`RaTb",
    2226: " 40KYPBRCSDTFTHSJRKQMQOSQ RRCSESGRIQJPLPNQPURQTPVPXQZR[S]S_Ra RSSQUQWRYSZT\\T^S`RaPb",
    2227: "  4KYUBNRUb",
    2228: "  4KYOBVROb",
    2229: "  3NVRBRb",
    2230: "  6KYOBOb RUBUb",
    2231: "  3E_IR[R",
    2232: "  6E_RIR[ RIR[R",
    2233: "  9F^RJR[ RJRZR RJ[Z[",
    2234: "  9F^RJR[ RJJZJ RJRZR",
    2235: "  6G]KKYY RYKKY",
    2236: "  6MWRQQRRSSRRQ",
    2237: " 15E_RIQJRKSJRI RIR[R RRYQZR[SZRY",
    2238: "  6E_IO[O RIU[U",
    2239: "  9E_YIK[ RIO[O RIU[U",
    2240: "  9E_IM[M RIR[R RIW[W",
    2241: "  4F^ZIJRZ[",
    2242: "  4F^JIZRJ[",
    2243: " 10F^ZFJMZT RJVZV RJ[Z[",
    2244: " 10F^JFZMJT RJVZV RJ[Z[",
    2245: " 21F_[WYWWVUTRPQOONMNKOJQJSKUMVOVQURTUPWNYM[M",
    2246: " 24F^IUISJPLONOPPTSVTXTZS[Q RISJQLPNPPQTTVUXUZT[Q[O",
    2247: "  8G]JTROZT RJTRPZT",
    2248: "  7LXTFOL RTFUGOL",
    2249: "  7LXPFUL RPFOGUL",
    2250: " 18H\\KFLHNJQKSKVJXHYF RKFLINKQLSLVKXIYF",
    2251: "  8MWRHQGRFSGSIRKQL",
    2252: "  8MWSFRGQIQKRLSKRJ",
    2253: "  8MWRHSGRFQGQIRKSL",
    2254: "  8MWQFRGSISKRLQKRJ",
    2255: " 10E[HMLMRY RKMR[ R[BR[",
    2256: " 13F^ZJSJOKMLKNJQJSKVMXOYSZZZ",
    2257: " 13F^JJJQKULWNYQZSZVYXWYUZQZJ",
    2258: " 13F^JJQJUKWLYNZQZSYVWXUYQZJZ",
    2259: " 13F^JZJSKOLMNKQJSJVKXMYOZSZZ",
    2260: " 16F^ZJSJOKMLKNJQJSKVMXOYSZZZ RJRVR",
    2261: " 11E_XP[RXT RUMZRUW RIRZR",
    2262: " 11JZPLRITL RMORJWO RRJR[",
    2263: " 11E_LPIRLT ROMJROW RJR[R",
    2264: " 11JZPXR[TX RMURZWU RRIRZ",
    2265: " 44I\\XRWOVNTMRMONMQLTLWMYNZP[R[UZWXXUYPYKXHWGUFRFPGOHOIPIPH RRMPNNQMTMXNZ RR[TZVXWUXPXKWHUF",
    2266: " 15H\\JFR[ RKFRY RZFR[ RJFZF RKGYG",
    2267: " 10AbDMIMRY RHNR[ Rb:R[",
    2268: " 32F^[CZD[E\\D\\C[BYBWCUETGSJRNPZO^N` RVDUFTJRVQZP]O_MaKbIbHaH`I_J`Ia",
    2269: " 50F^[CZD[E\\D\\C[BYBWCUETGSJRNPZO^N` RVDUFTJRVQZP]O_MaKbIbHaH`I_J`Ia RQKNLLNKQKSLVNXQYSYVXXVYSYQXNVLSKQK",
    2270: " 26F_\\S[UYVWVUUTTQPPONNLNJOIQISJULVNVPUQTTPUOWNYN[O\\Q\\S",
    2271: " 32F^[FI[ RNFPHPJOLMMKMIKIIJGLFNFPGSHVHYG[F RWTUUTWTYV[X[ZZ[X[VYTWT",
    2272: " 49F_[NZO[P\\O\\N[MZMYNXPVUTXRZP[M[JZIXIUJSPORMSKSIRGPFNGMIMKNNPQUXWZZ[[[\\Z\\Y RM[KZJXJUKSMQ RMKNMVXXZZ[",
    2273: " 56E`WNVLTKQKOLNMMPMSNUPVSVUUVS RQKOMNPNSOUPV RWKVSVUXVZV\\T]Q]O\\L[JYHWGTFQFNGLHJJILHOHRIUJWLYNZQ[T[WZYYZX RXKWSWUXV",
    2274: " 42H\\PBP_ RTBT_ RXIWJXKYJYIWGTFPFMGKIKKLMMNOOUQWRYT RKKMMONUPWQXRYTYXWZT[P[MZKXKWLVMWLX",
    2275: " 12H]SFLb RYFRb RLQZQ RKWYW",
    2276: " 46JZUITJUKVJVIUGSFQFOGNINKOMQOVR ROMTPVRWTWVVXTZ RPNNPMRMTNVPXU[ RNVSYU[V]V_UaSbQbOaN_N^O]P^O_",
    2277: " 30JZRFQHRJSHRF RRFRb RRQQTRbSTRQ RLMNNPMNLLM RLMXM RTMVNXMVLTM",
    2278: " 56JZRFQHRJSHRF RRFRT RRPQRSVRXQVSRRP RRTRb RR^Q`RbS`R^ RLMNNPMNLLM RLMXM RTMVNXMVLTM RL[N\\P[NZL[ RL[X[ RT[V\\X[VZT[",
    2279: " 12I\\XFX[ RKFXF RPPXP RK[X[",
    2281: " 38E`QFNGKIILHOHRIUKXNZQ[T[WZZX\\U]R]O\\LZIWGTFQF RROQPQQRRSRTQTPSORO RRPRQSQSPRP",
    2282: " 45J[PFNGOIQJ RPFOGOI RUFWGVITJ RUFVGVI RQJOKNLMNMQNSOTQUTUVTWSXQXNWLVKTJQJ RRUR[ RSUS[ RNXWX",
    2283: " 27I\\RFOGMILLLMMPORRSSSVRXPYMYLXIVGSFRF RRSR[ RSSS[ RNWWW",
    2284: " 28D`PFMGJIHLGOGSHVJYM[P\\T\\W[ZY\\V]S]O\\LZIWGTFPF RRFR\\ RGQ]Q",
    2285: " 31G`PMMNKPJSJTKWMYPZQZTYVWWTWSVPTNQMPM R]GWG[HUN R]G]M\\IVO R\\HVN",
    2286: " 28F\\IIJGLFOFQGRIRLQOPQNSKU ROFPGQIQMPPNS RVFT[ RWFS[ RKUYU",
    2287: " 30I\\MFMU RNFMQ RMQNOONQMTMWNXPXRWTUV RTMVNWPWRTXTZU[W[YY RKFNF",
    2288: " 44I\\RNOOMQLTLUMXOZR[S[VZXXYUYTXQVOSNRN RRHNJRFRN RSHWJSFSN RRSQTQURVSVTUTTSSRS RRTRUSUSTRT",
    2289: " 37G^QHRFR[ RTHSFS[ RJHKFKMLPNRQSRS RMHLFLNMQ R[HZFZMYPWRTSSS RXHYFYNXQ RNWWW",
    2290: " 31G]LFL[ RMFM[ RIFUFXGYHZJZMYOXPUQMQ RUFWGXHYJYMXOWPUQ RI[Y[YVX[",
    2291: " 24H[YGUGQHNJLMKPKSLVNYQ[U\\Y\\ RYGVHSJQMPPPSQVSYV[Y\\",
    2292: " 27F_OQMQKRJSIUIWJYKZM[O[QZRYSWSURSQROQ RSHPQ RZJRR R\\QST",
    2293: " 12H\\OKUY RUKOY RKOYU RYOKU",
    2294: " 48F^NVLUKUIVHXHYI[K\\L\\N[OYOXNVKRJOJMKJMHPGTGWHYJZMZOYRVVUXUYV[X\\Y\\[[\\Y\\X[VYUXUVV RJMKKMIPHTHWIYKZM",
    2295: " 48F^NMLNKNIMHKHJIHKGLGNHOJOKNMKQJTJVKYM[P\\T\\W[YYZVZTYQVMUKUJVHXGYG[H\\J\\K[MYNXNVM RJVKXMZP[T[WZYXZV",
    2317: " 12NVQQQSSSSQQQ RQQSS RSQQS",
    2318: " 18JZMPQRTTVVWYW[V]U^ RMQST RMRPSTUVWWY",
    2319: " 18JZWKVMTOPQMR RSPMS RUFVGWIWKVNTPQRMT",
    2320: " 36H\\SMONLPKRKTLVNWQWUVXTYRYPXNVMSM RXNSM RVMQNLP RONKR RLVQW RNWSVXT RUVYR",
    2321: " 36H\\SMONLPKRKTLVNWQWUVXTYRYPXNVMSM RXNSM RVMQNLP RONKR RLVQW RNWSVXT RUVYR",
    2322: " 34J[SMPNNPMRMTNVPWRWUVWTXRXPWNUMSM ROPUM RNRVN RMTWO RNUXP ROVWR RPWVT",
    2323: " 18JZOGO^ RUFU] RMNWL RMOWM RMWWU RMXWV",
    2324: " 18JZNFNX RVLV^ RNNVL RNOVM RNWVU RNXVV",
    2325: " 25JZNBNW RNNQLTLVMWOWQVSSUQVNW RNNQMTMVN RUMVOVQUSSU",
    2326: " 18E_HIHL R\\I\\L RHI\\I RHJ\\J RHK\\K RHL\\L",
    2327: " 18JZMNMQ RWNWQ RMNWN RMOWO RMPWP RMQWQ",
    2328: " 49JZMLWX RMLONQOTOVNWMWKUKUMTO RONTO RQOWM RVKVN RULWL RWXUVSUPUNVMWMYOYOWPU RUVPU RSUMW RNVNY RMXOX",
    2329: " 26JZPOOMOKMKMMNNPOSOUNWL RNKNN RMLOL RMMSO RPOUN RWLWY",
    2330: " 86A^GfHfIeIdHcGcFdFfGhIiKiNhPfQdR`RUQ;Q4R/S-U,V,X-Y/Y3X6W8U;P?JCHEFHEJDNDREVGYJ[N\\R\\V[XZZW[T[PZMYKWITHPHMIKKJNJRKUMW RGdGeHeHdGd RU;Q?LCIFGIFKENERFVGXJ[ RR\\U[WZYWZTZPYMXKVITH",
    2331: "103EfNSOUQVSVUUVSVQUOSNQNOONPMSMVNYP[S\\V\\Y[[Y\\W]T]P\\MZJXIUHRHOIMJKLIOHSHXI]KaMcPeTfYf]e`cba RKLJNIRIXJ\\L`NbQdUeYe]d_cba RPOTO ROPUP RNQVQ RNRVR RNSVS ROTUT RPUTU RaLaNcNcLaL RbLbN RaMcM RaVaXcXcVaV RbVbX RaWcW",
    2332: " 30D`H@Hd RM@Md RW@Wd R\\@\\d RMMWK RMNWL RMOWM RMWWU RMXWV RMYWW",
    2367: " 12NVQQQSSSSQQQ RQQSS RSQQS",
    2368: " 18JZMPQRTTVVWYW[V]U^ RMQST RMRPSTUVWWY",
    2369: " 18JZWKVMTOPQMR RSPMS RUFVGWIWKVNTPQRMT",
    2370: " 32H\\PMMNLOKQKSLUMVPWTWWVXUYSYQXOWNTMPM RMNLPLSMUNVPW RWVXTXQWOVNTM",
    2371: " 36H\\SMONLPKRKTLVNWQWUVXTYRYPXNVMSM RXNSM RVMQNLP RONKR RLVQW RNWSVXT RUVYR",
    2372: " 34J[SMPNNPMRMTNVPWRWUVWTXRXPWNUMSM ROPUM RNRVN RMTWO RNUXP ROVWR RPWVT",
    2373: " 18JZOGO^ RUFU] RMNWL RMOWM RMWWU RMXWV",
    2374: " 18JZNFNX RVLV^ RNNVL RNOVM RNWVU RNXVV",
    2375: " 25JZNBNW RNNQLTLVMWOWQVSSUQVNW RNNQMTMVN RUMVOVQUSSU",
    2376: " 18E_HIHL R\\I\\L RHI\\I RHJ\\J RHK\\K RHL\\L",
    2377: " 18JZMNMQ RWNWQ RMNWN RMOWO RMPWP RMQWQ",
    2378: " 36JZQCVMRTRU RULQS RTITKPRRUUY RW\\UYSXQXOYN[N]O_Ra RW\\UZSYOYO]P_Ra RSXPZN]",
    2379: " 26JZPOOMOKMKMMNNPOSOUNWL RNKNN RMLOL RMMSO RPOUN RWLSY",
    2380: " 86A^GfHfIeIdHcGcFdFfGhIiKiNhPfQdR`RUQ;Q4R/S-U,V,X-Y/Y3X6W8U;P?JCHEFHEJDNDREVGYJ[N\\R\\V[XZZW[T[PZMYKWITHPHMIKKJNJRKUMW RGdGeHeHdGd RU;Q?LCIFGIFKENERFVGXJ[ RR\\U[WZYWZTZPYMXKVITH",
    2381: " 89IjNQOOQNSNUOVQVSUUSVQVOUNTMQMNNKPISHWH[I^K`NaRaW`[_]]`ZcVfQiMk RWHZI]K_N`R`W_[^]\\`YcTgQi RPOTO ROPUP RNQVQ RNRVR RNSVS ROTUT RPUTU ReLeNgNgLeL RfLfN ReMgM ReVeXgXgVeV RfVfX ReWgW",
    2382: " 85D`H>Hf RI>If RM>Mf RQBSBSDQDQAR?T>W>Y?[A\\D\\I[LYNWOUOSNRLQNOQNROSQVRXSVUUWUYV[X\\[\\`[cYeWfTfReQcQ`S`SbQb RRBRD RQCSC RY?ZA[D[IZLYN RRLRNPQNRPSRVRX RYVZX[[[`ZcYe RR`Rb RQaSa",
    2401: " 21AcHBHb RIBIb R[B[b R\\B\\b RDB`B RDbMb RWb`b",
    2402: " 23BaGBQPFb RFBPP REBPQ REB\\B^I[B RGa\\a RFb\\b^[[b",
    2403: " 28I[X+U1R8P=OANFMNMVN^OcPgRlUsXy RU1S6Q<P@OFNNNVO^PdQhSnUs",
    2404: " 28I[L+O1R8T=UAVFWNWVV^UcTgRlOsLy RO1Q6S<T@UFVNVVU^TdShQnOs",
    2405: " 14I[M+MRMy RN+NRNy RM+X+ RMyXy",
    2406: " 14I[V+VRVy RW+WRWy RL+W+ RLyWy",
    2407: " 48I[V+S-Q/P1O4O8P<TDUGUJTMRP RS-Q0P4P8Q;UCVGVJUMRPNRRTUWVZV]UaQiPlPpQtSw RRTTWUZU]T`PhOlOpPsQuSwVy",
    2408: " 48I[N+Q-S/T1U4U8T<PDOGOJPMRP RQ-S0T4T8S;OCNGNJOMRPVRRTOWNZN]OaSiTlTpStQw RRTPWOZO]P`ThUlUpTsSuQwNy",
    2409: " 32I[V.S1Q4O8N=NCOIPMSXT\\UbUgTlSoQs RS1Q5P8O=OBPHQLTWU[VaVgUlSpQsNv",
    2410: " 32I[N.Q1S4U8V=VCUITMQXP\\ObOgPlQoSs RQ1S5T8U=UBTHSLPWO[NaNgOlQpSsVv",
    2411: ' 147Z:RARRo R@RQo R?RRr RZ"VJRr',
    2412: " 57Ca].\\.[/[0\\1]1^0^.],[+Y+W,U.T0S3R:QJQjPsOv R\\/\\0]0]/\\/ RR:Rj RU.T1S:SZRjQqPtOvMxKyIyGxFvFtGsHsItIuHvGv RGtGuHuHtGt",
    3001: " 36H\\RFKZ RQIW[ RRIX[ RRFY[ RMUVU RI[O[ RT[[[ RKZJ[ RKZM[ RWZU[ RWYV[ RXYZ[",
    3002: " 78G]LFL[ RMGMZ RNFN[ RIFUFXGYHZJZLYNXOUP RXHYJYLXN RUFWGXIXMWOUP RNPUPXQYRZTZWYYXZU[I[ RXRYTYWXY RUPWQXSXXWZU[ RJFLG RKFLH ROFNH RPFNG RLZJ[ RLYK[ RNYO[ RNZP[",
    3003: " 37G\\XIYFYLXIVGTFQFNGLIKKJNJSKVLXNZQ[T[VZXXYV RMILKKNKSLVMX RQFOGMJLNLSMWOZQ[",
    3004: " 62G]LFL[ RMGMZ RNFN[ RIFSFVGXIYKZNZSYVXXVZS[I[ RWIXKYNYSXVWX RSFUGWJXNXSWWUZS[ RJFLG RKFLH ROFNH RPFNG RLZJ[ RLYK[ RNYO[ RNZP[",
    3005: " 83G\\LFL[ RMGMZ RNFN[ RIFYFYL RNPTP RTLTT RI[Y[YU RJFLG RKFLH ROFNH RPFNG RTFYG RVFYH RWFYI RXFYL RTLSPTT RTNRPTR RTOPPTQ RLZJ[ RLYK[ RNYO[ RNZP[ RT[YZ RV[YY RW[YX RX[YU",
    3006: " 70G[LFL[ RMGMZ RNFN[ RIFYFYL RNPTP RTLTT RI[Q[ RJFLG RKFLH ROFNH RPFNG RTFYG RVFYH RWFYI RXFYL RTLSPTT RTNRPTR RTOPPTQ RLZJ[ RLYK[ RNYO[ RNZP[",
    3007: " 60G^XIYFYLXIVGTFQFNGLIKKJNJSKVLXNZQ[T[VZXZY[YS RMILKKNKSLVMX RQFOGMJLNLSMWOZQ[ RXTXY RWSWYVZ RTS\\S RUSWT RVSWU RZSYU R[SYT",
    3008: " 81F^KFK[ RLGLZ RMFM[ RWFW[ RXGXZ RYFY[ RHFPF RTF\\F RMPWP RH[P[ RT[\\[ RIFKG RJFKH RNFMH ROFMG RUFWG RVFWH RZFYH R[FYG RKZI[ RKYJ[ RMYN[ RMZO[ RWZU[ RWYV[ RYYZ[ RYZ[[",
    3009: " 39LXQFQ[ RRGRZ RSFS[ RNFVF RN[V[ ROFQG RPFQH RTFSH RUFSG RQZO[ RQYP[ RSYT[ RSZU[",
    3010: " 45JYSFSWRZQ[ RTGTWSZ RUFUWTZQ[O[MZLXLVMUNUOVOWNXMX RMVMWNWNVMV RPFXF RQFSG RRFSH RVFUH RWFUG",
    3011: " 69F\\KFK[ RLGLZ RMFM[ RXGMR RPPW[ RQPX[ RQNY[ RHFPF RUF[F RH[P[ RT[[[ RIFKG RJFKH RNFMH ROFMG RWFXG RZFXG RKZI[ RKYJ[ RMYN[ RMZO[ RWYU[ RWYZ[",
    3012: " 52I[NFN[ ROGOZ RPFP[ RKFSF RK[Z[ZU RLFNG RMFNH RQFPH RRFPG RNZL[ RNYM[ RPYQ[ RPZR[ RU[ZZ RW[ZY RX[ZX RY[ZU",
    3013: " 63E_JFJZ RJFQ[ RKFQX RLFRX RXFQ[ RXFX[ RYGYZ RZFZ[ RGFLF RXF]F RG[M[ RU[][ RHFJG R[FZH R\\FZG RJZH[ RJZL[ RXZV[ RXYW[ RZY[[ RZZ\\[",
    3014: " 39F^KFKZ RKFY[ RLFXX RMFYX RYGY[ RHFMF RVF\\F RH[N[ RIFKG RWFYG R[FYG RKZI[ RKZM[",
    3015: " 54G]QFNGLIKKJOJRKVLXNZQ[S[VZXXYVZRZOYKXIVGSFQF RMILKKNKSLVMX RWXXVYSYNXKWI RQFOGMJLNLSMWOZQ[ RS[UZWWXSXNWJUGSF",
    3016: " 59G]LFL[ RMGMZ RNFN[ RIFUFXGYHZJZMYOXPUQNQ RXHYJYMXO RUFWGXIXNWPUQ RI[Q[ RJFLG RKFLH ROFNH RPFNG RLZJ[ RLYK[ RNYO[ RNZP[",
    3017: " 77G]QFNGLIKKJOJRKVLXNZQ[S[VZXXYVZRZOYKXIVGSFQF RMILKKNKSLVMX RWXXVYSYNXKWI RQFOGMJLNLSMWOZQ[ RS[UZWWXSXNWJUGSF RNXOVQURUTVUXV^W`Y`Z^Z\\ RV\\W^X_Y_ RUXW]X^Y^Z]",
    3018: " 80G]LFL[ RMGMZ RNFN[ RIFUFXGYHZJZLYNXOUPNP RXHYJYLXN RUFWGXIXMWOUP RRPTQUSWYX[Z[[Y[W RWWXYYZZZ RTQURXXYYZY[X RI[Q[ RJFLG RKFLH ROFNH RPFNG RLZJ[ RLYK[ RNYO[ RNZP[",
    3019: " 44H\\XIYFYLXIVGSFPFMGKIKLLNOPURWSXUXXWZ RLLMNOOUQWRXT RMGLILKMMONUPXRYTYWXYWZT[Q[NZLXKUK[LX",
    3020: " 57H\\JFJL RQFQ[ RRGRZ RSFS[ RZFZL RJFZF RN[V[ RKFJL RLFJI RMFJH ROFJG RUFZG RWFZH RXFZI RYFZL RQZO[ RQYP[ RSYT[ RSZU[",
    3021: " 45F^KFKULXNZQ[S[VZXXYUYG RLGLVMX RMFMVNYOZQ[ RHFPF RVF\\F RIFKG RJFKH RNFMH ROFMG RWFYG R[FYG",
    3022: " 34H\\KFR[ RLFRXR[ RMFSX RYGR[ RIFPF RUF[F RJFLH RNFMH ROFMG RWFYG RZFYG",
    3023: " 55F^JFN[ RKFNVN[ RLFOV RRFOVN[ RRFV[ RSFVVV[ RTFWV RZGWVV[ RGFOF RRFTF RWF]F RHFKG RIFKH RMFLH RNFLG RXFZG R\\FZG",
    3024: " 54H\\KFW[ RLFX[ RMFY[ RXGLZ RIFPF RUF[F RI[O[ RT[[[ RJFMH RNFMH ROFMG RVFXG RZFXG RLZJ[ RLZN[ RWZU[ RWYV[ RWYZ[",
    3025: " 48G]JFQQQ[ RKFRQRZ RLFSQS[ RYGSQ RHFOF RVF\\F RN[V[ RIFKG RNFLG RWFYG R[FYG RQZO[ RQYP[ RSYT[ RSZU[",
    3026: " 41H\\YFKFKL RWFK[ RXFL[ RYFM[ RK[Y[YU RLFKL RMFKI RNFKH RPFKG RT[YZ RV[YY RW[YX RX[YU",
    3051: " 38H\\UFIZ RSJT[ RTHUZ RUFUHVYV[ RLUTU RF[L[ RQ[X[ RIZG[ RIZK[ RTZR[ RTYS[ RVYW[",
    3052: " 78F^OFI[ RPFJ[ RQFK[ RLFWFZG[I[KZNYOVP RYGZIZKYNXO RWFXGYIYKXNVP RNPVPXQYSYUXXVZR[F[ RWQXSXUWXUZ RVPWRWUVXTZR[ RMFPG RNFOH RRFPH RSFPG RJZG[ RJYH[ RKYL[ RJZM[",
    3053: " 41H]ZH[H\\F[L[JZHYGWFTFQGOIMLLOKSKVLYMZP[S[UZWXXV RQHOJNLMOLSLWMY RTFRGPJOLNOMSMXNZP[",
    3054: " 63F]OFI[ RPFJ[ RQFK[ RLFUFXGYHZKZOYSWWUYSZO[F[ RWGXHYKYOXSVWTY RUFWHXKXOWSUWRZO[ RMFPG RNFOH RRFPH RSFPG RJZG[ RJYH[ RKYL[ RJZM[",
    3055: " 80F]OFI[ RPFJ[ RQFK[ RULST RLF[FZL RNPTP RF[U[WV RMFPG RNFOH RRFPH RSFPG RWFZG RXFZH RYFZI RZFZL RULSPST RTNRPSR RTOQPSQ RJZG[ RJYH[ RKYL[ RJZM[ RP[UZ RR[UY RUYWV",
    3056: " 70F\\OFI[ RPFJ[ RQFK[ RULST RLF[FZL RNPTP RF[N[ RMFPG RNFOH RRFPH RSFPG RWFZG RXFZH RYFZI RZFZL RULSPST RTNRPSR RTOQPSQ RJZG[ RJYH[ RKYL[ RJZM[",
    3057: " 65H^ZH[H\\F[L[JZHYGWFTFQGOIMLLOKSKVLYMZP[R[UZWXYT RQHOJNLMOLSLWMY RVXWWXT RTFRGPJOLNOMSMXNZP[ RR[TZVWWT RTT\\T RUTWU RVTWW RZTXV R[TXU",
    3058: " 81E_NFH[ ROFI[ RPFJ[ RZFT[ R[FU[ R\\FV[ RKFSF RWF_F RLPXP RE[M[ RQ[Y[ RLFOG RMFNH RQFOH RRFOG RXF[G RYFZH R]F[H R^F[G RIZF[ RIYG[ RJYK[ RIZL[ RUZR[ RUYS[ RVYW[ RUZX[",
    3059: " 39KYTFN[ RUFO[ RVFP[ RQFYF RK[S[ RRFUG RSFTH RWFUH RXFUG ROZL[ ROYM[ RPYQ[ ROZR[",
    3060: " 47I\\WFRWQYO[ RXFTSSVRX RYFUSSXQZO[M[KZJXJVKULUMVMWLXKX RKVKWLWLVKV RTF\\F RUFXG RVFWH RZFXH R[FXG",
    3061: " 72F]OFI[ RPFJ[ RQFK[ R\\GMR RQOU[ RROV[ RSNWZ RLFTF RYF_F RF[N[ RR[Y[ RMFPG RNFOH RRFPH RSFPG RZF\\G R^F\\G RJZG[ RJYH[ RKYL[ RJZM[ RUZS[ RUYT[ RVYX[",
    3062: " 49H\\QFK[ RRFL[ RSFM[ RNFVF RH[W[YU ROFRG RPFQH RTFRH RUFRG RLZI[ RLYJ[ RMYN[ RLZO[ RR[WZ RT[XX RV[YU",
    3063: " 68D`MFGZ RMGNYN[ RNFOY ROFPX R[FPXN[ R[FU[ R\\FV[ R]FW[ RJFOF R[F`F RD[J[ RR[Z[ RKFMG RLFMH R^F\\H R_F\\G RGZE[ RGZI[ RVZS[ RVYT[ RWYX[ RVZY[",
    3064: " 43F_OFIZ ROFV[ RPFVX RQFWX R\\GWXV[ RLFQF RYF_F RF[L[ RMFPG RNFPH RZF\\G R^F\\G RIZG[ RIZK[",
    3065: " 56G]SFPGNILLKOJSJVKYLZN[Q[TZVXXUYRZNZKYHXGVFSF ROIMLLOKSKWLY RUXWUXRYNYJXH RSFQGOJNLMOLSLXMZN[ RQ[SZUWVUWRXNXIWGVF",
    3066: " 60F]OFI[ RPFJ[ RQFK[ RLFXF[G\\I\\K[NYPUQMQ RZG[I[KZNXP RXFYGZIZKYNWPUQ RF[N[ RMFPG RNFOH RRFPH RSFPG RJZG[ RJYH[ RKYL[ RJZM[",
    3067: " 78G]SFPGNILLKOJSJVKYLZN[Q[TZVXXUYRZNZKYHXGVFSF ROIMLLOKSKWLY RUXWUXRYNYJXH RSFQGOJNLMOLSLXMZN[ RQ[SZUWVUWRXNXIWGVF RLXMVOUPURVSXT]U^V^W] RT^U_V_ RSXS_T`V`W]W\\",
    3068: " 78F^OFI[ RPFJ[ RQFK[ RLFWFZG[I[KZNYOVPNP RYGZIZKYNXO RWFXGYIYKXNVP RRPTQURWXXYYYZX RWYXZYZ RURVZW[Y[ZXZW RF[N[ RMFPG RNFOH RRFPH RSFPG RJZG[ RJYH[ RKYL[ RJZM[",
    3069: " 44G^ZH[H\\F[L[JZHYGVFRFOGMIMLNNPPVSWUWXVZ RNLONVRWT ROGNINKOMUPWRXTXWWYVZS[O[LZKYJWJUI[JYKY",
    3070: " 54G]TFN[ RUFO[ RVFP[ RMFKL R]F\\L RMF]F RK[S[ RNFKL RPFLI RRFMG RYF\\G RZF\\H R[F\\I R\\F\\L ROZL[ ROYM[ RPYQ[ ROZR[",
    3071: " 48F_NFKQJUJXKZN[R[UZWXXU\\G ROFLQKUKYLZ RPFMQLULYN[ RKFSF RYF_F RLFOG RMFNH RQFOH RRFOG RZF\\G R^F\\G",
    3072: " 35H\\NFNHOYO[ ROGPX RPFQW R[GO[ RLFSF RXF^F RMFNH RQFPH RRFOG RYF[G R]F[G",
    3073: " 57E_MFMHKYK[ RNGLX ROFMW RUFMWK[ RUFUHSYS[ RVGTX RWFUW R]GUWS[ RJFRF RUFWF RZF`F RKFNG RLFMH RPFNI RQFNG R[F]G R_F]G",
    3074: " 54G]NFT[ ROFU[ RPFV[ R[GIZ RLFSF RXF^F RF[L[ RQ[X[ RMFOH RQFPH RRFPG RYF[G R]F[G RIZG[ RIZK[ RTZR[ RTYS[ RUYW[",
    3075: " 51G]MFQPN[ RNFRPO[ ROFSPP[ R\\GSP RKFRF RYF_F RK[S[ RLFNG RPFOH RQFNG RZF\\G R^F\\G ROZL[ ROYM[ RPYQ[ ROZR[",
    3076: " 35G]ZFH[ R[FI[ R\\FJ[ R\\FNFLL RH[V[XU ROFLL RPFMI RRFNG RR[VZ RT[WX RU[XU",
    3101: " 54I]NPNOOOOQMQMONNPMTMVNWOXQXXYZZ[ RVOWQWXXZ RTMUNVPVXWZZ[[[ RVRUSPTMULWLXMZP[S[UZVX RNUMWMXNZ RUSQTOUNWNXOZP[",
    3102: " 47G\\LFL[MZOZ RMGMY RIFNFNZ RNPONQMSMVNXPYSYUXXVZS[Q[OZNX RWPXRXVWX RSMUNVOWRWVVYUZS[ RJFLG RKFLH",
    3103: " 34H[WQWPVPVRXRXPVNTMQMNNLPKSKULXNZQ[S[VZXX RMPLRLVMX RQMONNOMRMVNYOZQ[",
    3104: " 52H]VFV[[[ RWGWZ RSFXFX[ RVPUNSMQMNNLPKSKULXNZQ[S[UZVX RMPLRLVMX RQMONNOMRMVNYOZQ[ RTFVG RUFVH RXYY[ RXZZ[",
    3105: " 41H[MSXSXQWOVNSMQMNNLPKSKULXNZQ[S[VZXX RWRWQVO RMPLRLVMX RVSVPUNSM RQMONNOMRMVNYOZQ[",
    3106: " 40KYWHWGVGVIXIXGWFTFRGQHPKP[ RRHQKQZ RTFSGRIR[ RMMVM RM[U[ RPZN[ RPYO[ RRYS[ RRZT[",
    3107: " 89I\\XNYOZNYMXMVNUO RQMONNOMQMSNUOVQWSWUVVUWSWQVOUNSMQM ROONQNSOU RUUVSVQUO RQMPNOPOTPVQW RSWTVUTUPTNSM RNUMVLXLYM[N\\Q]U]X^Y_ RN[Q\\U\\X] RLYMZP[U[X\\Y^Y_XaUbObLaK_K^L\\O[ RObMaL_L^M\\O[",
    3108: " 65G^LFL[ RMGMZ RIFNFN[ RNQOOPNRMUMWNXOYRY[ RWOXRXZ RUMVNWQW[ RI[Q[ RT[\\[ RJFLG RKFLH RLZJ[ RLYK[ RNYO[ RNZP[ RWZU[ RWYV[ RYYZ[ RYZ[[",
    3109: " 43LXQFQHSHSFQF RRFRH RQGSG RQMQ[ RRNRZ RNMSMS[ RN[V[ ROMQN RPMQO RQZO[ RQYP[ RSYT[ RSZU[",
    3110: " 41KXRFRHTHTFRF RSFSH RRGTG RRMR^QaPb RSNS]R` ROMTMT]S`RaPbMbLaL_N_NaMaM` RPMRN RQMRO",
    3111: " 61G]LFL[ RMGMZ RIFNFN[ RWNNW RRSY[ RRTX[ RQTW[ RTM[M RI[Q[ RT[[[ RJFLG RKFLH RUMWN RZMWN RLZJ[ RLYK[ RNYO[ RNZP[ RWYU[ RVYZ[",
    3112: " 31LXQFQ[ RRGRZ RNFSFS[ RN[V[ ROFQG RPFQH RQZO[ RQYP[ RSYT[ RSZU[",
    3113: " 99AcFMF[ RGNGZ RCMHMH[ RHQIOJNLMOMQNROSRS[ RQORRRZ ROMPNQQQ[ RSQTOUNWMZM\\N]O^R^[ R\\O]R]Z RZM[N\\Q\\[ RC[K[ RN[V[ RY[a[ RDMFN REMFO RFZD[ RFYE[ RHYI[ RHZJ[ RQZO[ RQYP[ RSYT[ RSZU[ R\\ZZ[ R\\Y[[ R^Y_[ R^Z`[",
    3114: " 65G^LML[ RMNMZ RIMNMN[ RNQOOPNRMUMWNXOYRY[ RWOXRXZ RUMVNWQW[ RI[Q[ RT[\\[ RJMLN RKMLO RLZJ[ RLYK[ RNYO[ RNZP[ RWZU[ RWYV[ RYYZ[ RYZ[[",
    3115: " 46H\\QMNNLPKSKULXNZQ[S[VZXXYUYSXPVNSMQM RMPLRLVMX RWXXVXRWP RQMONNOMRMVNYOZQ[ RS[UZVYWVWRVOUNSM",
    3116: " 60G\\LMLb RMNMa RIMNMNb RNPONQMSMVNXPYSYUXXVZS[Q[OZNX RWPXRXVWX RSMUNVOWRWVVYUZS[ RIbQb RJMLN RKMLO RLaJb RL`Kb RN`Ob RNaPb",
    3117: " 55H\\VNVb RWOWa RUNWNXMXb RVPUNSMQMNNLPKSKULXNZQ[S[UZVX RMPLRLVMX RQMONNOMRMVNYOZQ[ RSb[b RVaTb RV`Ub RX`Yb RXaZb",
    3118: " 43IZNMN[ RONOZ RKMPMP[ RWOWNVNVPXPXNWMUMSNQPPS RK[S[ RLMNN RMMNO RNZL[ RNYM[ RPYQ[ RPZR[",
    3119: " 43J[WOXMXQWOVNTMPMNNMOMQNSPTUUWVXY RNNMQ RNRPSUTWU RXVWZ RMONQPRUSWTXVXYWZU[Q[OZNYMWM[NY",
    3120: " 22KZPHPVQYRZT[V[XZYX RQHQWRY RPHRFRWSZT[ RMMVM",
    3121: " 43G^LMLVMYNZP[S[UZVYWW RMNMWNY RIMNMNWOZP[ RWMW[\\[ RXNXZ RTMYMY[ RJMLN RKMLO RYYZ[ RYZ[[",
    3122: " 31I[LMR[ RMMRY RNMSY RXNSYR[ RJMQM RTMZM RKMNO RPMNN RVMXN RYMXN",
    3123: " 45F^JMN[ RKMNX RLMOX RRMOXN[ RRMV[ RSMVX RRMTMWX RZNWXV[ RGMOM RWM]M RHMKN RNMLN RXMZN R\\MZN",
    3124: " 48H\\LMV[ RMMW[ RNMX[ RWNMZ RJMQM RTMZM RJ[P[ RS[Z[ RKMMN RPMNN RUMWN RYMWN RMZK[ RMZO[ RVZT[ RWZY[",
    3125: " 40H[LMR[ RMMRY RNMSY RXNSYP_NaLbJbIaI_K_KaJaJ` RJMQM RTMZM RKMNO RPMNN RVMXN RYMXN",
    3126: " 41I[VML[ RWMM[ RXMN[ RXMLMLQ RL[X[XW RMMLQ RNMLP ROMLO RQMLN RS[XZ RU[XY RV[XX RW[XW",
    3151: " 50G]WMUTUXVZW[Y[[Y\\W RXMVTVZ RWMYMWTVX RUTUQTNRMPMMNKQJTJVKYLZN[P[RZSYTWUT RNNLQKTKWLY RPMNOMQLTLWMZN[",
    3152: " 52I\\PFNMMSMWNYOZQ[S[VZXWYTYRXOWNUMSMQNPOOQNT RQFOMNQNWOZ RVYWWXTXQWO RMFRFPMNT RS[UYVWWTWQVNUM RNFQG ROFPH",
    3153: " 34I[WQWPVPVRXRXPWNUMRMONMQLTLVMYNZP[R[UZWW ROONQMTMWNY RRMPOOQNTNWOZP[",
    3154: " 58G]YFVQUUUXVZW[Y[[Y\\W RZFWQVUVZ RVF[FWTVX RUTUQTNRMPMMNKQJTJVKYLZN[P[RZSYTWUT RMOLQKTKWLY RPMNOMQLTLWMZN[ RWFZG RXFYH",
    3155: " 33I[MVQUTTWRXPWNUMRMONMQLTLVMYNZP[R[UZWX ROONQMTMWNY RRMPOOQNTNWOZP[",
    3156: " 45JZZHZGYGYI[I[GZFXFVGTISKRNQRO[N^M`Kb RTJSMRRP[O^ RXFVHUJTMSRQZP]O_MaKbIbHaH_J_JaIaI` RNMYM",
    3157: " 57H]XMT[S^QaOb RYMU[S_ RXMZMV[T_RaObLbJaI`I^K^K`J`J_ RVTVQUNSMQMNNLQKTKVLYMZO[Q[SZTYUWVT RNOMQLTLWMY RQMOONQMTMWNZO[",
    3158: " 41G]OFI[K[ RPFJ[ RLFQFK[ RMTOPQNSMUMWNXPXSVX RWNWRVVVZ RWPUUUXVZW[Y[[Y\\W RMFPG RNFOH",
    3159: " 35KXSFSHUHUFSF RTFTH RSGUG RLQMOOMQMRNSPSSQX RRNRRQVQZ RRPPUPXQZR[T[VYWW",
    3160: " 45KXUFUHWHWFUF RVFVH RUGWG RMQNOPMRMSNTPTSRZQ]P_NaLbJbIaI_K_KaJaJ` RSNSSQZP]O_ RSPRTP[O^N`Lb",
    3161: " 49G]OFI[K[ RPFJ[ RLFQFK[ RYOYNXNXPZPZNYMWMUNQROS RMSOSQTRUTYUZWZ RQUSYTZ ROSPTRZS[U[WZYW RMFPG RNFOH",
    3162: " 26LXTFQQPUPXQZR[T[VYWW RUFRQQUQZ RQFVFRTQX RRFUG RSFTH",
    3163: " 61@cAQBODMFMGNHPHSF[ RGNGSE[ RGPFTD[F[ RHSJPLNNMPMRNSPSSQ[ RRNRSP[ RRPQTO[Q[ RSSUPWNYM[M]N^P^S\\X R]N]R\\V\\Z R]P[U[X\\Z][_[aYbW",
    3164: " 42F^GQHOJMLMMNNPNSL[ RMNMSK[ RMPLTJ[L[ RNSPPRNTMVMXNYPYSWX RXNXRWVWZ RXPVUVXWZX[Z[\\Y]W",
    3165: " 46H\\QMNNLQKTKVLYMZP[S[VZXWYTYRXOWNTMQM RNOMQLTLWMY RVYWWXTXQWO RQMOONQMTMWNZP[ RS[UYVWWTWQVNTM",
    3166: " 66G]HQIOKMMMNNOPOSNWKb RNNNSMWJb RNPMTIb ROTPQQORNTMVMXNYOZRZTYWWZT[R[PZOWOT RXOYQYTXWWY RVMWNXQXTWWVYT[ RFbNb RJaGb RJ`Hb RK`Lb RJaMb",
    3167: " 57G\\WMQb RXMRb RWMYMSb RUTUQTNRMPMMNKQJTJVKYLZN[P[RZSYTWUT RMOLQKTKWLY RPMNOMQLTLWMZN[ RNbVb RRaOb RR`Pb RS`Tb RRaUb",
    3168: " 30I[JQKOMMOMPNQPQTO[ RPNPTN[ RPPOTM[O[ RYOYNXNXPZPZNYMWMUNSPQT",
    3169: " 47J[XPXOWOWQYQYOXNUMRMONNONQOSQTTUVVWX RONNQ RORQSTTVU RWVVZ RNOOQQRTSVTWVWXVZS[P[MZLYLWNWNYMYMX",
    3170: " 23KYTFQQPUPXQZR[T[VYWW RUFRQQUQZ RTFVFRTQX RNMXM",
    3171: " 42F^GQHOJMLMMNNPNSLX RMNMRLVLZ RMPKUKXLZN[P[RZTXVU RXMVUVXWZX[Z[\\Y]W RYMWUWZ RXMZMXTWX",
    3172: " 29H\\IQJOLMNMONPPPSNX RONORNVNZ ROPMUMXNZP[R[TZVXXUYQYMXMXNYP",
    3173: " 48CaDQEOGMIMJNKPKSIX RJNJRIVIZ RJPHUHXIZK[M[OZQXRU RTMRURXSZU[W[YZ[X]U^Q^M]M]N^P RUMSUSZ RTMVMTTSX",
    3174: " 51G]JQLNNMPMRNSPSR RPMQNQRPVOXMZK[I[HZHXJXJZIZIY RRORRQVQY RZOZNYNYP[P[NZMXMVNTPSRRVRZS[ RPVPXQZS[U[WZYW",
    3175: " 49G]HQIOKMMMNNOPOSMX RNNNRMVMZ RNPLULXMZO[Q[SZUXWT RYMU[T^RaPb RZMV[T_ RYM[MW[U_SaPbMbKaJ`J^L^L`K`K_",
    3176: " 39H\\YMXOVQNWLYK[ RXOOOMPLR RVORNONNO RVORMOMMOLR RLYUYWXXV RNYRZUZVY RNYR[U[WYXV",
    3200: " 50H\\QFNGLJKOKRLWNZQ[S[VZXWYRYOXJVGSFQF RNHMJLNLSMWNY RVYWWXSXNWJVH RQFOGNIMNMSNXOZQ[ RS[UZVXWSWNVIUGSF",
    3201: " 28H\\QHQ[ RRHRZ RSFS[ RSFPINJ RM[W[ RQZO[ RQYP[ RSYT[ RSZU[",
    3202: " 62H\\LJLKMKMJLJ RLIMINJNKMLLLKKKJLHMGPFTFWGXHYJYLXNUPPRNSLUKXK[ RWHXJXLWN RTFVGWJWLVNTPPR RKYLXNXSYWYYX RNXSZWZXY RNXS[W[XZYXYV",
    3203: " 76H\\LJLKMKMJLJ RLIMINJNKMLLLKKKJLHMGPFTFWGXIXLWNTO RVGWIWLVN RSFUGVIVLUNSO RQOTOVPXRYTYWXYWZT[P[MZLYKWKVLUMUNVNWMXLX RWRXTXWWY RSOUPVQWTWWVZT[ RLVLWMWMVLV",
    3204: " 28H\\SIS[ RTHTZ RUFU[ RUFJUZU RP[X[ RSZQ[ RSYR[ RUYV[ RUZW[",
    3205: " 55H\\MFKPMNPMSMVNXPYSYUXXVZS[P[MZLYKWKVLUMUNVNWMXLX RWPXRXVWX RSMUNVOWRWVVYUZS[ RLVLWMWMVLV RMFWF RMGUG RMHQHUGWF",
    3206: " 69H\\VIVJWJWIVI RWHVHUIUJVKWKXJXIWGUFRFOGMILKKOKULXNZQ[S[VZXXYUYTXQVOSNQNOONPMR RNIMKLOLUMXNY RWXXVXSWQ RRFPGOHNJMNMUNXOZQ[ RS[UZVYWVWSVPUOSN",
    3207: " 43H\\KFKL RYFYIXLTQSSRWR[ RSRRTQWQ[ RXLSQQTPWP[R[ RKJLHNFPFUIWIXHYF RMHNGPGRH RKJLINHPHUI",
    3208: " 79H\\PFMGLILLMNPOTOWNXLXIWGTFPF RNGMIMLNN RVNWLWIVG RPFOGNINLONPO RTOUNVLVIUGTF RPOMPLQKSKWLYMZP[T[WZXYYWYSXQWPTO RMQLSLWMY RWYXWXSWQ RPONPMSMWNZP[ RT[VZWWWSVPTO",
    3209: " 69H\\MWMXNXNWMW RWOVQURSSQSNRLPKMKLLINGQFSFVGXIYLYRXVWXUZR[O[MZLXLWMVNVOWOXNYMY RMPLNLKMI RVHWIXLXRWVVX RQSORNQMNMKNHOGQF RSFUGVIWLWSVWUYTZR[",
    3316: "100E`HQHRISKSMRMOLMJJJHLF RLOJK RKSLRLPJMIKIIJGLFOFQGRHSJSU RSWS\\R^P_M_L^L\\M[N\\M] RQHRJR\\Q^ ROFPGQJQU RQWQ\\P^O_ RSJXF RXFZI[K\\O\\R[UYXV[ RWGZK[N[O RVHXJZM[P[SZVYX RWYUVSU RQUOVMX RWZUWSVPV RV[TXSW RQWOWMX",
    3404: " 47J[QFNINKOLSNVPWRWUVXTZ ROJOKSMVOWP ROHOIPJUMWOXRXUWXTZQ[ RRNNPNXMY ROPOXRZ RPOPXRYSZ RMYNYPZQ[",
    3405: " 27KXPUVQSMOPNRNWOYQ[UY RUQRN RPPOROWPYQZ RTRROQOPQPVQXSZ",
    2668: " 24LZLVNSPRRSRUP[ RPRQSQUO[ RRUTSVRWRVU RVRVUWWXWZV",
    2670: " 20NVNVPSRO RUFOXOZQ[SZTYVV RVFPXPZQ[ RPNVN"
  };

  // src/drawing.ts
  function export_mock_svg(dr) {
    let width = dr.w;
    let height = dr.h;
    let elements = dr.elements;
    let o = `<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}">`;
    for (let i = 0; i < elements.length; i++) {
      let elt = elements[i];
      let {tag, x, y, w, h} = elt;
      if (tag == "note_head") {
        if (elt.stem_dir < 0) {
          if (elt.twisted) {
            o += `<rect x="${x}" y="${y - 2}" width="${10}" height="${4}" fill="blue"/>`;
          } else {
            o += `<rect x="${x - 10}" y="${y - 2}" width="${10}" height="${4}" fill="blue"/>`;
          }
        } else {
          if (!elt.twisted) {
            o += `<rect x="${x}" y="${y - 2}" width="${10}" height="${4}" fill="blue"/>`;
          } else {
            o += `<rect x="${x - 10}" y="${y - 2}" width="${10}" height="${4}" fill="blue"/>`;
          }
        }
        o += `<text x="${x}" y="${y}" font-size="8" fill="red">${elt.duration}</text>`;
      } else if (tag == "rest") {
        o += `<rect x="${x - w / 2}" y="${y - h / 2}" width="${w}" height="${h}" fill="rgba(0,255,0,0.2)" stroke="black"/>`;
        o += `<text x="${x - w / 2}" y="${y - h / 2}" font-size="8">${elt.duration}</text>`;
      } else if (tag == "accidental" || tag == "clef" || tag == "timesig_digit") {
        o += `<rect x="${x - w / 2}" y="${y - h / 2}" width="${w}" height="${h}" fill="rgba(255,255,0,0.2)" stroke="black"/>`;
      } else if (tag == "beam") {
        o += `<line x1="${x}" y1="${y}" x2="${x + w}" y2="${y + h}" stroke="brown" stroke-width="3"/>`;
      } else if (tag == "line") {
        o += `<line x1="${x}" y1="${y}" x2="${x + w}" y2="${y + h}" stroke="black"/>`;
      } else if (tag == "dbg") {
        o += `<rect x="${x}" y="${y}" width="${w}" height="${h}" fill="${elt.color}" opacity="0.1"/>`;
      } else {
        o += `<rect x="${x}" y="${y}" width="${w || 1}" height="${h || 1}" fill="rgba(0,0,0,0.2)" stroke="black"/>`;
        o += `<text x="${x}" y="${y}" font-size="5">${tag}</text>`;
      }
    }
    o += `</svg>`;
    return o;
  }
  function xform(polylines, fn) {
    return polylines.map((p) => p.map((xy) => fn(xy[0], xy[1])));
  }
  function cubic_bezier(x0, y0, x1, y1, x2, y2, x3, y3, t) {
    let s = 1 - t;
    let s2 = s * s;
    let s3 = s * s2;
    let t2 = t * t;
    let t3 = t2 * t;
    return [
      s3 * x0 + 3 * s2 * t * x1 + 3 * s * t2 * x2 + t3 * x3,
      s3 * y0 + 3 * s2 * t * y1 + 3 * s * t2 * y2 + t3 * y3
    ];
  }
  var symbols = {};
  (function make_symbols() {
    function note_var(p2, stem_dir, twisted) {
      if (stem_dir < 0) {
        if (twisted) {
          p2 = xform(p2, (u, v) => [u + 5, v]);
        } else {
          p2 = xform(p2, (u, v) => [u - 6, v]);
        }
      } else {
        if (twisted) {
          p2 = xform(p2, (u, v) => [u - 6, v]);
        } else {
          p2 = xform(p2, (u, v) => [u + 5, v]);
        }
      }
      return p2;
    }
    let p;
    {
      p = HERSHEY(2370).polylines;
      symbols["note_whole_up_twist"] = note_var(p, -1, true);
      symbols["note_whole_down_twist"] = note_var(p, 1, true);
      symbols["note_whole_up"] = note_var(p, -1, false);
      symbols["note_whole_down"] = note_var(p, 1, false);
    }
    {
      p = HERSHEY(2371).polylines;
      p = xform(p, (u, v) => scale_axis(u, v, 1, 0.9, 0.4634));
      p = p.slice(0, 1).concat(xform(p.slice(0, 1), (u, v) => scale_axis(u, v, 1, 0.75, 0.4634)));
      p = xform(p, (u, v) => [u * 0.82 + 0.5, v]);
      symbols["note_half_up_twist"] = note_var(p, -1, true);
      symbols["note_half_down_twist"] = note_var(p, 1, true);
      symbols["note_half_up"] = note_var(p, -1, false);
      symbols["note_half_down"] = note_var(p, 1, false);
    }
    {
      p = HERSHEY(2372).polylines;
      p = xform(p, (u, v) => scale_axis(u, v, 1, 0.8, 0.4634));
      symbols["note_fill_up_twist"] = note_var(p, -1, true);
      symbols["note_fill_down_twist"] = note_var(p, 1, true);
      symbols["note_fill_up"] = note_var(p, -1, false);
      symbols["note_fill_down"] = note_var(p, 1, false);
    }
    {
      p = HERSHEY(2317).polylines;
      symbols["dot"] = xform(p, (u, v) => [u * 1.1, v * 1.1]);
    }
    {
      p = HERSHEY(2325).polylines;
      symbols["acc_flat"] = xform(p, (u, v) => [u * 0.7, v + 0.5]);
    }
    {
      p = HERSHEY(2324).polylines;
      symbols["acc_nat"] = xform(p, (u, v) => [u * 0.7, v]);
    }
    {
      p = HERSHEY(2323).polylines;
      p = xform(p, (u, v) => [u * 0.9, v * 1.1 - u * 0.2]);
      p[3] = xform(p.slice(3, 4), (u, v) => [u, v + 0.15])[0];
      p[5] = xform(p.slice(5, 6), (u, v) => [u, v + 0.15])[0];
      symbols["acc_sharp"] = p;
    }
    {
      p = HERSHEY(2380).polylines;
      symbols["clef_g"] = xform(p, (u, v) => rotate(u, v, -0.15));
    }
    {
      p = HERSHEY(2381).polylines;
      symbols["clef_f"] = xform(p, (u, v) => [u - 9, v]);
    }
    {
      p = HERSHEY(2382).polylines;
      symbols["clef_c"] = xform(p, (u, v) => [u, v * 0.9]);
    }
    {
      p = HERSHEY(2376).polylines;
      symbols["rest_whole"] = xform(p, (u, v) => [u * 0.85, v * 1.25 + 2.25]);
    }
    {
      p = HERSHEY(2377).polylines;
      symbols["rest_half"] = xform(p, (u, v) => [u, v * 1.25 + 1]);
    }
    {
      p = HERSHEY(2378).polylines;
      symbols["rest_quarter"] = xform(p, (u, v) => rotate(u, v, -0.1));
    }
    {
      p = HERSHEY(2379).polylines;
      symbols["rest_8"] = xform(p, (u, v) => [u, v]);
    }
    {
      p = HERSHEY(2379).polylines;
      let q = xform(p, (u, v) => [u, v]);
      q[q.length - 1][q[q.length - 1].length - 1][0] += 0.93;
      q[q.length - 1][q[q.length - 1].length - 1][1] -= 3;
      p = xform(p, (u, v) => [u - 3.07, v + 10]);
      symbols["rest_16"] = q.concat(p);
    }
    {
      p = HERSHEY(2379).polylines;
      let q = xform(p, (u, v) => [u, v]);
      q[q.length - 1][q[q.length - 1].length - 1][0] += 0.93;
      q[q.length - 1][q[q.length - 1].length - 1][1] -= 3;
      let a = xform(q, (u, v) => [u + 3.07, v - 10]);
      let c = xform(p, (u, v) => [u - 3.07, v + 10]);
      symbols["rest_32"] = a.concat(q).concat(c);
    }
    {
      p = HERSHEY(2379).polylines;
      let q = xform(p, (u, v) => [u, v]);
      q[q.length - 1][q[q.length - 1].length - 1][0] += 0.93;
      q[q.length - 1][q[q.length - 1].length - 1][1] -= 3;
      let a = xform(q, (u, v) => [u + 4.07, v - 10]);
      let b = xform(q, (u, v) => [u + 1, v]);
      let c = xform(p, (u, v) => [u - 2.07, v + 10]);
      let d = xform(p, (u, v) => [u - 5.14, v + 20]);
      symbols["rest_64"] = a.concat(b).concat(c).concat(d);
    }
    {
      p = HERSHEY(2368).polylines;
      p = xform(p, (u, v) => [u + 5, (v + 2.5) * 1.5]);
      symbols["flag_up"] = p;
      p = xform(p, (u, v) => [u, v]);
      p[0].pop();
      p[0].pop();
      p[0][p[0].length - 1][1] += 3;
      symbols["flag_mid_up"] = p;
    }
    {
      p = HERSHEY(2369).polylines;
      p = xform(p, (u, v) => [u + 5, (v - 2.5) * 1.5]);
      symbols["flag_down"] = p;
      p = xform(p, (u, v) => [u, v]);
      p[p.length - 1].shift();
      p[p.length - 1].shift();
      p[p.length - 1][0][1] -= 3;
      symbols["flag_mid_down"] = p;
    }
    {
      for (let i = 0; i < 10; i++) {
        p = HERSHEY(3200 + i).polylines;
        symbols["timesig_digit_" + i] = xform(p, (u, v) => [u, v * 0.85 + 1.1]);
      }
    }
    {
      for (let i = 0; i < 10; i++) {
        p = HERSHEY(2200 + i).polylines;
        symbols["tuplet_digit_" + i] = xform(p, (u, v) => [u * 0.5, v * 0.5]);
      }
    }
    {
      p = HERSHEY(3103).polylines;
      symbols["timesig_c"] = xform(p, (u, v) => [u, v * 1.2 - 2.5]);
    }
    {
      p = [[]];
      for (let i = 0; i < 8; i++) {
        let a = i / 7 * Math.PI;
        p[0].push([
          Math.cos(a) * 6,
          1 - Math.sin(a) * 6
        ]);
      }
      p.push([[-1, 1], [0, 0], [1, 1], [0, 2]]);
      symbols["fermata"] = p;
    }
    {
      p = [];
      p.push([
        [-8, 2],
        [-5, -1],
        [-2, 2],
        [1, -1],
        [4, 2],
        [7, -1]
      ]);
      p.push([
        [-4, -2],
        [-1, 1]
      ]);
      p.push([
        [2, -2],
        [5, 1]
      ]);
      symbols["mordent"] = p;
    }
    {
      p = HERSHEY(2274).polylines.slice(-2);
      p = xform(p, (u, v) => rotate(-u * 0.4, v * 0.6, Math.PI / 2));
      symbols["turn"] = p;
    }
    {
      p = xform(HERSHEY(2670).polylines, (u, v) => [u * 0.8 - 4, v * 0.8]).concat(xform(HERSHEY(2668).polylines, (u, v) => [u * 0.8 + 4.5, v * 0.8 - 0.5]));
      symbols["trill"] = p;
    }
    {
      p = xform(HERSHEY(2218).polylines, (u, v) => [u, v + 8]);
      symbols["flageolet"] = p;
    }
    {
      p = xform(HERSHEY(3316).polylines, (u, v) => [u * 0.8 - 11, v * 0.8 - 3]).concat(xform(HERSHEY(3405).polylines, (u, v) => [u * 0.8 + 0, v * 0.8])).concat(xform(HERSHEY(3404).polylines, (u, v) => [u * 0.8 + 8, v * 0.8])).concat([[[14, 6], [15, 5], [16, 6], [15, 7]]]);
      symbols["pedal_on"] = xform(p, (u, v) => [u, v + 3]);
    }
    {
      p = [];
      for (let i = 0; i < 8; i++) {
        let a = i / 8 * Math.PI * 2;
        p = p.concat(xform([
          [[2, -2], [3, 0], [7, -0.5], [9, -2], [11, 0], [9, 2], [7, 0.5], [3, 0], [2, 2]]
        ], (u, v) => rotate(u * 0.8, v * 0.8, a)));
      }
      symbols["pedal_off"] = p;
    }
    {
      p = xform(HERSHEY(2407).polylines, (u, v) => [(u - 5) * 1.25, v / 78 + 0.5]);
      p = xform(p, (u, v) => {
        return v < 0.5 ? [u - 2 * (v / 0.5) - 2, v] : [u - 2 * (1 - v) / 0.5 - 2, v];
      });
      symbols["brace"] = p;
    }
  })();
  function scale_axis(x, y, sx, sy, th) {
    let u = x * Math.cos(th) - y * Math.sin(th);
    let v = x * Math.sin(th) + y * Math.cos(th);
    u *= sx;
    v *= sy;
    return [
      u * Math.cos(-th) - v * Math.sin(-th),
      u * Math.sin(-th) + v * Math.cos(-th)
    ];
  }
  function rotate(x, y, th) {
    let u = x * Math.cos(th) - y * Math.sin(th);
    let v = x * Math.sin(th) + y * Math.cos(th);
    return [u, v];
  }
  function build_slur_bezier(elt) {
    let {tag, x, y, w, h} = elt;
    elt.pts = [];
    elt.pts1 = [];
    let n = 20;
    let sh = 0;
    let x0 = elt.x;
    let y0 = elt.y;
    let x3 = elt.x + elt.w;
    let y3 = elt.y1;
    let a = Math.atan2(y3 - y0, x3 - x0) + Math.PI / 2 * elt.dir;
    let hx = Math.cos(a) * h;
    let hy = Math.sin(a) * h;
    let m0x = x0 * 0.8 + x3 * 0.2;
    let m0y = y0 * 0.8 + y3 * 0.2;
    let m1x = x0 * 0.2 + x3 * 0.8;
    let m1y = y0 * 0.2 + y3 * 0.8;
    let x1a = m0x + hx;
    let y1a = m0y + hy;
    let x2a = m1x + hx;
    let y2a = m1y + hy;
    let x1b = elt.x + elt.w * 0.2;
    let y1b = elt.y + elt.dir * h;
    let x2b = elt.x + elt.w * 0.8;
    let y2b = elt.y1 + elt.dir * h;
    let x1 = x1a * 0.5 + x1b * 0.5;
    let y1 = y1a * 0.5 + y1b * 0.5;
    let x2 = x2a * 0.5 + x2b * 0.5;
    let y2 = y2a * 0.5 + y2b * 0.5;
    y0 += sh;
    y1 += sh;
    y2 += sh;
    y3 += sh;
    elt.control = [[x0, y0], [x1, y1], [x2, y2], [x3, y3]];
    let p = [];
    for (let i = 0; i < n; i++) {
      let t = i / (n - 1);
      elt.pts.push(cubic_bezier(x0, y0, x1, y1, x2, y2, x3, y3, t));
    }
    p = [];
    for (let i = 2; i < n - 2; i++) {
      let t = 1 - i / (n - 1);
      elt.pts1.push(cubic_bezier(x0, y0, x1, y1 - elt.dir, x2, y2 - elt.dir, x3, y3, t));
    }
  }
  function build_cue(elt) {
    let {tag, x, y, w, h} = elt;
    elt.pts = [];
    function push_all(p) {
      for (let i = 0; i < p.length; i++) {
        if (p[i].length <= 1)
          continue;
        elt.pts.push(p[i]);
      }
    }
    if (elt.text == CUE.PEDAL_ON) {
      let p = symbols["pedal_on"];
      let scl = elt.h / 24;
      push_all(xform(p, (u, v) => [x + u * scl, y + v * scl + h / 2]));
    } else if (elt.text == CUE.PEDAL_OFF) {
      let p = symbols["pedal_off"];
      let scl = elt.h / 24;
      push_all(xform(p, (u, v) => [x + u * scl, y + v * scl + h / 2]));
    } else if (elt.text == CUE.PIANISSISSIMO || elt.text == CUE.PIANISSIMO || elt.text == CUE.PIANO || elt.text == CUE.MEZZO_PIANO || elt.text == CUE.MEZZO_FORTE || elt.text == CUE.FORTE || elt.text == CUE.FORTISSIMO || elt.text == CUE.FORTISSISSIMO || elt.text == CUE.SFORZANDO) {
      let v = get_text_width(elt.text, FONT.TRIPLEX_ITALIC);
      let scl = elt.h / 30;
      let dx = -v / 2 * scl;
      for (let i = 0; i < elt.text.length; i++) {
        if (elt.text[i] == " ") {
          dx += 10 * scl;
          continue;
        }
        let a = ascii_map(elt.text[i], FONT.TRIPLEX_ITALIC);
        if (a === void 0) {
          continue;
        }
        let e = HERSHEY(a);
        push_all(xform(e.polylines, (u, v2) => [x + dx + (u - e.xmin) * scl, y + (v2 + 14) * scl]));
        dx += (e.xmax - e.xmin - 3) * scl;
      }
    } else {
      let v = get_text_width(elt.text, FONT.DUPLEX_ITALIC);
      let scl = elt.h / 40;
      let dx = 0;
      for (let i = 0; i < elt.text.length; i++) {
        if (elt.text[i] == " ") {
          dx += 10 * scl;
          continue;
        }
        let a = ascii_map(elt.text[i], FONT.DUPLEX_ITALIC);
        if (a === void 0) {
          continue;
        }
        let e = HERSHEY(a);
        push_all(xform(e.polylines, (u, v2) => [x + dx + (u - e.xmin) * scl, y + (v2 + 18) * scl]));
        dx += (e.xmax - e.xmin) * scl;
      }
    }
  }
  function bounding_box(p) {
    let xmin = Infinity;
    let ymin = Infinity;
    let xmax = -Infinity;
    let ymax = -Infinity;
    for (let i = 0; i < p.length; i++) {
      if (Array.isArray(p[i][0])) {
        for (let j = 0; j < p[i].length; j++) {
          xmin = Math.min(xmin, p[i][j][0]);
          ymin = Math.min(ymin, p[i][j][1]);
          xmax = Math.max(xmax, p[i][j][0]);
          ymax = Math.max(ymax, p[i][j][1]);
        }
      } else {
        xmin = Math.min(xmin, p[i][0]);
        ymin = Math.min(ymin, p[i][1]);
        xmax = Math.max(xmax, p[i][0]);
        ymax = Math.max(ymax, p[i][1]);
      }
    }
    return {x: xmin, y: ymin, w: xmax - xmin, h: ymax - ymin};
  }
  function box_overlap(a, b) {
    return a.x <= b.x + b.w && a.x + a.w >= b.x && a.y <= b.y + b.h && a.y + a.h >= b.y;
  }
  function point_in_box(x, y, b) {
    return b.x <= x && x <= b.x + b.w && b.y <= y && y <= b.y + b.h;
  }
  function cue_evade_slur(elements) {
    let slurs = [];
    let cues = [];
    for (let i = 0; i < elements.length; i++) {
      if (elements[i].tag == "cue") {
        if (!elements[i].pts) {
          build_cue(elements[i]);
        }
        if (!elements[i].bbox) {
          elements[i].bbox = bounding_box(elements[i].pts);
        }
        cues.push(elements[i]);
      } else if (elements[i].tag == "slur") {
        if (!elements[i].pts) {
          build_slur_bezier(elements[i]);
        }
        if (!elements[i].bbox) {
          elements[i].bbox = bounding_box(elements[i].pts);
        }
        slurs.push(elements[i]);
      } else if (elements[i].tag == "cresc") {
        let {x, y, w, h, x1, y1, w1, h1} = elements[i];
        elements[i].bbox = bounding_box([[x, y], [x + w, y + h], [x1, y1], [x1 + w1, y1 + h1]]);
        cues.push(elements[i]);
      }
    }
    function resolve_(cue, depth = 5) {
      if (depth <= 0) {
        return;
      }
      for (let j = 0; j < slurs.length; j++) {
        if (box_overlap(cue.bbox, slurs[j].bbox)) {
          let hit = false;
          let dir = null;
          for (let k = 0; k < slurs[j].pts.length; k++) {
            if (point_in_box(slurs[j].pts[k][0], slurs[j].pts[k][1], cue.bbox)) {
              hit = true;
              dir = cue.bbox.y + cue.bbox.h / 2 < slurs[j].bbox.y + slurs[j].bbox.h / 2 ? -1 : 1;
              break;
            }
          }
          if (hit) {
            let d = dir * Math.min(4, Math.max(2, depth));
            cue.y += d;
            cue.bbox.y += d;
            if (cue.y1 != void 0) {
              cue.y1 += d;
            }
            cue.pts = null;
            return resolve_(cue, depth - 1);
          }
        }
      }
    }
    for (let i = 0; i < cues.length; i++) {
      resolve_(cues[i]);
    }
  }
  function slur_evade_note(elements) {
    let slurs = [];
    let notes = [];
    for (let i = 0; i < elements.length; i++) {
      if (elements[i].tag == "note_head") {
        let elt = elements[i];
        let {x, y, w, h} = elt;
        x -= 1;
        y -= 1;
        w += 2;
        h += 2;
        if (!elt.bbox) {
          if (elt.stem_dir < 0) {
            if (elt.twisted) {
              elt.bbox = {x, y: y - h / 2, w, h};
            } else {
              elt.bbox = {x: x - w, y: y - h / 2, w, h};
            }
          } else {
            if (!elt.twisted) {
              elt.bbox = {x, y: y - h / 2, w, h};
            } else {
              elt.bbox = {x: x - w, y: y - h / 2, w, h};
            }
          }
        }
        notes.push(elements[i]);
      } else if (elements[i].tag == "slur") {
        if (!elements[i].pts) {
          build_slur_bezier(elements[i]);
        }
        if (!elements[i].bbox) {
          elements[i].bbox = bounding_box(elements[i].pts);
        }
        slurs.push(elements[i]);
      }
    }
    function resolve_(slur, depth = 5) {
      if (depth <= 0) {
        return;
      }
      for (let j = 0; j < notes.length; j++) {
        if (box_overlap(slur.bbox, notes[j].bbox)) {
          let hit = false;
          let dir = slur.dir;
          for (let k = 0; k < slur.pts.length; k++) {
            if (point_in_box(slur.pts[k][0], slur.pts[k][1], notes[j].bbox)) {
              hit = true;
              break;
            }
          }
          if (hit) {
            let d = dir * Math.min(4, Math.max(2, depth));
            slur.y += d;
            slur.y1 += d;
            slur.bbox.y += d;
            slur.pts.forEach((xy) => {
              xy[1] += d;
            });
            slur.pts1.forEach((xy) => {
              xy[1] += d;
            });
            return resolve_(slur, depth - 1);
          }
        }
      }
    }
    for (let i = 0; i < slurs.length; i++) {
      if (slurs[i].adjacent) {
        continue;
      }
      resolve_(slurs[i]);
    }
  }
  function hf_drawing_polylines(elements, width, height) {
    let polylines = [];
    function push_all(p) {
      for (let i = 0; i < p.length; i++) {
        if (p[i].length <= 1)
          continue;
        polylines.push(p[i]);
      }
    }
    for (let i = 0; i < elements.length; i++) {
      let elt = elements[i];
      let {tag, x, y, w, h} = elt;
      if (tag == "note_head") {
        let p;
        let key = (elt.stem_dir < 0 ? "_up" : "_down") + (elt.twisted ? "_twist" : "");
        if (elt.duration >= NOTE_LENGTH.WHOLE) {
          key = "note_whole" + key;
        } else if (elt.duration >= NOTE_LENGTH.HALF) {
          key = "note_half" + key;
        } else {
          key = "note_fill" + key;
        }
        p = symbols[key];
        if (elt.mini)
          p = xform(p, (u, v) => [u / 2, v / 2]);
        push_all(xform(p, (u, v) => [x + u, y + v]));
      } else if (tag == "dot") {
        let p = symbols["dot"];
        if (elt.mini)
          p = xform(p, (u, v) => [u / 2, v / 2]);
        push_all(xform(p, (u, v) => [x + u, y + v]));
      } else if (tag == "accidental") {
        let p;
        if (elt.type == ACCIDENTAL.FLAT) {
          p = symbols["acc_flat"];
        } else if (elt.type == ACCIDENTAL.NATURAL) {
          p = symbols["acc_nat"];
        } else if (elt.type == ACCIDENTAL.SHARP) {
          p = symbols["acc_sharp"];
        }
        if (elt.mini)
          p = xform(p, (u, v) => [u / 2, v / 2]);
        push_all(xform(p, (u, v) => [x + u, y + v]));
      } else if (tag == "clef") {
        let p;
        if (elt.type == CLEF.TREBLE) {
          p = symbols["clef_g"];
        } else if (elt.type == CLEF.BASS) {
          p = symbols["clef_f"];
        } else {
          p = symbols["clef_c"];
        }
        push_all(xform(p, (u, v) => [x + u, y + v]));
      } else if (tag == "rest") {
        if (elt.duration == NOTE_LENGTH.WHOLE) {
          let p = symbols["rest_whole"];
          push_all(xform(p, (u, v) => [x + u, y + v]));
        } else if (elt.duration == NOTE_LENGTH.HALF) {
          let p = symbols["rest_half"];
          push_all(xform(p, (u, v) => [x + u, y + v]));
        } else if (elt.duration == NOTE_LENGTH.QUARTER) {
          let p = symbols["rest_quarter"];
          push_all(xform(p, (u, v) => [x + u, y + v]));
        } else if (elt.duration == NOTE_LENGTH.EIGHTH) {
          let p = symbols["rest_8"];
          push_all(xform(p, (u, v) => [x + u, y + v]));
        } else if (elt.duration == NOTE_LENGTH.SIXTEENTH) {
          let p = symbols["rest_16"];
          push_all(xform(p, (u, v) => [x + u, y + v]));
        } else if (elt.duration == NOTE_LENGTH.THIRTYSECOND) {
          let p = symbols["rest_32"];
          push_all(xform(p, (u, v) => [x + u, y + v]));
        } else if (elt.duration == NOTE_LENGTH.SIXTYFOURTH) {
          let p = symbols["rest_64"];
          push_all(xform(p, (u, v) => [x + u, y + v]));
        }
      } else if (tag == "flag") {
        if (elt.stem_dir < 0) {
          let p = elt.is_last ? symbols["flag_up"] : symbols["flag_mid_up"];
          if (elt.mini)
            p = xform(p, (u, v) => [u / 2, v / 2]);
          push_all(xform(p, (u, v) => [x + u, y + v]));
        } else {
          let p = elt.is_last ? symbols["flag_down"] : symbols["flag_mid_down"];
          if (elt.mini)
            p = xform(p, (u, v) => [u / 2, v / 2]);
          push_all(xform(p, (u, v) => [x + u, y + v]));
        }
      } else if (tag == "beam") {
        for (let j = 0.3; j < 4.66; j += 1.09) {
          polylines.push([[x, y - j * elt.stem_dir], [x + w, y + h - j * elt.stem_dir]]);
        }
      } else if (tag == "line") {
        polylines.push([[x, y], [x + w, y + h]]);
      } else if (tag == "cresc") {
        let p = [
          [[x, y], [x + w, y + h]],
          [[elt.x1, elt.y1], [elt.x1 + elt.w1, elt.y1 + elt.h1]]
        ];
        push_all(p);
      } else if (tag == "slur") {
        if (!elt.pts) {
          build_slur_bezier(elt);
        }
        polylines.push(elt.pts);
        polylines.push(elt.pts1);
      } else if (tag == "timesig_digit") {
        let p = symbols["timesig_digit_" + elt.value];
        push_all(xform(p, (u, v) => [x + u, y + v]));
      } else if (tag == "timesig_c") {
        let p = symbols["timesig_c"];
        push_all(xform(p, (u, v) => [x + u, y + v]));
        if (elt.type == "cut") {
          polylines.push([[x, y - 14], [x, y + 14]]);
        }
      } else if (tag == "tuplet_label") {
        let digits = elt.label.toString().split("");
        let mid = x + w / 2;
        let mw = digits.length;
        let dw = 8;
        let dp = 4;
        let ml = mid - mw / 2 * dw - dp;
        let mr = mid + mw / 2 * dw + dp;
        if (ml >= x && mr <= x + w) {
          polylines.push([[x, y], [x, y + h], [ml, y + h]]);
          polylines.push([[mr, y + h], [x + w, y + h], [x + w, y]]);
        }
        for (let i2 = 0; i2 < digits.length; i2++) {
          let p = symbols["tuplet_digit_" + digits[i2]];
          push_all(xform(p, (u, v) => [ml + dp + dw * i2 + u + 4, y + h + v]));
        }
      } else if (tag == "lyric") {
        let scl = w / get_text_width(elt.text);
        let dx = -4 * scl;
        for (let i2 = 0; i2 < elt.text.length; i2++) {
          if (elt.text[i2] == " ") {
            dx += 10 * scl;
            continue;
          }
          let a = ascii_map(elt.text[i2]);
          if (a === void 0) {
            continue;
          }
          let e = HERSHEY(a);
          push_all(xform(e.polylines, (u, v) => [x + dx + (u - e.xmin) * scl, y + (v + 12) * scl]));
          dx += (e.xmax - e.xmin) * scl;
        }
      } else if (tag == "bold_text") {
        let scl = w / get_text_width(elt.text, FONT.TRIPLEX, -2);
        if (isNaN(scl))
          scl = 1;
        let dx = 0;
        for (let i2 = 0; i2 < elt.text.length; i2++) {
          if (elt.text[i2] == " ") {
            dx += 10 * scl;
            continue;
          }
          let a = ascii_map(elt.text[i2], FONT.TRIPLEX);
          if (a === void 0) {
            continue;
          }
          let e = HERSHEY(a);
          push_all(xform(e.polylines, (u, v) => [x + dx + (u - e.xmin) * scl, y + (v + 12) * scl]));
          dx += (e.xmax - e.xmin - 2) * scl;
        }
      } else if (tag == "regular_text") {
        let scl = w / get_text_width(elt.text, FONT.DUPLEX, -2);
        if (isNaN(scl))
          scl = 1;
        let dx = 0;
        for (let i2 = 0; i2 < elt.text.length; i2++) {
          if (elt.text[i2] == " ") {
            dx += 10 * scl;
            continue;
          }
          let a = ascii_map(elt.text[i2], FONT.DUPLEX);
          if (a === void 0) {
            continue;
          }
          let e = HERSHEY(a);
          push_all(xform(e.polylines, (u, v) => [x + dx + (u - e.xmin) * scl, y + (v + 12) * scl]));
          dx += (e.xmax - e.xmin - 2) * scl;
        }
      } else if (tag == "bracket") {
        if (elt.type == BRACKET.BRACE) {
          let p = symbols["brace"];
          push_all(xform(p, (u, v) => [x + u, y + v * h]));
        } else if (elt.type == BRACKET.BRACKET) {
          polylines.push([[x + 5, y - 12], [x - 2, y - 8], [x - 8, y - 7], [x - 8, y + h + 7], [x - 2, y + h + 8], [x + 5, y + h + 12]]);
          polylines.push([[x + 5, y - 12], [x - 1, y - 8], [x - 7, y - 6], [x - 7, y + h + 6], [x - 1, y + h + 8], [x + 5, y + h + 12]]);
          polylines.push([[x - 6, y - 5], [x - 6, y + h + 5]]);
        }
      } else if (tag == "articulation") {
        let a = Math.abs(elt.type);
        if (a == ARTICULATION.STACCATO) {
          let p = symbols["dot"];
          push_all(xform(p, (u, v) => [x + u, y + v]));
        } else if (a == ARTICULATION.ACCENT) {
          let p = [[x - 5, y - 3], [x + 5, y], [x - 5, y + 3]];
          polylines.push(p);
        } else if (a == ARTICULATION.SPICCATO) {
          let p = [[x - 1, y - 3], [x, y + 3], [x + 1, y - 3], [x - 1, y - 3]];
          polylines.push(p);
        } else if (a == ARTICULATION.TENUTO) {
          let p = [[x - 4, y], [x + 4, y]];
          polylines.push(p);
        } else if (a == ARTICULATION.MARCATO) {
          let p = [[x - 3, y + 3], [x, y - 3], [x + 3, y + 3]];
          polylines.push(p);
        } else if (a == ARTICULATION.UP_BOW) {
          let p = [[x - 3, y - 3], [x, y + 3], [x + 3, y - 3]];
          polylines.push(p);
        } else if (a == ARTICULATION.TREMBLEMENT) {
          let p = [
            [[x - 4, y], [x + 4, y]],
            [[x, y - 4], [x, y + 4]]
          ];
          push_all(p);
        } else if (a == ARTICULATION.FERMATA) {
          let p = symbols["fermata"];
          push_all(xform(p, (u, v) => [x + u, y + v * elt.dir]));
        } else if (a == ARTICULATION.MORDENT) {
          let p = symbols["mordent"];
          push_all(xform(p, (u, v) => [x + u, y + v]));
        } else if (a == ARTICULATION.TURN) {
          let p = symbols["turn"];
          push_all(xform(p, (u, v) => [x + u, y + v]));
        } else if (a == ARTICULATION.TRILL) {
          let p = symbols["trill"];
          push_all(xform(p, (u, v) => [x + u, y + v]));
        } else if (a == ARTICULATION.FLAGEOLET) {
          let p = symbols["flageolet"];
          push_all(xform(p, (u, v) => [x + u, y + v]));
        } else {
          let p = HERSHEY(ascii_map(elt.type.toString(), FONT.TRIPLEX)).polylines;
          push_all(xform(p, (u, v) => [x + u / 2, y + v / 2]));
        }
        if (elt.type < 0) {
          let p = [[x, y - 5], [x, y + 5]];
          polylines.push(p);
        }
      } else if (tag == "squiggle") {
        let p = [];
        let q = [];
        let f = false;
        let h2 = Math.ceil(h / 8) * 8;
        let y2 = y - (h2 - h) / 2;
        for (let i2 = 0; i2 < h2; i2 += 4) {
          p.push([f ? x + 2 : x - 2, y2 + i2]);
          if (f && i2 + 4 < h2) {
            q.push([[x + 2.8, i2 + y2 + 0.8], [x - 1.2, i2 + y2 + 4.8]]);
          }
          f = !f;
        }
        polylines.push(p);
        push_all(q);
      } else if (tag == "cue") {
        if (!elt.pts) {
          build_cue(elt);
        }
        push_all(elt.pts);
      }
    }
    return polylines;
  }
  function round_polylines(polylines, accuracy = 2) {
    let n = Math.pow(10, accuracy);
    for (let i = 0; i < polylines.length; i++) {
      for (let j = 0; j < polylines[i].length; j++) {
        let [x, y] = polylines[i][j];
        x = Math.round(x * n) / n;
        y = Math.round(y * n) / n;
        polylines[i][j][0] = x;
        polylines[i][j][1] = y;
      }
    }
  }
  function export_svg(dr, {background = "white"} = {}) {
    let o = `<svg xmlns="http://www.w3.org/2000/svg" width="${dr.w}" height="${dr.h}">`;
    if (background) {
      o += `<rect x="0" y="0" width="${dr.w}" height="${dr.h}" fill="${background}"></rect>`;
    }
    o += `<path stroke="black" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" fill="none" d="`;
    for (let i = 0; i < dr.polylines.length; i++) {
      o += "M ";
      for (let j = 0; j < dr.polylines[i].length; j++) {
        o += dr.polylines[i][j] + " ";
      }
    }
    o += `"/>`;
    o += `</svg>`;
    return o;
  }
  function export_animated_svg(dr, {background = "white", speed = 1e-3} = {}) {
    let width = dr.w;
    let height = dr.h;
    let polylines = dr.polylines;
    let o = `<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}">`;
    if (background) {
      o += `<rect x="0" y="0" width="${dr.w}" height="${dr.h}" fill="${background}"></rect>`;
    }
    let lengths = [];
    let acc_lengths = [];
    let total_l = 0;
    for (let i = 0; i < polylines.length; i++) {
      let l = 0;
      for (let j = 1; j < polylines[i].length; j++) {
        l += Math.hypot(polylines[i][j - 1][0] - polylines[i][j][0], polylines[i][j - 1][1] - polylines[i][j][1]);
      }
      lengths.push(l);
      acc_lengths.push(total_l);
      total_l += l;
    }
    for (let i = 0; i < polylines.length; i++) {
      let l = lengths[i];
      o += `
    <path 
      stroke="black" 
      stroke-width="1.5" 
      fill="none" 
      stroke-dasharray="${l}"
      stroke-dashoffset="${l}"
      d="M`;
      for (let j = 0; j < polylines[i].length; j++) {
        o += polylines[i][j] + " ";
      }
      let t = speed * l;
      o += `">
    <animate id="a${i}"
      attributeName="stroke-dashoffset" 
      fill="freeze"
      from="${l}" to="${0}" dur="${t}s" 
      begin="${acc_lengths[i] * speed}s;a${i}.end+${1 + speed * total_l}s"/>
    />
    <animate id="b${i}"
      attributeName="stroke-dashoffset" 
      fill="freeze"
      from="${0}" to="${l}" dur="${1}s" 
      begin="${speed * total_l}s;b${i}.end+${speed * total_l}s"/>
    />
    </path>`;
    }
    o += `</svg>`;
    return o;
  }
  function export_pdf(dr) {
    let width = dr.w;
    let height = dr.h;
    let polylines = dr.polylines;
    var head = `%PDF-1.1
%%\xA5\xB1\xEB
1 0 obj
<< /Type /Catalog
/Pages 2 0 R
>>endobj
    2 0 obj
<< /Type /Pages
/Kids [3 0 R]
/Count 1
/MediaBox [0 0 ${width} ${height}]
>>
endobj
    3 0 obj
<< /Type /Page
/Parent 2 0 R
/Resources
<< /Font
<< /F1
<< /Type /Font
    /Subtype /Type1
/BaseFont /Times-Roman
>>
>>
>>
/Contents [`;
    var pdf = "";
    var count = 4;
    for (var i = 0; i < polylines.length; i++) {
      pdf += `${count} 0 obj 
<< /Length 0 >>
 stream
 1 j 1 J 1.5 w
`;
      for (var j = 0; j < polylines[i].length; j++) {
        var [x, y] = polylines[i][j];
        pdf += `${x} ${height - y} ${j ? "l" : "m"} `;
      }
      pdf += "\nS\nendstream\nendobj\n";
      head += `${count} 0 R `;
      count++;
    }
    head += "]\n>>\nendobj\n";
    pdf += "\ntrailer\n<< /Root 1 0 R \n /Size 0\n >>startxref\n\n%%EOF\n";
    return head + pdf;
  }
  function xiaolinwu(data2, w, h, x0, y0, x1, y1) {
    function plot(x, y, c) {
      data2[y * w + x] = 1 - (1 - data2[y * w + x]) * (1 - c);
    }
    function ipart(x) {
      return Math.floor(x);
    }
    function round(x) {
      return ipart(x + 0.5);
    }
    function fpart(x) {
      return x - Math.floor(x);
    }
    function rfpart(x) {
      return 1 - fpart(x);
    }
    function drawline(x02, y02, x12, y12) {
      let steep = Math.abs(y12 - y02) > Math.abs(x12 - x02);
      if (steep) {
        [x02, y02] = [y02, x02];
        [x12, y12] = [y12, x12];
      }
      if (x02 > x12) {
        [x02, x12] = [x12, x02];
        [y02, y12] = [y12, y02];
      }
      let dx = x12 - x02;
      let dy = y12 - y02;
      let gradient = dy / dx;
      if (dx == 0) {
        gradient = 1;
      }
      let xend = round(x02);
      let yend = y02 + gradient * (xend - x02);
      let xgap = rfpart(x02 + 0.5);
      let xpxl1 = xend;
      let ypxl1 = ipart(yend);
      if (steep) {
        plot(ypxl1, xpxl1, rfpart(yend) * xgap);
        plot(ypxl1 + 1, xpxl1, fpart(yend) * xgap);
      } else {
        plot(xpxl1, ypxl1, rfpart(yend) * xgap);
        plot(xpxl1, ypxl1 + 1, fpart(yend) * xgap);
      }
      let intery = yend + gradient;
      xend = round(x12);
      yend = y12 + gradient * (xend - x12);
      xgap = fpart(x12 + 0.5);
      let xpxl2 = xend;
      let ypxl2 = ipart(yend);
      if (steep) {
        plot(ypxl2, xpxl2, rfpart(yend) * xgap);
        plot(ypxl2 + 1, xpxl2, fpart(yend) * xgap);
      } else {
        plot(xpxl2, ypxl2, rfpart(yend) * xgap);
        plot(xpxl2, ypxl2 + 1, fpart(yend) * xgap);
      }
      if (steep) {
        for (let x = xpxl1 + 1; x <= xpxl2 - 1; x++) {
          plot(ipart(intery), x, rfpart(intery));
          plot(ipart(intery) + 1, x, fpart(intery));
          intery = intery + gradient;
        }
      } else {
        for (let x = xpxl1 + 1; x <= xpxl2 - 1; x++) {
          plot(x, ipart(intery), rfpart(intery));
          plot(x, ipart(intery) + 1, fpart(intery));
          intery = intery + gradient;
        }
      }
    }
    drawline(x0, y0, x1, y1);
  }
  function encode_gif(data2, w, h) {
    let bytes = [];
    bytes.push(71, 73, 70, 56, 57, 97);
    bytes.push(w & 255);
    bytes.push(w >> 8 & 255);
    bytes.push(h & 255);
    bytes.push(h >> 8 & 255);
    bytes.push(246);
    bytes.push(0, 0);
    for (let i = 0; i < 127; i++) {
      bytes.push(i * 2, i * 2, i * 2);
    }
    bytes.push(255, 255, 255);
    bytes.push(44, 0, 0, 0, 0);
    bytes.push(w & 255);
    bytes.push(w >> 8 & 255);
    bytes.push(h & 255);
    bytes.push(h >> 8 & 255);
    bytes.push(0, 7);
    let n = ~~(w * h / 126);
    let inc = n * 126;
    let exc = w * h - inc;
    for (let i = 0; i < n; i++) {
      bytes.push(127);
      bytes.push(128);
      for (let j = 0; j < 126; j++) {
        bytes.push(~~(data2[i * 126 + j] * 127));
      }
    }
    if (exc) {
      bytes.push(exc + 1);
      bytes.push(128);
      for (let i = 0; i < exc; i++) {
        bytes.push(~~(data2[inc + i] * 127));
      }
    }
    bytes.push(1, 129, 0, 59);
    return bytes;
  }
  function export_gif(dr, {scale = 1, iter = 2} = {}) {
    let scl = 1 / scale;
    let w = ~~(dr.w / scl);
    let h = ~~(dr.h / scl);
    let polylines = dr.polylines;
    let data2 = new Array(w * h).fill(0);
    for (var i = 0; i < polylines.length; i++) {
      for (var j = 0; j < polylines[i].length - 1; j++) {
        let x0 = polylines[i][j][0] / scl;
        let y0 = polylines[i][j][1] / scl;
        let x1 = polylines[i][j + 1][0] / scl;
        let y1 = polylines[i][j + 1][1] / scl;
        for (let k = 0; k < iter; k++)
          xiaolinwu(data2, w, h, x0, y0, x1, y1);
      }
    }
    for (let i2 = 0; i2 < data2.length; i2++) {
      data2[i2] = 1 - data2[i2];
    }
    let bytes = encode_gif(data2, w, h);
    return bytes;
  }

  // src/midicompile.ts
  var MAX_VOICES = 2;
  var NOTE_LENGTH2 = {
    WHOLE: 32,
    HALF: 16,
    QUARTER: 8,
    EIGHTH: 4,
    SIXTEENTH: 2,
    THIRTYSECOND: 1
  };
  var NOTE_LENGTH_QUANT = 2;
  var NOTE_LENGTH_MODIFIER = 1.5;
  var NAME2PITCH = {
    Ab_0: 8,
    Ab_1: 20,
    Ab_2: 32,
    Ab_3: 44,
    Ab_4: 56,
    Ab_5: 68,
    Ab_6: 80,
    Ab_7: 92,
    Ab_8: 104,
    Ab_9: 116,
    F_3: 41,
    Ds_8: 99,
    Ds_9: 111,
    F_8: 101,
    F_9: 113,
    Gs_3: 44,
    Gs_2: 32,
    Gs_1: 20,
    Gs_0: 8,
    Gs_7: 92,
    Gs_6: 80,
    Gs_5: 68,
    Gs_4: 56,
    G_10: 127,
    Gs_9: 116,
    Gs_8: 104,
    E_3: 40,
    E_2: 28,
    E_1: 16,
    E_0: 4,
    E_7: 88,
    E_6: 76,
    E_5: 64,
    E_4: 52,
    E_9: 112,
    E_8: 100,
    As_9: 118,
    As_8: 106,
    Ds_0: 3,
    Ds_1: 15,
    Ds_6: 75,
    Ds_7: 87,
    Ds_4: 51,
    Ds_5: 63,
    As_1: 22,
    As_0: 10,
    As_3: 46,
    As_2: 34,
    As_5: 70,
    As_4: 58,
    As_7: 94,
    As_6: 82,
    Cs_7: 85,
    Cs_6: 73,
    Cs_5: 61,
    Cs_4: 49,
    Bb_9: 118,
    Cs_2: 25,
    Cs_1: 13,
    Cs_0: 1,
    Bb_5: 70,
    Bb_4: 58,
    Bb_7: 94,
    Bb_6: 82,
    Bb_1: 22,
    Bb_0: 10,
    Cs_9: 109,
    Cs_8: 97,
    Bb_8: 106,
    Bb_3: 46,
    Bb_2: 34,
    A_7: 93,
    A_6: 81,
    A_5: 69,
    A_4: 57,
    A_3: 45,
    A_2: 33,
    A_1: 21,
    A_0: 9,
    F_4: 53,
    A_9: 117,
    A_8: 105,
    B_8: 107,
    B_9: 119,
    F_10: 125,
    B_0: 11,
    B_1: 23,
    B_2: 35,
    B_3: 47,
    B_4: 59,
    B_5: 71,
    B_6: 83,
    B_7: 95,
    Fs_0: 6,
    Fs_1: 18,
    Fs_2: 30,
    Fs_3: 42,
    Fs_4: 54,
    Fs_5: 66,
    F_5: 65,
    Fs_7: 90,
    Fs_8: 102,
    Fs_9: 114,
    Gb_8: 102,
    Gb_9: 114,
    Gb_2: 30,
    Gb_3: 42,
    Gb_0: 6,
    Gb_1: 18,
    Gb_6: 78,
    Gb_7: 90,
    Gb_4: 54,
    Gb_5: 66,
    F_6: 77,
    Fs_6: 78,
    Eb_8: 99,
    Eb_9: 111,
    E_10: 124,
    Eb_4: 51,
    Eb_5: 63,
    Eb_6: 75,
    Eb_7: 87,
    Eb_0: 3,
    Eb_1: 15,
    Eb_2: 27,
    Eb_3: 39,
    D_8: 98,
    D_9: 110,
    D_2: 26,
    D_3: 38,
    D_0: 2,
    D_1: 14,
    D_6: 74,
    D_7: 86,
    D_4: 50,
    D_5: 62,
    F_2: 29,
    G_9: 115,
    G_8: 103,
    G_5: 67,
    G_4: 55,
    G_7: 91,
    G_6: 79,
    G_1: 19,
    G_0: 7,
    G_3: 43,
    G_2: 31,
    Cs_3: 37,
    Db_9: 109,
    Db_8: 97,
    Db_3: 37,
    Db_2: 25,
    Db_1: 13,
    Db_0: 1,
    Db_7: 85,
    Db_6: 73,
    Db_5: 61,
    Db_4: 49,
    C_1: 12,
    C_0: 0,
    C_3: 36,
    C_2: 24,
    C_5: 60,
    C_4: 48,
    C_7: 84,
    C_6: 72,
    C_9: 108,
    C_8: 96,
    Ds_2: 27,
    Ds_3: 39,
    D_10: 122,
    C_10: 120,
    F_7: 89,
    F_0: 5,
    F_1: 17
  };
  for (let i = 0; i <= 10; i++) {
    NAME2PITCH["Es_" + i] = NAME2PITCH["F_" + i];
    NAME2PITCH["Fb_" + i] = NAME2PITCH["E_" + i];
    NAME2PITCH["Bs_" + i] = NAME2PITCH["C_" + (i + 1)];
    NAME2PITCH["Cb_" + i] = NAME2PITCH["B_" + (i - 1)];
  }
  function classify_key_signature(key_sig) {
    let [num_acc, is_minor] = key_sig;
    let acc = ACCIDENTAL.NATURAL;
    if (num_acc < 0) {
      acc = ACCIDENTAL.FLAT;
      num_acc = -num_acc;
    } else if (num_acc) {
      acc = ACCIDENTAL.SHARP;
    }
    return [acc, num_acc];
  }
  function note_duration_overlap(a, b) {
    let x1 = a.begin;
    let x2 = a.begin + a.duration;
    let y1 = b.begin;
    let y2 = b.begin + b.duration;
    return x1 < y2 && y1 < x2;
  }
  var _pitch2name_cache = {};
  function infer_name_from_pitch(pitch, key_signature) {
    let candidates = [];
    let key = pitch | key_signature[0] << 24 | key_signature[1] << 16;
    let val = _pitch2name_cache[key];
    if (val !== void 0) {
      return val;
    }
    for (let name in NAME2PITCH) {
      if (NAME2PITCH[name] == pitch) {
        candidates.push(name);
      }
    }
    if (candidates.length == 0) {
      return null;
    }
    if (candidates.length == 1) {
      _pitch2name_cache[key] = candidates[0];
      return candidates[0];
    }
    let [acc, num_acc] = key_signature;
    let acc_notes = ORDER_OF_ACCIDENTALS[acc].slice(0, num_acc).split("");
    for (let n of acc_notes) {
      for (let i = 0; i < candidates.length; i++) {
        if (acc == ACCIDENTAL.SHARP && candidates[i].startsWith(n + "s")) {
          _pitch2name_cache[key] = candidates[i];
          return candidates[i];
        } else if (acc == ACCIDENTAL.FLAT && candidates[i].startsWith(n + "b")) {
          _pitch2name_cache[key] = candidates[i];
          return candidates[i];
        }
      }
    }
    _pitch2name_cache[key] = candidates[0];
    return candidates[0];
  }
  function compare_wholeness(a, b) {
    for (let i = 5; i >= 0; i--) {
      let p = Math.pow(2, i);
      let ap = a / p;
      let bp = b / p;
      ap -= ~~ap;
      bp -= ~~bp;
      if (ap == 0 && bp == 0) {
        return 0;
      } else if (ap > 0 && bp == 0) {
        return -1;
      } else if (ap == 0 && bp > 0) {
        return 1;
      }
    }
    return 0;
  }
  function factor_rest_duration(begin, dur, channel) {
    let l = dur;
    let b = begin;
    let rests = [];
    while (l > 0) {
      let ll = 0;
      for (let p = 0; p <= 5; p++) {
        let d = Math.pow(2, p);
        if (l < d) {
          break;
        }
        if (compare_wholeness(b + d, b) > 0) {
          ll = d;
          break;
        }
      }
      if (!ll) {
        for (let p = 5; p >= 0; p--) {
          let d = Math.pow(2, p);
          if (l >= d) {
            ll = d;
            break;
          }
        }
      }
      rests.push({
        begin: b,
        duration: ll,
        voice: channel,
        tuplet: null
      });
      l -= ll;
      b += ll;
    }
    return rests;
  }
  function find_rests(measure, staff_idx, channels) {
    let measure_length = measure.duration;
    let staff = measure.staves[staff_idx];
    let rests = [];
    let did = false;
    for (let c of channels) {
      let channel_notes = staff.notes.filter((x) => x.voice == c);
      if (!channel_notes.length) {
        continue;
      }
      did = true;
      let bins = new Array(measure_length).fill(true);
      for (let i = 0; i < measure_length; i++) {
        for (let m of channel_notes) {
          if (m.voice == c) {
            if (m.begin <= i && i < m.begin + m.duration) {
              bins[i] = false;
              break;
            }
          }
        }
      }
      let last_length = 0;
      for (let i = 0; i < bins.length + 1; i++) {
        if (i < bins.length && bins[i]) {
          last_length++;
        } else {
          if (last_length > 0) {
            rests.push(...factor_rest_duration(i - last_length, last_length, c));
          }
          last_length = 0;
        }
      }
    }
    if (!did) {
      rests.push(...factor_rest_duration(0, measure_length, channels[0]));
    }
    return rests;
  }
  function get_piece_title(pattern) {
    let title = [];
    for (let track of pattern.tracks) {
      for (let event of track.events) {
        if (event.type == "SEQUENCE_OR_TRACK_NAME") {
          title.push(...event.data["text"].split("\n"));
        }
      }
    }
    return title;
  }
  function is_note_on_event(evt) {
    return evt.type == "NOTE_ON" && evt.data["velocity"] != 0;
  }
  function is_note_off_event(evt) {
    return evt.type == "NOTE_OFF" || evt.type == "NOTE_ON" && evt.data["velocity"] == 0;
  }
  function pattern_to_tick_tables(pattern) {
    var _a;
    let res = pattern.ticks_per_quarter_note;
    let sections = [];
    let track_id = -1;
    let end_of_track = 0;
    let last_time_sig = null;
    let last_key_sig = null;
    for (let track of pattern.tracks) {
      track_id += 1;
      let t = 0;
      for (let event of track.events) {
        t += event.delta_time;
        if (event.type == "TIME_SIGNATURE" && track_id == 0) {
          let ts = [event.data["numerator"], 2 ** event.data["denominator_exp"]];
          if (sections.length == 0 || sections[sections.length - 1][1][0] != null) {
            sections.push([t, [ts, last_key_sig], []]);
          } else {
            sections[sections.length - 1][1][0] = ts;
          }
          last_time_sig = ts;
        } else if (event.type == "KEY_SIGNATURE" && track_id == 0) {
          let ks = classify_key_signature([event.data["num_sharps_or_flats"], event.data["is_minor"]]);
          if (sections.length == 0 || sections[sections.length - 1][1][1] != null) {
            sections.push([t, [last_time_sig, ks], []]);
          } else {
            sections[sections.length - 1][1][1] = ks;
          }
          last_key_sig = ks;
        } else if (event.type == "END_OF_TRACK") {
          end_of_track = Math.max(t, end_of_track);
        } else {
          for (let i = 0; i < sections.length; i++) {
            let idx = sections.length - i - 1;
            if (t >= sections[idx][0]) {
              if (event.type == "NOTE_ON" || event.type == "NOTE_OFF") {
                let name;
                if (is_note_on_event(event)) {
                  name = "NOTE_ON";
                } else if (is_note_off_event(event)) {
                  name = "NOTE_OFF";
                }
                sections[idx][2].push({name, abs_tick: t - sections[idx][0], pitch: event.data["key"], channel: (track_id * 16 + event.data["channel"]) * 100});
              }
              break;
            }
          }
        }
      }
    }
    let unpaired = [];
    for (let i = 0; i < sections.length; i++) {
      for (let j = 0; j < sections[i][2].length; j++) {
        let note = sections[i][2][j];
        if (note.name == "NOTE_ON") {
          unpaired.unshift([true, i, j, note]);
        } else if (note.name == "NOTE_OFF") {
          for (let k = 0; k < unpaired.length; k++) {
            let up = unpaired[k];
            if (up[0] && up[3].channel == note.channel && up[3].pitch == note.pitch) {
              unpaired[k][0] = false;
              sections[up[1]][2][up[2]].duration = note.abs_tick - up[3].abs_tick;
              break;
            }
          }
        }
      }
    }
    let tick_tables = [];
    for (let i = 0; i < sections.length; i++) {
      let end_tick = i + 1 < sections.length ? sections[i + 1][0] : end_of_track;
      tick_tables.push({
        time_signature: sections[i][1][0],
        key_signature: (_a = sections[i][1][1]) != null ? _a : [0, 0],
        resolution: res,
        duration: end_tick - sections[i][0],
        notes: []
      });
      for (let j = 0; j < sections[i][2].length; j++) {
        let note = sections[i][2][j];
        if (sections[i][2][j].name == "NOTE_ON") {
          if (note.duration !== void 0) {
            let dur = note.duration;
            tick_tables[tick_tables.length - 1].notes.push({
              begin: note.abs_tick,
              pitch: note.pitch,
              duration: dur,
              channel: note.channel
            });
          } else {
            console.warn(`WARNING: Unpaired NOTE_ON event, discarding!`, note);
          }
        }
      }
    }
    return tick_tables;
  }
  function split_voices(measures) {
    function collide(a, b) {
      if (a.begin == b.begin && a.duration == b.duration) {
        return a.pitch == b.pitch;
      }
      return note_duration_overlap(a, b);
    }
    function collide_with_channel(measure, index) {
      let channel = measure.notes[index].channel;
      for (let i = 0; i < index; i++) {
        if (measure.notes[i].channel != channel) {
          continue;
        }
        if (collide(measure.notes[index], measure.notes[i])) {
          return true;
        }
      }
      return false;
    }
    for (let i = 0; i < measures.length; i++) {
      let notes = measures[i].notes;
      let cross_ties = measures[i].cross_ties;
      for (let j = 0; j < notes.length; j++) {
        let note = notes[j];
        let skip = false;
        for (let k = 0; k < cross_ties.length; k++) {
          if (note == cross_ties[k].right) {
            skip = true;
            break;
          }
        }
        if (skip)
          continue;
        while (collide_with_channel(measures[i], j)) {
          note.channel++;
        }
        for (let k = 0; k < measures[i].cross_ties.length; k++) {
          if (measures[i].cross_ties[k].left == note) {
            measures[i].cross_ties[k].right.channel = note.channel;
          }
        }
      }
    }
  }
  function classify_note_length(length) {
    let d0 = 1024;
    let l0 = -1;
    let mod = false;
    for (let k in NOTE_LENGTH2) {
      let l = NOTE_LENGTH2[k];
      let d = Math.abs(length - l);
      if (d < d0) {
        l0 = l;
        d0 = d;
      }
    }
    for (let k in NOTE_LENGTH2) {
      let l = ~~(NOTE_LENGTH2[k] * NOTE_LENGTH_MODIFIER);
      let d = Math.abs(length - l);
      if (d < d0) {
        mod = true;
        l0 = l;
        d0 = d;
      }
    }
    return [l0, mod];
  }
  function has_modifier(length) {
    if (length == NOTE_LENGTH2.THIRTYSECOND * NOTE_LENGTH_MODIFIER)
      return true;
    if (length == NOTE_LENGTH2.SIXTEENTH * NOTE_LENGTH_MODIFIER)
      return true;
    if (length == NOTE_LENGTH2.EIGHTH * NOTE_LENGTH_MODIFIER)
      return true;
    if (length == NOTE_LENGTH2.QUARTER * NOTE_LENGTH_MODIFIER)
      return true;
    if (length == NOTE_LENGTH2.HALF * NOTE_LENGTH_MODIFIER)
      return true;
    if (length == NOTE_LENGTH2.WHOLE * NOTE_LENGTH_MODIFIER)
      return true;
    return false;
  }
  function tick2length(tick, resolution) {
    let ticks_per_quarter_note = resolution;
    let num_quarter_notes = tick / ticks_per_quarter_note;
    let num_32nd_notes = num_quarter_notes * (NOTE_LENGTH2.QUARTER / NOTE_LENGTH2.THIRTYSECOND);
    return num_32nd_notes;
  }
  function length2tick(length, resolution) {
    let num_32nd_notes = length;
    let num_quarter_notes = num_32nd_notes * (NOTE_LENGTH2.THIRTYSECOND * 1 / NOTE_LENGTH2.QUARTER);
    let ticks_per_quarter_note = resolution;
    let num_ticks = num_quarter_notes * ticks_per_quarter_note;
    return ~~num_ticks;
  }
  function tick_table_to_measures(tick_table) {
    let time_sig = tick_table.time_signature;
    let key_sig = tick_table.key_signature;
    let resolution = tick_table.resolution;
    let notes = tick_table.notes;
    let measures = [];
    function getmeasurelength() {
      let ticks_per_quarter_note = resolution;
      let num_beats = time_sig[0];
      let num_32nd_notes_per_beat = ~~(NOTE_LENGTH2.WHOLE / time_sig[1]);
      let num_32nd_notes = num_32nd_notes_per_beat * num_beats;
      return num_32nd_notes;
    }
    function getmeasureticks() {
      let num_32nd_notes = getmeasurelength();
      return length2tick(num_32nd_notes, resolution);
    }
    let measure_duration = getmeasureticks();
    let measure_length = getmeasurelength();
    function getlength(tick) {
      return ~~tick2length(tick, resolution);
    }
    function empty_measure() {
      return {
        time_signature: time_sig,
        key_signature: key_sig,
        duration: getlength(measure_duration),
        notes: [],
        cross_ties: []
      };
    }
    while (tick_table.duration > measure_duration * measures.length) {
      measures.push(empty_measure());
    }
    for (let i = 0; i < notes.length; i++) {
      let note = notes[i];
      let measure_id = ~~(note.begin / measure_duration);
      while (measure_id >= measures.length) {
        measures.push(empty_measure());
      }
      let begin = getlength(note.begin - measure_id * measure_duration);
      let [length, modifier] = classify_note_length(tick2length(note.duration, resolution));
      let channel = note.channel;
      let pitch = note.pitch;
      let nnote = {
        begin,
        channel,
        pitch,
        duration: Math.min(length, measure_length - begin)
      };
      measures[measure_id].notes.push(nnote);
      let carry_cnt = 1;
      let left = nnote;
      while (begin + length > measure_length) {
        if (measure_id + carry_cnt >= measures.length) {
          measures.push(empty_measure());
        }
        let right = {
          begin: 0,
          duration: Math.min(measure_length, begin + length - measure_length),
          channel,
          pitch
        };
        measures[measure_id + carry_cnt].notes.push(right);
        measures[measure_id + carry_cnt - 1].cross_ties.push({left, right});
        measures[measure_id + carry_cnt].cross_ties.push({left, right});
        length = begin + length - measure_length;
        begin = 0;
        carry_cnt += 1;
        left = right;
      }
    }
    return measures;
  }
  function compile_staff(measure, staff_idx) {
    var _a, _b;
    let staff = measure.staves[staff_idx];
    let [measure_acc, num_acc] = staff.key_signature;
    let acc_names = ORDER_OF_ACCIDENTALS[measure_acc].slice(0, num_acc).split("");
    let acc_history = {};
    function get_beat_length(time_sig) {
      let beat_length2 = ~~(NOTE_LENGTH2.WHOLE / time_sig[1]);
      if (time_sig[1] == 4 && time_sig[0] >= 4) {
        beat_length2 *= 2;
      }
      return beat_length2;
    }
    let beat_length = get_beat_length(staff.time_signature);
    let channels = get_existing_voices(staff.notes.concat(staff.rests), []);
    staff.voices = channels.length;
    function get_beat_idx(note) {
      return ~~(note.begin / beat_length);
    }
    function get_notes_in_beat(beat_idx) {
      let notes = [];
      for (let m of staff.notes) {
        if (get_beat_idx(m) == beat_idx) {
          notes.push(m);
        }
      }
      return notes;
    }
    function calc_stem_dir(note) {
      let beat_idx = get_beat_idx(note);
      let notes_in_beat = get_notes_in_beat(beat_idx);
      let avg_line = notes_in_beat.reduce((acc, x) => acc + x.staff_pos, 0) / notes_in_beat.length;
      if (avg_line < 4) {
        return 1;
      } else {
        return -1;
      }
    }
    for (let i = 0; i < staff.notes.length; i++) {
      let note = staff.notes[i];
      let note_name = note.name;
      let note_oct = Number(note_name.split("_")[1]);
      let note_staff = note_name_to_staff_pos(note_name, staff.clef);
      note.octave = note_oct;
      note.staff_pos = note_staff;
      let modifier = has_modifier(note.duration);
      note.modifier = modifier;
    }
    for (let i = 0; i < staff.notes.length; i++) {
      let accidental = null;
      let note = staff.notes[i];
      let note_name = note.name;
      let note_bname = note_name[0];
      let note_acc = get_note_name_accidental(note_name);
      let key = note_bname + "_" + note.octave;
      if (acc_names.includes(note_bname)) {
        if (note_acc == measure_acc) {
          if (acc_history[key] === void 0 || acc_history[key] === note_acc) {
          } else {
            accidental = note_acc;
            acc_history[key] = note_acc;
          }
        } else {
          accidental = note_acc;
          acc_history[key] = note_acc;
        }
      } else {
        if (note_acc == ACCIDENTAL.NATURAL) {
          if (acc_history[key]) {
            accidental = note_acc;
            acc_history[key] = note_acc;
          }
        } else {
          if (acc_history[key] !== note_acc) {
            accidental = note_acc;
            acc_history[key] = note_acc;
          }
        }
      }
      note.accidental = accidental;
    }
    let channel_median_staff_pos = get_median_staff_pos(staff.notes);
    let channel_to_voice = {};
    let voice_median_staff_pos = {};
    let channels_sorted = Object.entries(channel_median_staff_pos).sort((a, b) => a[1] - b[1]);
    for (let i = 0; i < channels_sorted.length; i++) {
      channel_to_voice[channels_sorted[i][0]] = i;
      voice_median_staff_pos[i] = channel_median_staff_pos[channels_sorted[i][0]];
    }
    for (let i = 0; i < staff.notes.length; i++) {
      staff.notes[i].voice = (_a = channel_to_voice[staff.notes[i].voice]) != null ? _a : 0;
    }
    for (let i = 0; i < staff.rests.length; i++) {
      staff.rests[i].voice = (_b = channel_to_voice[staff.rests[i].voice]) != null ? _b : 0;
    }
    for (let i = 0; i < staff.notes.length; i++) {
      let note = staff.notes[i];
      let stem_dir;
      if (staff.voices == 1) {
        stem_dir = calc_stem_dir(note);
      } else {
        stem_dir = note.voice % 2 ? 1 : -1;
      }
      note.stem_dir = stem_dir;
    }
    chord_and_beam_staff(staff, beat_length);
    for (let i = 0; i < staff.notes.length; i++) {
      staff.notes[i].duration *= NOTE_LENGTH_QUANT;
      staff.notes[i].begin *= NOTE_LENGTH_QUANT;
    }
    for (let i = 0; i < staff.rests.length; i++) {
      staff.rests[i].duration *= NOTE_LENGTH_QUANT;
      staff.rests[i].begin *= NOTE_LENGTH_QUANT;
    }
  }
  function get_channel_average_pitch(measures) {
    let c2p = {};
    for (let m of measures) {
      for (let n of m.notes) {
        if (!c2p[n.channel]) {
          c2p[n.channel] = [0, 0];
        }
        c2p[n.channel][0] += n.pitch;
        c2p[n.channel][1]++;
      }
    }
    let c2p2 = {};
    for (let k in c2p) {
      c2p2[k] = c2p[k][1] ? c2p[k][0] / c2p[k][1] : 0;
    }
    return c2p2;
  }
  function assign_clef_from_pitch(pitch) {
    if (pitch > NAME2PITCH["C_5"]) {
      return CLEF.TREBLE;
    } else {
      return CLEF.BASS;
    }
  }
  function score_from_midi(pattern) {
    var _a, _b;
    let tick_tables = pattern_to_tick_tables(pattern);
    let measures_ = [];
    for (let i = 0; i < tick_tables.length; i++) {
      let ms = tick_table_to_measures(tick_tables[i]);
      for (let j = 0; j < ms.length; j++) {
        measures_.push(ms[j]);
      }
    }
    split_voices(measures_);
    let channel2pitch = get_channel_average_pitch(measures_);
    let channel2clef = {};
    for (let k in channel2pitch) {
      channel2clef[k] = assign_clef_from_pitch(channel2pitch[k]);
    }
    let channels = Object.keys(channel2pitch).map(Number).sort((a, b) => a - b);
    let channel_groups_ = {};
    for (let i = 0; i < channels.length; i++) {
      let g = ~~(channels[i] / 100);
      let g0 = channels[i] - g * 100;
      let g1 = ~~(g0 / MAX_VOICES);
      let gg = g * 100 + g1;
      if (!channel_groups_[gg])
        channel_groups_[gg] = [];
      channel_groups_[gg].push(channels[i]);
    }
    let channel_groups = Object.values(channel_groups_);
    let score = {
      title: get_piece_title(pattern),
      instruments: [],
      composer: [],
      slurs: [],
      measures: [],
      crescs: []
    };
    for (let i = 0; i < measures_.length; i++) {
      let ties = measures_[i].cross_ties;
      for (let j = 0; j < ties.length; j++) {
        let slur = {left: (_a = ties[j].left.id) != null ? _a : short_id(), right: (_b = ties[j].right.id) != null ? _b : short_id(), is_tie: true};
        ties[j].left.id = slur.left;
        ties[j].right.id = slur.right;
        score.slurs.push(slur);
      }
    }
    for (let i = 0; i < measures_.length; i++) {
      let measure = {
        duration: measures_[i].duration,
        barline: i == measures_.length ? BARLINE.END : BARLINE.SINGLE,
        staves: []
      };
      for (let j = 0; j < channel_groups.length; j++) {
        let ch_group = channel_groups[j];
        measure.staves.push({
          clef: channel2clef[ch_group[0]],
          time_signature: measures_[i].time_signature,
          key_signature: measures_[i].key_signature,
          notes: [],
          rests: [],
          grace: [],
          voices: null,
          beams: []
        });
        for (let k = 0; k < measures_[i].notes.length; k++) {
          if (ch_group.includes(measures_[i].notes[k].channel)) {
            let name = infer_name_from_pitch(measures_[i].notes[k].pitch, measures_[i].key_signature);
            let note = {
              begin: measures_[i].notes[k].begin,
              duration: measures_[i].notes[k].duration,
              accidental: null,
              modifier: null,
              octave: null,
              name,
              voice: measures_[i].notes[k].channel,
              staff_pos: null,
              stem_dir: null,
              prev_in_chord: null,
              next_in_chord: null,
              tuplet: null
            };
            if (measures_[i].notes[k].id) {
              note.id = measures_[i].notes[k].id;
            }
            measure.staves[j].notes.push(note);
          }
        }
        measure.staves[j].rests.push(...find_rests(measure, j, ch_group));
        compile_staff(measure, j);
      }
      measure.duration *= 2;
      score.measures.push(measure);
    }
    return score;
  }
  function score_to_midi(score) {
    let meta_track = {events: []};
    let tracks = [];
    let tied_lefts = {};
    let tied_rights = {};
    for (let i = 0; i < score.slurs.length; i++) {
      if (score.slurs[i].is_tie) {
        tied_lefts[score.slurs[i].left] = true;
        tied_rights[score.slurs[i].right] = true;
      }
    }
    meta_track.events.push({type: "SEQUENCE_OR_TRACK_NAME", delta_time: 0, data: {text: score.title.concat(score.composer).join("\n")}});
    let instruments = [];
    for (let i = 0; i < score.instruments.length; i++) {
      instruments.push(...score.instruments[i].names);
    }
    for (let j = 0; j < score.measures[0].staves.length; j++) {
      let T = 0;
      for (let i = 0; i < score.measures.length; i++) {
        if (!tracks[j]) {
          tracks[j] = {events: []};
          if (instruments[j]) {
            tracks[j].events.push({type: "INSTRUMENT_NAME", delta_time: 0, data: {text: instruments[j]}});
          }
        }
        if (j == 0) {
          if (i == 0 || score.measures[i].staves[j].key_signature.toString() != score.measures[i - 1].staves[j].key_signature.toString()) {
            let [acc, num_acc] = score.measures[i].staves[j].key_signature;
            meta_track.events.push({type: "KEY_SIGNATURE", delta_time: T, data: {num_sharps_or_flats: acc * num_acc, is_minor: 0}});
          }
          if (i == 0 || score.measures[i].staves[j].time_signature.toString() != score.measures[i - 1].staves[j].time_signature.toString()) {
            let [numerator, denominator] = score.measures[i].staves[j].time_signature;
            let denominator_exp = Math.log2(denominator);
            meta_track.events.push({type: "TIME_SIGNATURE", delta_time: T, data: {numerator, denominator_exp, clocks_per_metronome_click: 24, notated_32nd_per_quarter_note: 8}});
          }
        }
        for (let k = 0; k < score.measures[i].staves[j].notes.length; k++) {
          let note = score.measures[i].staves[j].notes[k];
          let t0 = note.begin;
          let d = note.duration;
          let v = 100;
          if (note.articulation == ARTICULATION.STACCATO) {
            d /= 2;
          }
          if (note.articulation == ARTICULATION.SPICCATO) {
            d /= 4;
          }
          if (note.articulation == ARTICULATION.ACCENT) {
            v = 125;
          }
          let t1 = t0 + d;
          if (note.prev_in_chord != null || note.next_in_chord != null) {
            let first = note;
            let last = note;
            let count_prev = 0;
            let count_next = 0;
            let is_arp = note.articulation == ARTICULATION.ARPEGGIATED;
            while (first.prev_in_chord != null) {
              first = score.measures[i].staves[j].notes[first.prev_in_chord];
              is_arp = is_arp || first.articulation == ARTICULATION.ARPEGGIATED;
              count_prev++;
            }
            while (last.next_in_chord != null) {
              last = score.measures[i].staves[j].notes[last.next_in_chord];
              is_arp = is_arp || last.articulation == ARTICULATION.ARPEGGIATED;
              count_next++;
            }
            if (is_arp) {
              let idx;
              if (first.staff_pos < last.staff_pos) {
                idx = count_next;
              } else {
                idx = count_prev;
              }
              t0 += Math.min(2, note.duration / (count_next + count_prev + 1)) * idx;
            }
          }
          if (score.measures[i].staves[j].grace[note.begin]) {
            t0 = Math.min(t1 - 1, Math.max(t0, note.begin + score.measures[i].staves[j].grace[note.begin].duration / 4));
          }
          if (note.articulation != ARTICULATION.TRILL && note.articulation != ARTICULATION.TREMBLEMENT) {
            if (!tied_rights[note.id]) {
              tracks[j].events.push({type: "NOTE_ON", delta_time: T + t0, data: {key: NAME2PITCH[note.name], velocity: v, channel: 0}});
            }
            if (!tied_lefts[note.id]) {
              tracks[j].events.push({type: "NOTE_OFF", delta_time: T + t1, data: {key: NAME2PITCH[note.name], velocity: 0, channel: 0}});
            }
          } else {
            let above = String.fromCharCode(note.name[0].charCodeAt(0) + 1);
            if (above == "H") {
              above = "A" + note.name.slice(1);
              ;
            } else if (above == "C") {
              above += note.name.slice(1);
              above = above.split("_")[0] + "_" + (note.octave + 1);
            } else {
              above += note.name.slice(1);
            }
            let flip = false;
            for (let i2 = t0; i2 < t1; i2++) {
              tracks[j].events.push({type: "NOTE_ON", delta_time: T + i2, data: {key: NAME2PITCH[flip ? above : note.name], velocity: v, channel: 0}});
              tracks[j].events.push({type: "NOTE_OFF", delta_time: T + i2 + 1, data: {key: NAME2PITCH[flip ? above : note.name], velocity: 0, channel: 0}});
              flip = !flip;
            }
          }
        }
        for (let k = 0; k < score.measures[i].staves[j].grace.length; k++) {
          if (!score.measures[i].staves[j].grace[k])
            continue;
          for (let l = 0; l < score.measures[i].staves[j].grace[k].staves[0].notes.length; l++) {
            let note = score.measures[i].staves[j].grace[k].staves[0].notes[l];
            tracks[j].events.push({type: "NOTE_ON", delta_time: T + k + note.begin / 4, data: {key: NAME2PITCH[note.name], velocity: 100, channel: 0}});
            tracks[j].events.push({type: "NOTE_OFF", delta_time: T + k + (note.begin + note.duration) / 4, data: {key: NAME2PITCH[note.name], velocity: 0, channel: 0}});
          }
        }
        T += score.measures[i].duration;
      }
    }
    tracks.unshift(meta_track);
    for (let j = 0; j < tracks.length; j++) {
      tracks[j].events.sort((a, b) => a.delta_time - b.delta_time);
      for (let k = tracks[j].events.length - 1; k > 0; k--) {
        tracks[j].events[k].delta_time -= tracks[j].events[k - 1].delta_time;
      }
    }
    for (let j = 0; j < tracks.length; j++) {
      for (let k = 0; k < tracks[j].events.length; k++) {
        tracks[j].events[k].delta_time = ~~(tracks[j].events[k].delta_time * 6);
      }
      tracks[j].events.push({type: "END_OF_TRACK", delta_time: 0, data: {}});
    }
    let pattern = {
      magic: "MThd",
      tracks,
      num_tracks: tracks.length,
      format: 1,
      time_format: "METRIC",
      ticks_per_quarter_note: 96
    };
    return pattern;
  }

  // src/fx.ts
  var PERLIN_YWRAPB = 4;
  var PERLIN_YWRAP = 1 << PERLIN_YWRAPB;
  var PERLIN_ZWRAPB = 8;
  var PERLIN_ZWRAP = 1 << PERLIN_ZWRAPB;
  var PERLIN_SIZE = 4095;
  var perlin_octaves = 4;
  var perlin_amp_falloff = 0.5;
  var scaled_cosine = function(i) {
    return 0.5 * (1 - Math.cos(i * Math.PI));
  };
  var p_perlin;
  function noise(x, y = 0, z = 0) {
    if (p_perlin == null) {
      p_perlin = new Array(PERLIN_SIZE + 1);
      for (let i = 0; i < PERLIN_SIZE + 1; i++) {
        p_perlin[i] = Math.random();
      }
    }
    if (x < 0) {
      x = -x;
    }
    if (y < 0) {
      y = -y;
    }
    if (z < 0) {
      z = -z;
    }
    let xi = Math.floor(x), yi = Math.floor(y), zi = Math.floor(z);
    let xf = x - xi;
    let yf = y - yi;
    let zf = z - zi;
    let rxf, ryf;
    let r = 0;
    let ampl = 0.5;
    let n1, n2, n3;
    for (let o = 0; o < perlin_octaves; o++) {
      let of = xi + (yi << PERLIN_YWRAPB) + (zi << PERLIN_ZWRAPB);
      rxf = scaled_cosine(xf);
      ryf = scaled_cosine(yf);
      n1 = p_perlin[of & PERLIN_SIZE];
      n1 += rxf * (p_perlin[of + 1 & PERLIN_SIZE] - n1);
      n2 = p_perlin[of + PERLIN_YWRAP & PERLIN_SIZE];
      n2 += rxf * (p_perlin[of + PERLIN_YWRAP + 1 & PERLIN_SIZE] - n2);
      n1 += ryf * (n2 - n1);
      of += PERLIN_ZWRAP;
      n2 = p_perlin[of & PERLIN_SIZE];
      n2 += rxf * (p_perlin[of + 1 & PERLIN_SIZE] - n2);
      n3 = p_perlin[of + PERLIN_YWRAP & PERLIN_SIZE];
      n3 += rxf * (p_perlin[of + PERLIN_YWRAP + 1 & PERLIN_SIZE] - n3);
      n2 += ryf * (n3 - n2);
      n1 += scaled_cosine(zf) * (n2 - n1);
      r += n1 * ampl;
      ampl *= perlin_amp_falloff;
      xi <<= 1;
      xf *= 2;
      yi <<= 1;
      yf *= 2;
      zi <<= 1;
      zf *= 2;
      if (xf >= 1) {
        xi++;
        xf--;
      }
      if (yf >= 1) {
        yi++;
        yf--;
      }
      if (zf >= 1) {
        zi++;
        zf--;
      }
    }
    return r;
  }
  function resample_polyline(polyline, l, L) {
    let q = [];
    for (let i = 0; i < polyline.length - 1; i++) {
      let a = polyline[i];
      let b = polyline[i + 1];
      let s = Math.hypot(a[0] - b[0], a[1] - b[1]);
      let n = Math.ceil(s / l);
      if (s >= L) {
        n = 1;
      }
      for (let j = 0; j < n; j++) {
        let t = j / n;
        let c = [a[0] * (1 - t) + b[0] * t, a[1] * (1 - t) + b[1] * t];
        q.push(c);
      }
      q.push(b.slice());
    }
    return q;
  }
  function disturb_polylines(elements, polylines, multiplier = 1) {
    let content_y = 0;
    for (let i = 0; i < elements.length; i++) {
      if (elements[i].type == "composer" || elements[i].type == "tempo" || elements[i].type == "title" || elements[i].type == "subtitle") {
        content_y = Math.max(content_y, elements[i].y + elements[i].h);
      }
    }
    let q = [];
    for (let i = 0; i < polylines.length; i++) {
      let qq = [];
      let bbox = bounding_box(polylines[i]);
      if (bbox.y - 4 <= content_y) {
        for (let j = 0; j < polylines[i].length; j++) {
          let [x, y] = polylines[i][j];
          x += (noise(x * 0.01, y * 0.01, 1 + i * 0.1) * 2 - 1) * 2 * multiplier;
          y += (noise(x * 0.01, y * 0.01, 2 + i * 0.1) * 2 - 1) * 2 * multiplier;
          x -= Math.min(y * 0.1, 20) * multiplier;
          y -= Math.min(x * 0.01, 20) * multiplier;
          qq.push([x, y]);
        }
      } else {
        for (let j = 0; j < polylines[i].length; j++) {
          let [x, y] = polylines[i][j];
          x += (noise(x * 0.01, y * 0.01, 1 + i * 0.1) * 2 - 1) * 6 * multiplier;
          y += (noise(x * 0.01, y * 0.01, 2 + i * 0.1) * 2 - 1) * 5 * multiplier;
          x -= Math.min(y * 0.015, 20) * multiplier;
          y -= Math.min(x * 0.01, 20) * multiplier;
          qq.push([x, y]);
        }
      }
      q.push(qq);
    }
    return q;
  }
  function export_sketch_svg(dr, {noise_mul = 1} = {}) {
    let p = dr.polylines.map((x) => resample_polyline(x, 5, 500));
    p = disturb_polylines(dr.elements, p, noise_mul);
    let o = `<svg xmlns="http://www.w3.org/2000/svg" width="${dr.w}" height="${dr.h}">`;
    o += `<rect x="0" y="0" width="${dr.w}" height="${dr.h}" fill="antiquewhite"></rect>`;
    for (let i = 0; i < p.length; i++) {
      o += `<path stroke="#2B1100" stroke-opacity="${Math.random() * 0.1 + 0.6}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" fill="none" d="M `;
      for (let j = 0; j < p[i].length; j++) {
        o += p[i][j] + " ";
      }
      o += `"/>`;
    }
    o += `</svg>`;
    return o;
  }

  // src/midifmt.ts
  var META_EVENT = {
    0: ["SEQUENCE_NUMBER", "value"],
    1: ["TEXT_EVENT", "text"],
    2: ["COPYRIGHT_NOTICE", "text"],
    3: ["SEQUENCE_OR_TRACK_NAME", "text"],
    4: ["INSTRUMENT_NAME", "text"],
    5: ["LYRIC", "text"],
    6: ["MARKER", "text"],
    7: ["CUE_POINT", "text"],
    32: ["CHANNEL_PREFIX", "value"],
    33: ["PORT", "value"],
    47: ["END_OF_TRACK"],
    84: ["SMPTE_OFFSET", "hour", "min", "sec", "frame", "frac_frame"],
    81: ["SET_TEMPO", "data"],
    88: ["TIME_SIGNATURE", "numerator", "denominator_exp", "clocks_per_metronome_click", "notated_32nd_per_quarter_note"],
    89: ["KEY_SIGNATURE", "num_sharps_or_flats", "is_minor"],
    127: ["SEQUENCER_SPECIFIC_EVENT", "data"]
  };
  var MIDI_EVENT = {
    8: ["NOTE_OFF", "key", "velocity"],
    9: ["NOTE_ON", "key", "velocity"],
    10: ["POLYPHONIC_KEY_PRESSURE", "key", "pressure"],
    11: ["CONTROL_CHANGE", "controller", "value"],
    12: ["PROGRAM_CHANGE", "value"],
    13: ["CHANNEL_PRESSURE", "value"],
    14: ["PITCH_WHEEL_CHANGE", "lsb", "msb"]
  };
  var SYSTEM_EVENT = {
    2: ["SONG_POSITION_POINTER", "lsb", "msb"],
    3: ["SONG_SELECT", "value"],
    6: ["TUNE_REQUEST"],
    7: ["END_OF_EXCLUSIVE"],
    8: ["TIMING_CLOCK"],
    10: ["START"],
    11: ["CONTINUE"],
    12: ["STOP"],
    14: ["ACTIVE_SENSING"],
    15: ["RESET"]
  };
  var META_EVENT_LOOKUP = Object.fromEntries(Object.entries(META_EVENT).map((x) => [x[1][0], [x[0], ...x[1].slice(1)]]));
  var MIDI_EVENT_LOOKUP = Object.fromEntries(Object.entries(MIDI_EVENT).map((x) => [x[1][0], [x[0], ...x[1].slice(1)]]));
  var SYSTEM_EVENT_LOOKUP = Object.fromEntries(Object.entries(SYSTEM_EVENT).map((x) => [x[1][0], [x[0], ...x[1].slice(1)]]));
  function parse_midi(bytes) {
    var _a, _b, _c;
    let ptr = 0;
    function read_str(n) {
      let s = String.fromCharCode(...bytes.slice(ptr, ptr + n));
      ptr += n;
      return s;
    }
    function read_u8() {
      return bytes[ptr++];
    }
    function read_u32() {
      let s = (bytes[ptr] << 24 | bytes[ptr + 1] << 16 | bytes[ptr + 2] << 8 | bytes[ptr + 3]) >>> 0;
      ptr += 4;
      return s;
    }
    function read_u16() {
      let s = bytes[ptr] << 8 | bytes[ptr + 1];
      ptr += 2;
      return s;
    }
    function read_u(n_bytes) {
      let s = 0;
      for (let i = 0; i < n_bytes; i++) {
        s = (s << 8 | bytes[ptr]) >>> 0;
        ptr++;
      }
      return s;
    }
    function read_vlen() {
      let is_last = false;
      let s = 0;
      do {
        let n = bytes[ptr] & 127;
        s = (s << 7 | n) >>> 0;
        is_last = !(bytes[ptr] >> 7 & 1);
        ptr++;
      } while (!is_last);
      return s;
    }
    let magic = read_str(4);
    let hd_len = read_u32();
    let hd_fmt = read_u16();
    let hd_ntk = read_u16();
    let div_fmt = bytes[ptr] >> 7 & 1;
    let ot = {};
    if (div_fmt) {
      let x = read_u16() & 32767;
      ot.negative_SMPTE_format = -((~(x >> 8) & 127) + 1);
      ot.ticks_per_frame = x & 255;
    } else {
      ot.ticks_per_quarter_note = read_u16() & 32767;
    }
    let o = __objSpread(__objSpread({
      magic,
      num_tracks: hd_ntk,
      format: hd_fmt,
      time_format: div_fmt ? "TIME_CODE" : "METRIC"
    }, ot), {
      tracks: []
    });
    while (read_str(4) == "MTrk") {
      let track_len = read_u32();
      let p0 = ptr;
      let trk = {events: []};
      while (ptr < p0 + track_len) {
        let dt = read_vlen();
        let e = {type: "UNDEFINED", delta_time: dt, data: {}};
        if (bytes[ptr] == 255) {
          let tmpl = (_a = META_EVENT[bytes[++ptr]]) != null ? _a : ["UNDEFINED"];
          ptr++;
          let len = read_vlen();
          e.type = tmpl[0];
          let chunk = ~~(len / (tmpl.length - 1));
          for (let i = 1; i < tmpl.length; i++) {
            if (tmpl[i] == "text") {
              e.data["text"] = read_str(chunk);
            } else if (tmpl[i] == "data") {
              e.data = bytes.slice(ptr, ptr + chunk);
              ptr += chunk;
            } else {
              e.data[tmpl[i]] = read_u(chunk);
              if (tmpl[i] == "num_sharps_or_flats") {
                let x = e.data[tmpl[i]];
                if (x > 127) {
                  x = -((~x & 255) + 1);
                }
                e.data[tmpl[i]] = x;
              }
            }
          }
        } else if (bytes[ptr] == 240 || bytes[ptr] == 247) {
          e.type = "SYSEX";
          e.data = [];
          do {
            e.data.push(bytes[ptr++]);
          } while (bytes[ptr] != 240 && bytes[ptr] != 247);
          e.data.push(bytes[ptr++]);
        } else {
          let type = bytes[ptr] >> 4 & 15;
          let chan = bytes[ptr] & 15;
          ptr++;
          let tmpl = ["UNDEFINED"];
          if (type == 15) {
            tmpl = (_b = SYSTEM_EVENT[chan]) != null ? _b : tmpl;
          } else {
            tmpl = (_c = MIDI_EVENT[type]) != null ? _c : tmpl;
          }
          if (tmpl[0] == "UNDEFINED" && trk.events.length) {
            ptr--;
            chan = trk.events[trk.events.length - 1].data["channel"];
            tmpl = Object.values(MIDI_EVENT).find((x) => x[0] == trk.events[trk.events.length - 1].type);
          }
          e.type = tmpl[0];
          for (let i = 1; i < tmpl.length; i++) {
            e.data[tmpl[i]] = read_u8();
          }
          e.data["channel"] = chan;
        }
        trk.events.push(e);
      }
      o.tracks.push(trk);
    }
    return o;
  }
  function export_midi(pattern) {
    let bytes = [];
    function write_str(s) {
      for (let i = 0; i < s.length; i++) {
        bytes.push(s.charCodeAt(i));
      }
    }
    function write_u8(n) {
      return bytes.push(n);
    }
    function write_u32(n) {
      bytes.push(n >> 24 & 255);
      bytes.push(n >> 16 & 255);
      bytes.push(n >> 8 & 255);
      bytes.push(n & 255);
    }
    function write_u16(n) {
      bytes.push(n >> 8 & 255);
      bytes.push(n & 255);
    }
    function write_u(n, n_bytes) {
      for (let i = 0; i < n_bytes; i++) {
        bytes.push(n >> (n_bytes - i - 1 << 3) & 255);
      }
    }
    function write_vlen(n) {
      let b = [];
      while (n > 0) {
        b.push(n & 127);
        n = n >>> 7;
      }
      if (!b.length)
        b.push(0);
      b.reverse();
      for (let i = 0; i < b.length - 1; i++) {
        b[i] |= 128;
      }
      bytes.push(...b);
    }
    write_str(pattern.magic);
    write_u32(6);
    write_u16(1);
    write_u16(pattern.num_tracks);
    if (pattern.time_format == "METRIC") {
      write_u16(pattern.ticks_per_quarter_note);
    } else {
      write_u16(pattern.ticks_per_frame | ~(-pattern.negative_SMPTE_format - 1) << 8);
    }
    for (let i = 0; i < pattern.tracks.length; i++) {
      write_str("MTrk");
      let len_pos = bytes.length;
      bytes.push(0, 0, 0, 0);
      for (let j = 0; j < pattern.tracks[i].events.length; j++) {
        let e = pattern.tracks[i].events[j];
        write_vlen(e.delta_time);
        if (META_EVENT_LOOKUP[e.type]) {
          let k = META_EVENT_LOOKUP[e.type][0];
          write_u8(255);
          write_u8(Number(k));
          if (META_EVENT[k][1] == "text") {
            write_vlen(e.data["text"].length);
            write_str(e.data["text"]);
          } else if (META_EVENT[k][1] == "value") {
            if (e.type == "SEQUENCE_NUMBER") {
              write_u8(2);
              write_u16(e.data["value"]);
            } else {
              write_u8(1);
              write_u8(e.data["value"]);
            }
          } else if (META_EVENT[k][1] == "data") {
            write_vlen(e.data.length);
            bytes.push(...e.data);
          } else {
            write_vlen(META_EVENT[k].length - 1);
            for (let j2 = 1; j2 < META_EVENT[k].length; j2++) {
              let x = e.data[META_EVENT[k][j2]];
              if (META_EVENT[k][j2] == "num_sharps_or_flats" && x < 0) {
                x = (~-x & 255) + 1;
              }
              bytes.push(x);
            }
          }
        } else if (MIDI_EVENT_LOOKUP[e.type]) {
          let k = Number(MIDI_EVENT_LOOKUP[e.type][0]);
          bytes.push(k << 4 | e.data["channel"]);
          for (let j2 = 1; j2 < MIDI_EVENT[k].length; j2++) {
            write_u8(e.data[MIDI_EVENT[k][j2]]);
          }
        } else if (SYSTEM_EVENT_LOOKUP[e.type]) {
          let k = Number(SYSTEM_EVENT_LOOKUP[e.type][0]);
          bytes.push(15 << 4 | k);
          for (let j2 = 1; j2 < SYSTEM_EVENT[k].length; j2++) {
            write_u8(e.data[SYSTEM_EVENT[k][j2]]);
          }
        } else {
          for (let j2 = 1; j2 < e.data.length; j2++) {
            write_u8(e.data[j2]);
          }
        }
      }
      let n = bytes.length - len_pos - 4;
      bytes[len_pos] = n >> 24 & 255;
      bytes[len_pos + 1] = n >> 16 & 255;
      bytes[len_pos + 2] = n >> 8 & 255;
      bytes[len_pos + 3] = n & 255;
    }
    return bytes;
  }

  // src/txtfmt.ts
  var ARTICULATION_SYMBOL_LOOKUP = {
    ">": ARTICULATION.ACCENT,
    "^": ARTICULATION.MARCATO,
    ".": ARTICULATION.STACCATO,
    "-": ARTICULATION.TENUTO,
    ",": ARTICULATION.SPICCATO,
    "?": ARTICULATION.FERMATA,
    "+": ARTICULATION.TREMBLEMENT,
    t: ARTICULATION.TRILL,
    o: ARTICULATION.FLAGEOLET,
    m: ARTICULATION.MORDENT,
    s: ARTICULATION.TURN,
    v: ARTICULATION.UP_BOW,
    "{": ARTICULATION.ARPEGGIATED
  };
  var ARTICULATION_SYMBOL = Object.fromEntries(Object.entries(ARTICULATION_SYMBOL_LOOKUP).map((x) => [x[1], x[0]]));
  function parse_txt(txt) {
    txt = txt.replace(/[\n\r\t]/g, " ");
    let swap_sp = "\uFFFF";
    let swap_sp_re = new RegExp(swap_sp, "g");
    let swap_qt = "\uFFFE";
    let swap_qt_re = new RegExp(swap_qt, "g");
    txt = txt.replace(/\\'/g, swap_qt);
    txt = txt.split("'").map((x, i2) => i2 % 2 ? x.replace(/ /g, swap_sp) : x).join("'");
    txt = txt.split(";").filter((_, i2) => !(i2 % 2)).join(" ");
    let words = txt.split(" ").filter((x) => x.length).map((x) => x.replace(swap_sp_re, " ").replace(swap_qt_re, "'"));
    let score = {
      title: [],
      instruments: [],
      composer: [],
      slurs: [],
      measures: [],
      crescs: []
    };
    let measure;
    let staff;
    let note;
    let rest;
    let slur;
    let cresc;
    let i = 0;
    let state = [];
    let begin = 0;
    let voice = 0;
    let begin0 = 0;
    let rest_hidden = false;
    let tup_state = [];
    function curr_state(s) {
      return state[state.length - 1] == s;
    }
    function pop_short_state() {
      let curr = state[state.length - 1];
      if (curr) {
        if (curr == "note") {
          state.pop();
          if (note.tuplet && note.tuplet.display_duration === null) {
            note.tuplet.display_duration = note.duration;
            note.duration = Math.max(1, ~~(note.duration * tup_state[tup_state.length - 1].mul));
          }
          if (note.tuplet)
            tup_state[tup_state.length - 1].members.push(note);
          if (curr_state("grace") || state.includes("grace")) {
            if (!staff.grace[begin0]) {
              staff.grace[begin0] = {duration: 0, barline: BARLINE.NONE, staves: [{
                clef: staff.clef,
                time_signature: [1, 1],
                key_signature: staff.key_signature,
                notes: [],
                grace: [],
                rests: [],
                voices: 1,
                beams: []
              }]};
            }
            staff.grace[begin0].staves[0].notes.push(note);
          } else {
            staff.notes.push(note);
          }
          measure.duration = Math.max(measure.duration, begin + note.duration);
          if (!curr_state("chord")) {
            begin += note.duration;
          }
        } else if (curr == "rest") {
          state.pop();
          if (rest.tuplet && rest.tuplet.display_duration === null) {
            rest.tuplet.display_duration = rest.duration;
            rest.duration = Math.max(1, ~~(rest.duration * tup_state[tup_state.length - 1].mul));
          }
          if (rest.tuplet && !rest_hidden)
            tup_state[tup_state.length - 1].members.push(rest);
          measure.duration = Math.max(measure.duration, begin + rest.duration);
          begin += rest.duration;
          if (!rest_hidden)
            staff.rests.push(rest);
        } else if (curr == "title" || curr == "composer" || curr == "instruments" || curr == "tempo") {
          state.pop();
        } else if (curr == "slur") {
          state.pop();
          score.slurs.push(slur);
        } else if (curr == "cresc") {
          state.pop();
          score.crescs.push(cresc);
        }
      }
    }
    function switch_state(s) {
      pop_short_state();
      state.push(s);
    }
    function parse_dur(x) {
      if (x[x.length - 1] == ".") {
        return [96 / Number(x.slice(0, -1)), true];
      } else {
        return [64 / Number(x), false];
      }
    }
    while (i < words.length) {
      let x = words[i];
      if (x == "end") {
        pop_short_state();
        if (curr_state("staff")) {
          compile_staff2(staff);
          measure.staves.push(staff);
        } else if (curr_state("measure")) {
          score.measures.push(measure);
        } else if (curr_state("chord")) {
          if (state.includes("grace")) {
            begin += staff.grace[begin0].staves[0].notes[staff.grace[begin0].staves[0].notes.length - 1].duration;
          } else {
            begin += staff.notes[staff.notes.length - 1].duration;
          }
        } else if (curr_state("voice")) {
          voice++;
          begin = 0;
        } else if (curr_state("grace")) {
          staff.grace[begin0].duration = Math.max(staff.grace[begin0].duration, begin);
          compile_staff2(staff.grace[begin0].staves[0], -1);
          begin = begin0;
        } else if (curr_state("tuplet")) {
          let tup = tup_state.pop();
          let sum = tup.members[tup.members.length - 1].begin - tup.begin + tup.members[tup.members.length - 1].duration;
          let remain = tup.dur - sum;
          for (let i2 = tup.members.length - 1; i2 >= 0; i2--) {
            if (tup.members[i2].begin == tup.members[tup.members.length - 1].begin) {
              tup.members[i2].duration += remain;
            } else {
              break;
            }
          }
          begin = tup.begin + tup.dur;
        }
        state.pop();
      } else if (x == "title") {
        switch_state("title");
      } else if (x == "composer") {
        switch_state("composer");
      } else if (x == "instruments") {
        switch_state("instruments");
      } else if (x == "tempo") {
        switch_state("tempo");
      } else if (x == "measure") {
        switch_state("measure");
        measure = {
          duration: 0,
          barline: BARLINE.SINGLE,
          staves: []
        };
      } else if (x == "staff") {
        switch_state("staff");
        staff = {
          clef: CLEF.TREBLE,
          time_signature: [4, 4],
          key_signature: [0, 0],
          notes: [],
          grace: [],
          rests: [],
          voices: 1,
          beams: []
        };
        if (score.measures[score.measures.length - 1]) {
          if (score.measures[score.measures.length - 1].staves[measure.staves.length]) {
            let prev = score.measures[score.measures.length - 1].staves[measure.staves.length];
            staff.time_signature[0] = prev.time_signature[0];
            staff.time_signature[1] = prev.time_signature[1];
            staff.key_signature[0] = prev.key_signature[0];
            staff.key_signature[1] = prev.key_signature[1];
            staff.clef = prev.clef;
          }
        }
        begin = 0;
        voice = 0;
      } else if (x == "note") {
        switch_state("note");
        note = {
          begin: null,
          duration: null,
          accidental: null,
          modifier: false,
          octave: null,
          name: null,
          voice: null,
          staff_pos: null,
          stem_dir: null,
          prev_in_chord: null,
          next_in_chord: null,
          tuplet: null
        };
        if (state[state.length - 2] == "grace" && staff.grace[begin0] && staff.grace[begin0].staves[0].notes.length) {
          let notes = staff.grace[begin0].staves[0].notes;
          if (notes[notes.length - 1]) {
            Object.assign(note, notes[notes.length - 1]);
          }
        } else {
          if (staff.notes[staff.notes.length - 1]) {
            Object.assign(note, staff.notes[staff.notes.length - 1]);
          }
        }
        note.begin = begin;
        note.accidental = null;
        note.voice = voice;
        if (note.id) {
          delete note.id;
        }
        if (note.lyric) {
          delete note.lyric;
        }
        if (note.articulation) {
          delete note.articulation;
        }
        if (note.cue) {
          delete note.cue;
        }
        if (state[state.length - 2] != "grace") {
          let tup = tup_state[tup_state.length - 1];
          if (note.tuplet && tup) {
            if (note.tuplet.id != tup.id) {
              note.tuplet = {id: tup.id, display_duration: null, label: tup.num};
            }
          } else if (tup && !note.tuplet) {
            note.tuplet = {id: tup.id, display_duration: null, label: tup.num};
          } else if (!tup && note.tuplet) {
            note.tuplet = null;
          }
        } else {
          note.tuplet = null;
        }
      } else if (x == "rest") {
        switch_state("rest");
        rest = {
          begin: null,
          duration: null,
          voice: null,
          tuplet: null
        };
        rest_hidden = false;
        if (staff.rests[staff.rests.length - 1]) {
          Object.assign(rest, staff.rests[staff.rests.length - 1]);
        }
        rest.begin = begin;
        rest.voice = voice;
        if (rest.cue) {
          delete rest.cue;
        }
        if (state[state.length - 2] != "grace") {
          let tup = tup_state[tup_state.length - 1];
          if (rest.tuplet && tup) {
            if (rest.tuplet.id != tup.id) {
              rest.tuplet = {id: tup.id, display_duration: null, label: tup.num};
            }
          } else if (tup && !rest.tuplet) {
            rest.tuplet = {id: tup.id, display_duration: null, label: tup.num};
          } else if (!tup && rest.tuplet) {
            rest.tuplet = null;
          }
        } else {
          rest.tuplet = null;
        }
      } else if (x == "chord") {
        switch_state("chord");
      } else if (x == "grace") {
        switch_state("grace");
        begin0 = begin;
        begin = 0;
      } else if (x == "tuplet") {
        switch_state("tuplet");
        tup_state.push({
          id: short_id(),
          mul: 1,
          begin,
          dur: 0,
          num: 3,
          members: []
        });
      } else if (x == "voice") {
        switch_state("voice");
      } else if (x == "slur") {
        switch_state("slur");
        slur = {
          left: null,
          right: null,
          is_tie: false
        };
      } else if (x == "tie") {
        switch_state("slur");
        slur = {
          left: null,
          right: null,
          is_tie: true
        };
      } else if (x == "cresc") {
        switch_state("cresc");
        cresc = {
          left: null,
          right: null,
          val_left: null,
          val_right: null
        };
      } else if (curr_state("measure")) {
        if (x.startsWith("|") || x.startsWith(":")) {
          if (x == "|") {
            measure.barline = BARLINE.SINGLE;
          } else if (x == "||") {
            measure.barline = BARLINE.DOUBLE;
          } else if (x == "|||") {
            measure.barline = BARLINE.END;
          } else if (x == "|:") {
            measure.barline = BARLINE.REPEAT_BEGIN;
          } else if (x == ":|") {
            measure.barline = BARLINE.REPEAT_END;
          } else if (x == ":|:") {
            measure.barline = BARLINE.REPEAT_END_BEGIN;
          }
        }
      } else if (curr_state("staff")) {
        if (x == "G") {
          staff.clef = CLEF.TREBLE;
        } else if (x == "F") {
          staff.clef = CLEF.BASS;
        } else if (x == "Ca" || x == "C") {
          staff.clef = CLEF.ALTO;
        } else if (x == "Ct") {
          staff.clef = CLEF.TENOR;
        } else if (x == "Cm") {
          staff.clef = CLEF.MEZZO_SOPRANO;
        } else if (x == "Cs") {
          staff.clef = CLEF.SOPRANO;
        } else if (x == "Cb") {
          staff.clef = CLEF.BARITONE;
        } else if (x == "~") {
          staff.key_signature = [0, 0];
        } else if (x.startsWith("b")) {
          staff.key_signature = [ACCIDENTAL.FLAT, x.length];
        } else if (x.startsWith("#")) {
          staff.key_signature = [ACCIDENTAL.SHARP, x.length];
        } else if (x.includes("/")) {
          let s = x.split("/");
          staff.time_signature = [Number(s[0]), Number(s[1])];
        }
      } else if (curr_state("note")) {
        if (/^[A-Z].*/.test(x)) {
          note.name = x[0];
          note.octave = Number(x.slice(1));
        } else if (x[0] == "d") {
          let [dur, mod] = parse_dur(x.slice(1));
          note.duration = dur;
          note.modifier = mod;
          if (note.tuplet)
            note.tuplet.display_duration = null;
        } else if (x[0] == "$") {
          note.id = x.slice(1);
        } else if (x[0] == "#") {
          note.accidental = ACCIDENTAL.SHARP;
        } else if (x[0] == "b") {
          note.accidental = ACCIDENTAL.FLAT;
        } else if (x[0] == "~") {
          note.accidental = ACCIDENTAL.NATURAL;
        } else if (x[0] == "l") {
          note.lyric = x.slice(1).replace(/(^')|('$)/g, "");
        } else if (x[0] == "a") {
          if (ARTICULATION_SYMBOL_LOOKUP[x[1]]) {
            note.articulation = ARTICULATION_SYMBOL_LOOKUP[x[1]];
          } else {
            note.articulation = Number(x[1]);
          }
          if (x[2] == "|") {
            note.articulation = -note.articulation;
          }
        } else if (x[0] == "|") {
          note.cue = {position: 0, data: x.slice(1).replace(/(^')|('$)/g, "")};
        } else if (x[0] == "[") {
          note.cue = {position: -1, data: x.slice(1).replace(/(^')|('$)/g, "")};
        } else if (x[0] == "]") {
          note.cue = {position: 1, data: x.slice(1).replace(/(^')|('$)/g, "")};
        }
      } else if (curr_state("rest")) {
        if (x[0] == "d") {
          let dur = 64 / Number(x.slice(1));
          rest.duration = dur;
          if (rest.tuplet)
            rest.tuplet.display_duration = null;
        } else if (x[0] == "|") {
          rest.cue = {position: 0, data: x.slice(1).replace(/(^')|('$)/g, "")};
        } else if (x[0] == "[") {
          rest.cue = {position: -1, data: x.slice(1).replace(/(^')|('$)/g, "")};
        } else if (x[0] == "]") {
          rest.cue = {position: 1, data: x.slice(1).replace(/(^')|('$)/g, "")};
        } else if (x[0] == "-") {
          rest_hidden = true;
        }
      } else if (curr_state("slur")) {
        if (x[0] == "$") {
          if (slur.left == null) {
            slur.left = x.slice(1);
          } else {
            slur.right = x.slice(1);
          }
        }
      } else if (curr_state("cresc")) {
        if (x[0] == "$") {
          if (cresc.left == null) {
            cresc.left = x.slice(1);
          } else {
            cresc.right = x.slice(1);
          }
        } else {
          if (cresc.val_left === null) {
            cresc.val_left = Number(x);
          } else {
            cresc.val_right = Number(x);
          }
        }
      } else if (curr_state("tuplet")) {
        if (x[0] == "d") {
          let [a_, b_] = x.slice(1).split("/");
          let a = parse_dur(a_)[0];
          let b = parse_dur(b_)[0];
          tup_state[tup_state.length - 1].mul = a / b;
          tup_state[tup_state.length - 1].dur = a;
        } else {
          let n = Number(x);
          tup_state[tup_state.length - 1].num = n;
        }
      } else if (curr_state("title")) {
        score.title.push(x.replace(/(^')|('$)/g, ""));
      } else if (curr_state("composer")) {
        score.composer.push(x.replace(/(^')|('$)/g, ""));
      } else if (curr_state("instruments")) {
        if (x == "{") {
          while (score.instruments[score.instruments.length - 1] && score.instruments[score.instruments.length - 1].connect_barlines.length < score.instruments[score.instruments.length - 1].names.length)
            score.instruments[score.instruments.length - 1].connect_barlines.push(false);
          score.instruments.push({bracket: BRACKET.BRACE, names: [], connect_barlines: []});
        } else if (x == "[") {
          while (score.instruments[score.instruments.length - 1] && score.instruments[score.instruments.length - 1].connect_barlines.length < score.instruments[score.instruments.length - 1].names.length)
            score.instruments[score.instruments.length - 1].connect_barlines.push(false);
          score.instruments.push({bracket: BRACKET.BRACKET, names: [], connect_barlines: []});
        } else if (x == "|") {
          while (score.instruments[score.instruments.length - 1] && score.instruments[score.instruments.length - 1].connect_barlines.length < score.instruments[score.instruments.length - 1].names.length)
            score.instruments[score.instruments.length - 1].connect_barlines.push(false);
          score.instruments.push({bracket: BRACKET.NONE, names: [], connect_barlines: []});
        } else if (x == "-") {
          score.instruments[score.instruments.length - 1].connect_barlines.push(true);
        } else {
          if (!score.instruments.length) {
            score.instruments.push({bracket: BRACKET.NONE, names: [], connect_barlines: []});
          }
          let group = score.instruments[score.instruments.length - 1];
          if (group.connect_barlines.length < group.names.length) {
            group.connect_barlines.push(false);
          }
          group.names.push(x.replace(/(^')|('$)/g, ""));
        }
      } else if (curr_state("tempo")) {
        if (!score.tempo) {
          score.tempo = {};
        }
        if (x[0] == "d") {
          let [dur, mod] = parse_dur(x.slice(1));
          score.tempo.duration = dur;
          score.tempo.modifier = mod;
        } else if (x[0] == "=") {
          score.tempo.bpm = Number(x.slice(1));
        } else {
          score.tempo.text = x.replace(/(^')|('$)/g, "");
        }
      }
      i++;
    }
    pop_short_state();
    return score;
  }
  function compile_staff2(staff, force_stem_dir = 0) {
    for (let i = 0; i < staff.notes.length; i++) {
      staff.voices = Math.max(staff.notes[i].voice + 1, staff.voices);
    }
    for (let i = 0; i < staff.rests.length; i++) {
      staff.voices = Math.max(staff.rests[i].voice + 1, staff.voices);
    }
    function get_beat_length(time_sig) {
      if (CONFIG.BEAM_POLICY == 0) {
        return 1;
      } else if (CONFIG.BEAM_POLICY == 1) {
        return ~~(NOTE_LENGTH.WHOLE / time_sig[1]);
      } else {
        let beat_length2 = ~~(NOTE_LENGTH.WHOLE / time_sig[1]);
        beat_length2 *= time_sig[0] % 2 || time_sig[0] <= 2 && time_sig[1] > 2 ? time_sig[0] : time_sig[0] / 2;
        return beat_length2;
      }
    }
    let beat_length = get_beat_length(staff.time_signature);
    function get_beat_idx(note) {
      return ~~(note.begin / beat_length);
    }
    function get_notes_in_beat(beat_idx) {
      let notes = [];
      for (let m of staff.notes) {
        if (get_beat_idx(m) == beat_idx) {
          notes.push(m);
        }
      }
      return notes;
    }
    function calc_stem_dir(note) {
      let notes_in_beat;
      if (note.duration < NOTE_LENGTH.QUARTER) {
        let beat_idx = get_beat_idx(note);
        if (note.tuplet) {
          notes_in_beat = staff.notes.filter((x) => x.tuplet && x.tuplet.id == note.tuplet.id);
        } else {
          notes_in_beat = get_notes_in_beat(beat_idx).filter((x) => x.duration < NOTE_LENGTH.QUARTER);
        }
      } else {
        notes_in_beat = [];
        for (let m of staff.notes) {
          if (m.begin == note.begin) {
            notes_in_beat.push(m);
          }
        }
      }
      let avg_line = notes_in_beat.reduce((acc, x) => acc + x.staff_pos, 0) / notes_in_beat.length;
      if (avg_line < 4) {
        return 1;
      } else {
        return -1;
      }
    }
    let [measure_acc, num_acc] = staff.key_signature;
    let acc_names = ORDER_OF_ACCIDENTALS[measure_acc].slice(0, num_acc).split("");
    let acc_history = {};
    for (let i = 0; i < staff.notes.length; i++) {
      let note = staff.notes[i];
      let note_bname = note.name;
      let key = note_bname + "_" + note.octave;
      if (note.accidental != null) {
        note.name = note_bname + ["b", "", "s"][note.accidental + 1];
        acc_history[key] = note.accidental;
      } else {
        if (acc_history[key] === void 0) {
          if (acc_names.includes(note_bname)) {
            note.name = note_bname + ["b", null, "s"][measure_acc + 1];
            acc_history[key] = measure_acc;
          } else {
            note.name = note_bname;
          }
        } else {
          note.name = note_bname + ["b", "", "s"][acc_history[key] + 1];
        }
      }
      note.name += "_";
      note.name += note.octave;
      note.staff_pos = note_name_to_staff_pos(note.name, staff.clef);
    }
    for (let i = 0; i < staff.notes.length; i++) {
      let note = staff.notes[i];
      let stem_dir;
      if (staff.voices == 1) {
        stem_dir = force_stem_dir || calc_stem_dir(note);
      } else {
        stem_dir = note.voice % 2 ? 1 : -1;
      }
      note.stem_dir = stem_dir;
    }
    chord_and_beam_staff(staff, beat_length);
  }
  function export_txt(score) {
    let o = "";
    o += `title '${score.title.map((x) => x.replace(/'/g, "\\'")).join("' '")}'
`;
    if (score.composer) {
      o += `composer '${score.composer}'
`;
    }
    if (score.tempo) {
      o += `tempo`;
      if (score.tempo.text) {
        o += ` '` + score.tempo.text.replace(/'/g, "\\'") + `'`;
      }
      if (score.tempo.duration) {
        if (score.tempo.modifier) {
          o += " d" + (96 / score.tempo.duration).toString() + ".";
        } else {
          o += " d" + (64 / score.tempo.duration).toString();
        }
        if (score.tempo.bpm) {
          o += " =" + score.tempo.bpm;
        }
      }
      o += "\n";
    }
    if (score.instruments.length) {
      o += "instruments ";
      for (let i = 0; i < score.instruments.length; i++) {
        o += ["", "{", "["][score.instruments[i].bracket] + " ";
        for (let j = 0; j < score.instruments[i].names.length; j++) {
          if (j && score.instruments[i].connect_barlines[j - 1]) {
            o += " - ";
          }
          o += `'${score.instruments[i].names[j].replace(/'/g, "\\'")}' `;
        }
      }
      o += "\n";
    }
    for (let i = 0; i < score.measures.length; i++) {
      let measure = score.measures[i];
      o += `measure`;
      if (measure.barline == BARLINE.DOUBLE) {
        o += ` ||`;
      } else if (measure.barline == BARLINE.REPEAT_BEGIN) {
        o += ` |:`;
      } else if (measure.barline == BARLINE.REPEAT_END) {
        o += ` :|`;
      } else if (measure.barline == BARLINE.END) {
        o += ` |||`;
      } else if (measure.barline == BARLINE.REPEAT_END_BEGIN) {
        o += ` :|:`;
      }
      o += `
`;
      for (let j = 0; j < measure.staves.length; j++) {
        let staff = measure.staves[j];
        o += `  staff ${staff.clef == CLEF.TREBLE ? "G" : "F"} ${["b", "", "#"][staff.key_signature[0] + 1].repeat(staff.key_signature[1])} ${staff.time_signature[0]}/${staff.time_signature[1]}
`;
        for (let k = 0; k < staff.voices; k++) {
          let do_items = function(items2) {
            var _a;
            for (let l = 0; l < items2.length; l++) {
              let done = items2[l][2];
              if (done) {
                continue;
              }
              if (items2[l][1].tuplet) {
                let count = function() {
                  let begin = -1;
                  let real = 0;
                  let disp = 0;
                  for (let m = l; m < items2.length; m++) {
                    if (!items2[m][1].tuplet || items2[m][1].tuplet.id != items2[l][1].tuplet.id) {
                      break;
                    }
                    if (items2[m][1].begin != begin) {
                      begin = items2[m][1].begin;
                      disp += items2[m][1].tuplet.display_duration;
                    }
                    real = items2[m][1].begin - items2[l][1].begin + items2[m][1].duration;
                  }
                  function to_str(n) {
                    if (64 / n == ~~(64 / n)) {
                      return (~~(64 / n)).toString();
                    } else {
                      return (~~(96 / n)).toString() + ".";
                    }
                  }
                  let real_str = to_str(real);
                  let disp_str = to_str(disp);
                  return [real_str, disp_str];
                };
                let prev_tup_id = null;
                for (let m = l - 1; m >= 0; m--) {
                  let e = items2[m][1];
                  if (e.tuplet) {
                    prev_tup_id = items2[m][1].tuplet.id;
                    break;
                  }
                }
                if (!items2[l - 1] || prev_tup_id === null) {
                  o += `   tuplet ${items2[l][1].tuplet.label} d${count().join("/")}
`;
                } else if (prev_tup_id !== null && prev_tup_id != items2[l][1].tuplet.id) {
                  o += `   end
   tuplet ${items2[l][1].tuplet.label} d${count().join("/")}
`;
                }
              } else if (items2[l - 1] && items2[l - 1][1].tuplet) {
                let next_tup_id = null;
                for (let m = l + 1; m < items2.length; m++) {
                  let e = items2[m][1];
                  if (e.tuplet) {
                    next_tup_id = items2[m][1].tuplet.id;
                    break;
                  }
                }
                if (items2[l - 1][1].tuplet.id != next_tup_id) {
                  o += `   end
`;
                }
              }
              if (items2[l][0] == "note") {
                let e = items2[l][1];
                while (e.prev_in_chord !== null) {
                  e = staff.notes[e.prev_in_chord];
                }
                let is_chord = e.next_in_chord !== null;
                if (is_chord)
                  o += "    chord\n";
                do {
                  items2.find((x) => x[1] == e)[2] = true;
                  let s = ["note"];
                  s.push(e.name[0] + e.octave);
                  if (e.accidental !== null) {
                    s.push(["b", "~", "#"][e.accidental + 1]);
                  }
                  let dur = e.duration;
                  if (e.tuplet) {
                    dur = e.tuplet.display_duration;
                  }
                  if (e.modifier) {
                    s.push("d" + (96 / dur).toString() + ".");
                  } else {
                    s.push("d" + (64 / dur).toString());
                  }
                  if (e.articulation) {
                    s.push("a" + ((_a = ARTICULATION_SYMBOL[e.articulation]) != null ? _a : e.articulation));
                  }
                  if (e.cue) {
                    s.push(`${["[", "|", "]"][e.cue.position + 1]}'${e.cue.data.replace(/'/g, "\\'")}'`);
                  }
                  if (e.lyric) {
                    s.push(`l'${e.lyric.replace(/'/g, "\\'")}'`);
                  }
                  let t = "    ";
                  if (is_chord)
                    t += "  ";
                  t += s.join(" ");
                  if (e.id) {
                    t = t.padEnd(50, " ") + " $" + e.id;
                  }
                  o += t + "\n";
                  e = staff.notes[e.next_in_chord];
                } while (e);
                if (is_chord)
                  o += "    end\n";
              } else if (items2[l][0] == "rest") {
                let e = items2[l][1];
                let dur = e.duration;
                if (e.tuplet) {
                  dur = e.tuplet.display_duration;
                }
                o += `    rest d${64 / dur}`;
                if (e.cue) {
                  o += ` ${["[", "|", "]"][e.cue.position + 1]}'${e.cue.data.replace(/'/g, "\\'")}'`;
                }
                o += "\n";
              } else if (items2[l][0] == "grace") {
                o += `   grace
`;
                do_items(items2[l][1].items);
                o += `   end
`;
              } else {
              }
            }
            if (items2[items2.length - 1] && items2[items2.length - 1][1].tuplet) {
              o += `   end
`;
            }
          };
          let items = [];
          for (let l = 0; l < staff.notes.length; l++) {
            if (staff.notes[l].voice == k) {
              items.push(["note", staff.notes[l], false]);
            }
          }
          for (let l = 0; l < staff.rests.length; l++) {
            if (staff.rests[l].voice == k) {
              items.push(["rest", staff.rests[l], false]);
            }
          }
          for (let l = 0; l < staff.grace.length; l++) {
            if (!staff.grace[l]) {
              continue;
            }
            let grace_item = ["grace", {begin: l - 1e-3, duration: staff.grace[l].duration, items: []}, false];
            for (let m = 0; m < staff.grace[l].staves[0].notes.length; m++) {
              let n = staff.grace[l].staves[0].notes[m];
              if (n.voice == k) {
                grace_item[1].items.push(["note", n, false]);
              }
            }
            for (let m = 0; m < staff.grace[l].staves[0].rests.length; m++) {
              let n = staff.grace[l].staves[0].rests[m];
              if (n.voice == k) {
                grace_item[1].items.push(["rest", n, false]);
              }
            }
            grace_item[1].items.sort((a, b) => a[1].begin - b[1].begin);
            if (grace_item[1].items.length)
              items.push(grace_item);
          }
          items.sort((a, b) => a[1].begin - b[1].begin);
          if (staff.voices > 1) {
            o += "   voice\n";
          }
          do_items(items);
          if (staff.voices > 1) {
            o += "   end\n";
          }
        }
        o += `  end
`;
      }
      o += `end
`;
    }
    for (let i = 0; i < score.slurs.length; i++) {
      let slur = score.slurs[i];
      if (slur.is_tie) {
        o += `tie $${slur.left} $${slur.right}
`;
      } else {
        o += `slur $${slur.left} $${slur.right}
`;
      }
    }
    for (let i = 0; i < score.crescs.length; i++) {
      let cresc = score.crescs[i];
      o += `cresc ${cresc.val_left} ${cresc.val_right} $${cresc.left} $${cresc.right}
`;
    }
    return o;
  }

  // src/main.ts
  var CONFIG = {
    PAGE_WIDTH: 1200,
    LINE_HEIGHT: 9,
    NOTE_WIDTH: 12,
    REST_WIDTH_MUL: 1,
    CLEF_WIDTH_MUL: 2,
    TIMESIG_WIDTH_MUL: 2,
    KEYSIG_WIDTH_MUL: 0.8,
    ACCIDENTAL_WIDTH_MUL: 1.2,
    LEDGER_WIDTH_MUL: 0.75,
    INTER_NOTE_WIDTH: 4,
    DURATION_BASED_SPACING: 0.05,
    FLAG_SPACING: 0.72,
    MEASURE_PAD_FRONT: 12,
    MEASURE_PAD_BACK: 12,
    INTER_STAFF_HEIGHT: 70,
    INTER_ROW_HEIGHT: 100,
    STEM_LENGTH: 2.5,
    PAGE_MARGIN_X: 100,
    PAGE_MARGIN_Y: 50,
    TITLE_TEXT_SIZE: 34,
    SUBTITLE_TEXT_SIZE: 20,
    TITLE_LINE_SPACING: 12,
    TEMPO_COMPOSER_TEXT_SIZE: 14,
    INSTRUMENT_TEXT_SIZE: 16,
    MEASURE_NUMBER_TEXT_SIZE: 12,
    INSTRUMENT_PAD_RIGHT: 20,
    BEAM_MAX_SLOPE: 0.4,
    LINES_PER_STAFF: 5,
    GRACE_WIDTH_MUL: 0.4,
    LYRIC_SCALE: 0.6,
    LYRIC_SPACING: 12,
    CUE_TEXT_SIZE: 22,
    CUE_HEIGHT: 22,
    SQUIGGLE_WIDTH_MUL: 1.5,
    JUSTIFY_ALIGN_MIN: 0.75,
    SLUR_ARC_MUL: 1,
    SHOW_SOLO_INSTRUMENT: 0,
    SHOW_MEASURE_NUMBER: 1,
    HEADBUTT_RESOLVE: 1,
    HEADBUTT_MERGE: 1,
    CUE_EVADE: 1,
    SLUR_EVADE: 1,
    JOIN_STAFF_LINES: 1,
    TUPLET_LABEL_SPACING: 1.1,
    WHOLE_HALF_REST_LEDGERS: 0,
    TIMESIG_COMMON_TIME_C: 0,
    BEAM_POLICY: 3,
    DEBUG_BLOCKS: 0
  };
  var NOTE_LENGTH_MODIFIER2 = 1.5;
  var FONT_INHERENT_HEIGHT = 24;
  function CONTENT_WIDTH() {
    return CONFIG.PAGE_WIDTH - CONFIG.PAGE_MARGIN_X * 2;
  }
  var id_registry = {};
  function staff_has_cue_lyric(staff, crescs = null) {
    let has_cue = false;
    for (let i = 0; i < staff.notes.length; i++) {
      if (staff.notes[i].cue) {
        has_cue = true;
        break;
      }
    }
    if (!has_cue) {
      for (let i = 0; i < staff.rests.length; i++) {
        if (staff.rests[i].cue) {
          has_cue = true;
          break;
        }
      }
    }
    if (!has_cue && crescs && crescs.length) {
      for (let i = 0; i < staff.notes.length; i++) {
        if (staff.notes[i].id) {
          for (let j = 0; j < crescs.length; j++) {
            if (crescs[j].left == staff.notes[i].id || crescs[j].right == staff.notes[i].id) {
              has_cue = true;
              break;
            }
          }
          if (has_cue) {
            break;
          }
        }
      }
    }
    let has_lyric = false;
    for (let i = 0; i < staff.notes.length; i++) {
      if (staff.notes[i].lyric) {
        has_lyric = true;
        break;
      }
    }
    staff.flags.need_cue = has_cue;
    staff.flags.need_lyric = has_lyric;
  }
  function calc_staff_flags(score, measure_idx, staff_idx) {
    let measures = score.measures;
    if (measure_idx != 0) {
      let ks0 = measures[measure_idx - 1].staves[staff_idx].key_signature;
      let ks1 = measures[measure_idx].staves[staff_idx].key_signature;
      if (ks0[0] != ks1[0] || ks0[1] != ks1[1]) {
        let [acc0, num_acc0] = ks0;
        let [acc1, num_acc1] = ks1;
        if (num_acc0 > 0 && num_acc1 == 0) {
          measures[measure_idx].staves[staff_idx].flags.need_keysig = {
            accidental: ~acc0,
            count: num_acc0
          };
        } else {
          measures[measure_idx].staves[staff_idx].flags.need_keysig = {
            accidental: acc1,
            count: num_acc1
          };
        }
      }
      let ts0 = measures[measure_idx - 1].staves[staff_idx].time_signature;
      let ts1 = measures[measure_idx].staves[staff_idx].time_signature;
      if (ts0[0] != ts1[0] || ts0[1] != ts1[1]) {
        measures[measure_idx].staves[staff_idx].flags.need_timesig = true;
      }
      if (measures[measure_idx - 1].staves[staff_idx].clef != measures[measure_idx].staves[staff_idx].clef) {
        measures[measure_idx].staves[staff_idx].flags.need_clef = true;
      }
    } else {
      let [acc, num_acc] = measures[measure_idx].staves[staff_idx].key_signature;
      measures[measure_idx].staves[staff_idx].flags.need_keysig = {
        accidental: acc,
        count: num_acc
      };
      measures[measure_idx].staves[staff_idx].flags.need_timesig = true;
      measures[measure_idx].staves[staff_idx].flags.need_clef = true;
    }
    staff_has_cue_lyric(measures[measure_idx].staves[staff_idx], score.crescs);
  }
  function has_twisted_sibling(notes, idx) {
    let note = notes[idx];
    let does = note.twisted;
    if (does)
      return does;
    let head_note = note;
    let tail_note = note;
    while (head_note.prev_in_chord != null) {
      head_note = notes[head_note.prev_in_chord];
      if (head_note.twisted)
        does = true;
    }
    if (does)
      return does;
    while (tail_note.next_in_chord != null) {
      tail_note = notes[tail_note.next_in_chord];
      if (tail_note.twisted)
        does = true;
    }
    return does;
  }
  function compile_measure(measure) {
    function get_index_in_chord(notes, note) {
      let i = 0;
      while (note.prev_in_chord !== null) {
        note = notes[note.prev_in_chord];
        i++;
      }
      return i;
    }
    for (let j = 0; j < measure.staves.length; j++) {
      let staff = measure.staves[j];
      if (!staff.coords) {
        staff.coords = {x: 0, y: 0, w: 0, local_y_min: 0, local_y_max: 0, col: 0, row: 0};
      }
      if (!staff.flags) {
        staff.flags = {need_keysig: null, need_timesig: false, need_clef: false, need_cue: false, need_lyric: false};
      }
      for (let b of staff.beams) {
        for (let k of b) {
          staff.notes[k].beamed = true;
        }
      }
      for (let k = 0; k < staff.notes.length; k++) {
        let note = staff.notes[k];
        let twisted = false;
        let stem_len = CONFIG.STEM_LENGTH;
        let stem_dir = note.stem_dir;
        let flag_count = 0;
        if (note.prev_in_chord !== null) {
          let pd = note.staff_pos - staff.notes[note.prev_in_chord].staff_pos;
          if (Math.abs(pd) <= 1) {
            if (get_index_in_chord(staff.notes, note) % 2) {
              twisted = true;
            }
          }
        }
        if (note.next_in_chord !== null) {
          let pd = note.staff_pos - staff.notes[note.next_in_chord].staff_pos;
          if (!twisted && Math.abs(pd) <= 1) {
            if (get_index_in_chord(staff.notes, note) % 2) {
              twisted = true;
            }
          }
          stem_len = Math.abs(pd) / 2;
        } else {
          if (note.tuplet) {
            flag_count = calc_num_flags(note.tuplet.display_duration, note.modifier);
          } else {
            flag_count = calc_num_flags(note.duration, note.modifier);
          }
        }
        stem_len += flag_count * CONFIG.FLAG_SPACING / 2;
        note.stem_len = stem_len;
        note.flag_count = flag_count;
        note.twisted = twisted;
        note.slot_shift = 0;
        note.modifier_shift = 0;
      }
      let beams = staff.beams;
      for (let b of beams) {
        let notes_spanned = [];
        for (let i = 0; i < b.length; i++) {
          notes_spanned.push(staff.notes[b[i]]);
        }
        if (!notes_spanned.length) {
          continue;
        }
        let flagcnts = [];
        for (let i = 0; i < notes_spanned.length; i++) {
          flagcnts.push(notes_spanned[i].flag_count);
        }
        let extra_len = Math.max(0, Math.max(...flagcnts) - 1) * CONFIG.FLAG_SPACING;
        for (let i = 0; i < notes_spanned.length; i++) {
          notes_spanned[i].stem_len += extra_len - notes_spanned[i].flag_count * CONFIG.FLAG_SPACING / 6;
        }
      }
      compile_rests(staff);
    }
    for (let j = 0; j < measure.staves.length; j++) {
      let staff = measure.staves[j];
      for (let i = 0; i < staff.grace.length; i++) {
        if (staff.grace[i]) {
          compile_measure(staff.grace[i]);
          let st = staff.grace[i].staves[0];
          for (let j2 = 0; j2 < st.notes.length; j2++) {
            if (st.notes[j2].next_in_chord == null) {
              st.notes[j2].stem_len *= 0.6;
            }
          }
          staff.grace[i].pad = {left: 0, inter: CONFIG.INTER_NOTE_WIDTH / 2, right: 0};
        }
      }
    }
    measure.pad = {left: CONFIG.MEASURE_PAD_FRONT, inter: CONFIG.INTER_NOTE_WIDTH, right: CONFIG.MEASURE_PAD_BACK};
    make_measure_slots(measure);
    if (CONFIG.HEADBUTT_RESOLVE) {
      for (let j = 0; j < measure.staves.length; j++) {
        let staff = measure.staves[j];
        for (let k = 0; k < staff.notes.length; k++) {
          let try_opt_headbutt = function() {
            if (staff.voices <= 1 || slot.mid_note <= 1 || has_twisted_sibling(staff.notes, k)) {
              return;
            }
            let track = slot.mid_pack.intervals[staff_idx];
            let entry = track.find((a) => a.idx == note_idx);
            if (entry.x > 0) {
              return;
            }
            let collider = null;
            for (let j2 = 0; j2 < track.length; j2++) {
              if (track[j2].idx == entry.idx)
                continue;
              if (interval_overlap(track[j2].top, track[j2].bottom, entry.top, entry.bottom)) {
                if (collider) {
                  return;
                } else {
                  collider = staff.notes[track[j2].idx];
                }
              }
            }
            if (collider) {
              return;
            }
            if (note.stem_dir < 0) {
              note.slot_shift = -CONFIG.NOTE_WIDTH;
              note.modifier_shift = -CONFIG.NOTE_WIDTH;
            } else {
              note.modifier_shift = -CONFIG.NOTE_WIDTH;
            }
          };
          let staff_idx = j;
          let note_idx = k;
          let note = staff.notes[k];
          let slot = measure.slots[note.begin];
          try_opt_headbutt();
        }
      }
    }
  }
  function make_space_for_barlines(measures) {
    for (let i = 0; i < measures.length; i++) {
      let measure = measures[i];
      if (measure.barline == BARLINE.DOUBLE) {
        measure.pad.right += 4;
      } else if (measure.barline == BARLINE.END) {
        measure.pad.right += 8;
      } else if (measure.barline == BARLINE.REPEAT_END) {
        measure.pad.right += 12;
      } else if (measure.barline == BARLINE.REPEAT_BEGIN) {
        measures[i + 1].pad.left += 12;
      } else if (measure.barline == BARLINE.REPEAT_END_BEGIN) {
        measure.pad.right += 12;
        measures[i + 1].pad.left += 12;
      }
    }
  }
  function plan_beams(measure, staff_idx) {
    let staff = measure.staves[staff_idx];
    let beams = staff.beams;
    let notes = staff.notes;
    let slots = measure.slots;
    for (let beam of beams) {
      let notes_spanned = [];
      for (let i = 0; i < beam.length; i++) {
        notes_spanned.push(notes[beam[i]]);
      }
      if (!notes_spanned.length) {
        continue;
      }
      let stem_dir = notes_spanned[0].stem_dir;
      let pts = notes_spanned.map((n) => {
        let stem_length = n.stem_len;
        let x = slot_pos(measure, n.begin) + CONFIG.NOTE_WIDTH * (Number(n.stem_dir < 0) * slots[n.begin].mid_note);
        return {x, y: on_staff(2 * stem_dir * stem_length + n.staff_pos)};
      });
      let [m, b] = least_sq_regress(pts);
      if (Math.abs(m) > CONFIG.BEAM_MAX_SLOPE) {
        m = Math.sign(m) * CONFIG.BEAM_MAX_SLOPE;
        let anchor;
        if (stem_dir < 0) {
          anchor = pts.reduce((acc, a) => a.y <= acc.y ? a : acc, {x: 0, y: Infinity});
        } else {
          anchor = pts.reduce((acc, a) => a.y >= acc.y ? a : acc, {x: 0, y: -Infinity});
        }
        b = anchor.y - m * anchor.x;
      }
      for (let i = 0; i < notes_spanned.length; i++) {
        let d = pts[i].x * m + b - on_staff(notes_spanned[i].staff_pos);
        if (Math.sign(d) != notes_spanned[i].stem_dir) {
          b -= d;
          d = pts[i].x * m + b - on_staff(notes_spanned[i].staff_pos);
        }
        if (Math.abs(d) < CONFIG.LINE_HEIGHT * 1.5) {
          b += notes_spanned[i].stem_dir * CONFIG.LINE_HEIGHT * 1.5;
        }
      }
      for (let i = 0; i < notes_spanned.length; i++) {
        let d = pts[i].x * m + b - on_staff(notes_spanned[i].staff_pos);
        notes_spanned[i].stem_len = Math.abs(d) / CONFIG.LINE_HEIGHT;
      }
      beam.m = m;
      beam.b = b;
    }
  }
  function plan_articulations(measure, staff_idx) {
    let staff = measure.staves[staff_idx];
    for (let k = 0; k < staff.notes.length; k++) {
      let note = staff.notes[k];
      if (note.articulation && note.articulation != ARTICULATION.ARPEGGIATED) {
        let head_note = note;
        let tail_note = note;
        while (head_note.prev_in_chord != null) {
          head_note = staff.notes[head_note.prev_in_chord];
        }
        while (tail_note.next_in_chord != null) {
          tail_note = staff.notes[tail_note.next_in_chord];
        }
        let lh = head_note.staff_pos;
        let lt = tail_note.staff_pos;
        let ya = (lh % 2 ? lh : lh - note.stem_dir) - note.stem_dir * 2;
        let line_b = Math.round(lt + note.stem_len * note.stem_dir * 2);
        let yb = (line_b % 2 ? line_b : line_b + note.stem_dir) + note.stem_dir * 2;
        let xa = 0;
        let xb = 1;
        let x, y;
        if (staff.voices <= 1) {
          if (note.articulation == ARTICULATION.TRILL) {
            [x, y] = note.stem_dir < 0 ? [xb, yb] : [xa, ya];
          } else {
            [x, y] = [xa, ya];
          }
        } else if (note.voice % 2) {
          if (note.stem_dir < 0) {
            [x, y] = [xa, ya];
          } else {
            [x, y] = [xb, yb];
          }
        } else {
          if (note.stem_dir < 0) {
            [x, y] = [xb, yb];
          } else {
            [x, y] = [xa, ya];
          }
        }
        note.articulation_pos = [x, y];
      }
    }
  }
  function compile_score(score) {
    let score_ = score;
    score_.indent = 0;
    let instr_set = new Set();
    for (let i = 0; i < score.instruments.length; i++) {
      for (let j = 0; j < score.instruments[i].names.length; j++) {
        instr_set.add(score.instruments[i].names[j]);
      }
    }
    let instrs = Array.from(instr_set);
    if (instrs.length > 1 || CONFIG.SHOW_SOLO_INSTRUMENT) {
      let w = 0;
      for (let i = 0; i < instrs.length; i++) {
        w = Math.max(w, get_text_width(instrs[i], FONT.DUPLEX, -2));
      }
      w *= CONFIG.INSTRUMENT_TEXT_SIZE / FONT_INHERENT_HEIGHT;
      score_.indent = w + CONFIG.INSTRUMENT_PAD_RIGHT;
    }
    score_.first_col_measure_indices = [];
    score_.slurred_ids = {};
    for (let i = 0; i < score_.slurs.length; i++) {
      score_.slurred_ids[score_.slurs[i].left] = true;
      score_.slurred_ids[score_.slurs[i].right] = true;
    }
    for (let i = 0; i < score_.measures.length; i++) {
      let measure = score_.measures[i];
      for (let j = 0; j < measure.staves.length; j++) {
        let staff = measure.staves[j];
        staff.flags = {need_keysig: null, need_timesig: false, need_clef: false, need_cue: false, need_lyric: false};
        calc_staff_flags(score_, i, j);
      }
      compile_measure(measure);
    }
    make_space_for_barlines(score_.measures);
    plan_measures(score_);
    return score_;
  }
  function least_sq_regress(pts) {
    let sum_x = 0;
    let sum_y = 0;
    let sum_xsq = 0;
    let sum_xy = 0;
    let n = pts.length;
    for (let p of pts) {
      sum_x += p.x;
      sum_y += p.y;
      sum_xsq += p.x ** 2;
      sum_xy += p.x * p.y;
    }
    let denom = n * sum_xsq - sum_x ** 2;
    if (denom == 0) {
      denom = 1e-4;
    }
    let m = (n * sum_xy - sum_x * sum_y) / denom;
    let b = (sum_y - m * sum_x) / n;
    return [m, b];
  }
  function interval_overlap(x1, x2, y1, y2) {
    return x1 < y2 && y1 < x2;
  }
  function pack_add(pack, idx, layer, top, bottom, exemption) {
    if (!exemption) {
      exemption = (_a, _b) => false;
    }
    if (!pack.intervals[layer]) {
      pack.intervals[layer] = [];
    }
    let track = pack.intervals[layer];
    for (let i = 0; i < 99; i++) {
      let ok = true;
      for (let j = 0; j < track.length; j++) {
        if (track[j].x != i) {
          continue;
        }
        if (interval_overlap(track[j].top, track[j].bottom, top, bottom) && !(track[j].top == top && track[j].bottom == bottom && exemption(idx, j))) {
          ok = false;
          break;
        }
      }
      if (ok) {
        track.push({top, bottom, x: i, idx});
        return;
      }
    }
  }
  function pack_width(pack) {
    let x = 0;
    for (let i = 0; i < pack.intervals.length; i++) {
      if (!pack.intervals[i])
        continue;
      for (let j = 0; j < pack.intervals[i].length; j++) {
        x = Math.max(pack.intervals[i][j].x + 1, x);
      }
    }
    return x;
  }
  function make_measure_slots(measure) {
    let slots = new Array(Math.max(1, measure.duration)).fill(null).map((x) => ({
      mid_note: 0,
      left_grace: 0,
      left_squiggle: 0,
      left_deco: 0,
      right_deco: 0,
      left_note: 0,
      right_note: 0,
      right_spacing: 0,
      acc_pack: {intervals: new Array(measure.staves.length).fill(null).map((_) => [])},
      mid_pack: {intervals: new Array(measure.staves.length).fill(null).map((_) => [])}
    }));
    for (let k = 0; k < measure.staves.length; k++) {
      let merger = function(a, b) {
        return notes[a].duration < NOTE_LENGTH.HALF && notes[b].duration < NOTE_LENGTH.HALF || NOTE_LENGTH.HALF <= notes[a].duration && notes[a].duration < NOTE_LENGTH.WHOLE && NOTE_LENGTH.HALF <= notes[b].duration && notes[b].duration < NOTE_LENGTH.WHOLE;
      };
      let notes = measure.staves[k].notes;
      let rests = measure.staves[k].rests;
      for (let i = 0; i < notes.length; i++) {
        let slot = slots[notes[i].begin];
        if (notes[i].stem_dir < 0) {
          if (notes[i].twisted) {
            slot.right_note = 1;
          } else {
            slot.mid_note = 1;
            pack_add(slot.mid_pack, i, k, notes[i].staff_pos - 1, notes[i].staff_pos + 1, CONFIG.HEADBUTT_MERGE && merger);
          }
        } else {
          if (notes[i].twisted) {
            slot.left_note = 1;
          } else {
            slot.mid_note = 1;
            pack_add(slot.mid_pack, i, k, notes[i].staff_pos - 1, notes[i].staff_pos + 1, CONFIG.HEADBUTT_MERGE && merger);
          }
        }
        if (notes[i].modifier) {
          slot.right_deco = Math.max(1, slot.right_deco);
        }
        if (notes.length > 1) {
          let v = CONFIG.DURATION_BASED_SPACING * notes[i].duration;
          if (!slot.right_spacing) {
            slot.right_spacing = v;
          } else {
            slot.right_spacing = Math.min(v, slot.right_spacing);
          }
        }
        if (notes[i].flag_count && !notes[i].beamed && notes[i].stem_dir < 0 && !notes[i].twisted) {
          slot.right_deco = Math.max(1, slot.right_deco);
        }
        if (notes[i].articulation == ARTICULATION.ARPEGGIATED) {
          slot.left_squiggle = CONFIG.SQUIGGLE_WIDTH_MUL;
        }
        if (notes[i].accidental !== null) {
          pack_add(slot.acc_pack, i, k, notes[i].staff_pos - 3, notes[i].staff_pos + 2);
        }
      }
      for (let i = 0; i < rests.length; i++) {
        let slot = slots[rests[i].begin];
        slot.mid_note = Math.max(slot.mid_note, CONFIG.REST_WIDTH_MUL);
      }
      for (let i = 0; i < measure.staves[k].grace.length; i++) {
        if (measure.staves[k].grace[i]) {
          let slot = slots[i];
          let d = [0, 0, 0];
          slot_pos(measure.staves[k].grace[i], measure.staves[k].grace[i].duration, d);
          slot.left_grace = d[0] * CONFIG.GRACE_WIDTH_MUL + d[1] * measure.staves[k].grace[i].pad.inter / CONFIG.NOTE_WIDTH;
        }
      }
      if (!notes.length) {
        slots[0].mid_note = Math.max(slots[0].mid_note, CONFIG.REST_WIDTH_MUL);
      }
    }
    for (let i = 0; i < slots.length; i++) {
      slots[i].left_deco = pack_width(slots[i].acc_pack) * CONFIG.ACCIDENTAL_WIDTH_MUL;
    }
    for (let i = 0; i < slots.length; i++) {
      slots[i].mid_note = Math.max(slots[i].mid_note, pack_width(slots[i].mid_pack) * 1);
    }
    let lyric_slots = new Array(slots.length).fill(false);
    for (let k = 0; k < measure.staves.length; k++) {
      let notes = measure.staves[k].notes;
      for (let i = 0; i < notes.length; i++) {
        if (notes[i].lyric) {
          lyric_slots[notes[i].begin] = true;
        }
      }
    }
    for (let k = 0; k < measure.staves.length; k++) {
      let notes = measure.staves[k].notes;
      for (let i = 0; i < notes.length; i++) {
        if (notes[i].lyric) {
          let slot = slots[notes[i].begin];
          let w = get_text_width(notes[i].lyric) * CONFIG.LYRIC_SCALE;
          let w0 = (slot.mid_note + slot.right_note + slot.right_deco + slot.right_spacing) * CONFIG.NOTE_WIDTH;
          let n = notes[i].begin + 1;
          while (!lyric_slots[n] && n < lyric_slots.length) {
            let ww = slots[n].left_deco + slots[n].left_grace + slots[n].left_note + slots[n].left_squiggle + slots[n].mid_note + slots[n].right_deco + slots[n].right_note + slots[n].right_spacing;
            if (ww) {
              w0 += CONFIG.INTER_NOTE_WIDTH;
            }
            w0 += ww * CONFIG.NOTE_WIDTH;
            n++;
          }
          if (w0 < w) {
            let due = (w - w0) / CONFIG.NOTE_WIDTH;
            let spread = due / (n - notes[i].begin);
            for (let m = notes[i].begin; m < n; m++) {
              slots[m].right_spacing += spread;
            }
          }
        }
      }
    }
    measure.slots = slots;
  }
  function slot_pos(measure, begin, out) {
    let slots = measure.slots;
    let r = 0;
    let s = measure.pad.left;
    let t = 0;
    if (measure.staves.some((x) => x.flags.need_clef)) {
      s += CONFIG.CLEF_WIDTH_MUL * CONFIG.NOTE_WIDTH;
      t++;
      s += measure.pad.inter;
    }
    if (measure.staves.some((x) => x.flags.need_timesig)) {
      s += CONFIG.TIMESIG_WIDTH_MUL * CONFIG.NOTE_WIDTH;
      t++;
      s += measure.pad.inter;
    }
    if (measure.staves.some((x) => x.flags.need_keysig)) {
      let num_acc = 0;
      for (let i = 0; i < measure.staves.length; i++) {
        num_acc = Math.max(num_acc, measure.staves[i].key_signature[1]);
      }
      s += num_acc * CONFIG.KEYSIG_WIDTH_MUL * CONFIG.NOTE_WIDTH;
      t++;
      s += measure.pad.inter;
    }
    for (let i = 0; i < begin; i++) {
      if (slots[i].left_grace) {
        s += measure.pad.inter * 2;
        r += slots[i].left_grace;
        t += 2;
      }
      let w_real = slots[i].left_note + slots[i].right_note + slots[i].mid_note + slots[i].left_deco + slots[i].right_deco + slots[i].left_squiggle;
      let w = w_real + slots[i].right_spacing;
      r += w;
      if (w_real) {
        s += measure.pad.inter;
        t++;
      }
    }
    if (slots[begin]) {
      if (slots[begin].left_grace) {
        s += measure.pad.inter * 2;
        r += slots[begin].left_grace;
        t += 2;
      }
      r += slots[begin].left_note + slots[begin].left_deco + slots[begin].left_squiggle;
    } else if (begin >= slots.length) {
      s += measure.pad.right - measure.pad.inter;
      t--;
    } else if (begin < 0) {
      s -= measure.pad.left;
    }
    if (out) {
      out[0] = r;
      out[1] = t;
      out[2] = s;
    }
    return r * CONFIG.NOTE_WIDTH + s;
  }
  function on_staff(line) {
    return line * CONFIG.LINE_HEIGHT / 2;
  }
  function estimate_staff_ybound(staff, slurred_ids) {
    let ymin = 0;
    let ymax = (CONFIG.LINES_PER_STAFF - 1) * 2;
    for (let i = 0; i < staff.notes.length; i++) {
      let note = staff.notes[i];
      let line = note.staff_pos;
      let y0 = line;
      let y1 = y0;
      if (note.stem_dir < 0) {
        y0 -= note.stem_len * 2;
      } else {
        y1 += note.stem_len * 2;
      }
      if (note.tuplet) {
        if (note.stem_dir < 0) {
          y0 -= 3;
        } else {
          y1 += 3;
        }
      }
      if (note.articulation_pos) {
        y0 = Math.min(y0, note.articulation_pos[1] - 2);
        y1 = Math.max(y1, note.articulation_pos[1] + 2);
      }
      if (note.id && slurred_ids[note.id]) {
        y0 -= 2;
        y1 += 2;
      }
      y0 -= 1;
      y1 += 1;
      ymin = Math.min(ymin, y0);
      ymax = Math.max(ymax, y1);
    }
    for (let i = 0; i < staff.rests.length; i++) {
      let rest = staff.rests[i];
      ymin = Math.min(ymin, rest.staff_pos - 2);
      ymax = Math.max(ymax, rest.staff_pos + 2);
    }
    let ya = on_staff(ymin);
    let yb = on_staff(ymax);
    let {need_cue, need_lyric} = staff.flags;
    let yc = need_cue ? CONFIG.CUE_HEIGHT : 0;
    let yd = need_lyric ? FONT_INHERENT_HEIGHT * CONFIG.LYRIC_SCALE + CONFIG.LYRIC_SPACING * 2 : 0;
    return [ya, yb + yc + yd];
  }
  function calc_num_flags(length, has_modifier2) {
    return Math.max(0, ~~(4 - Math.log2(!has_modifier2 ? length : length / NOTE_LENGTH_MODIFIER2)));
  }
  function compile_rests(staff) {
    let voice_median_staff_pos = get_median_staff_pos(staff.notes);
    let notes = staff.notes;
    let rests = staff.rests;
    function rest_staff_pos(rest) {
      let y;
      if (staff.voices <= 1) {
        y = 4;
      } else if (staff.voices == 2) {
        if (voice_median_staff_pos[rest.voice] == void 0) {
          if (rest.voice) {
            y = 8;
          } else {
            y = 0;
          }
        } else {
          let other_voice = (rest.voice + 1) % staff.voices;
          if (other_voice < rest.voice) {
            y = voice_median_staff_pos[rest.voice] + 4;
            for (let i = 0; i < notes.length; i++) {
              if (notes[i].voice != other_voice) {
                continue;
              }
              if (notes[i].begin == rest.begin) {
                y = Math.max(y, 5 + notes[i].staff_pos);
              }
            }
            y = ~~(y / 2) * 2;
          } else {
            y = voice_median_staff_pos[rest.voice] - 4;
            for (let i = 0; i < notes.length; i++) {
              if (notes[i].voice != other_voice) {
                continue;
              }
              if (notes[i].begin == rest.begin) {
                y = Math.min(y, -5 + notes[i].staff_pos);
              }
            }
            y = ~~(y / 2) * 2;
          }
        }
      } else {
        y = voice_median_staff_pos[rest.voice];
      }
      return y;
    }
    for (let i = 0; i < rests.length; i++) {
      rests[i].staff_pos = rest_staff_pos(rests[i]);
    }
  }
  function draw_staff(measure, staff_idx, no_staff_lines = false) {
    let staff = measure.staves[staff_idx];
    let notes = staff.notes;
    let rests = staff.rests;
    let result = [];
    let slots = measure.slots;
    let ledgers = new Array(measure.duration).fill(null).map((_) => new Set());
    function put_ledgers_as_necessary(begin, line) {
      if (line < 0) {
        for (let i = Math.floor((line + 1) / 2) * 2; i < 0; i += 2) {
          ledgers[begin].add(i);
        }
      } else if (line > 9) {
        for (let i = 10; i < ~~(line / 2) * 2 + 1; i += 2) {
          ledgers[begin].add(i);
        }
      }
    }
    function draw_ledgers() {
      for (let i = 0; i < ledgers.length; i++) {
        let slot = slots[i];
        let slot_x = slot_pos(measure, i);
        for (let line of ledgers[i]) {
          result.push({
            tag: "line",
            type: "ledger",
            x: slot_x - slot.left_note * CONFIG.NOTE_WIDTH - CONFIG.LEDGER_WIDTH_MUL / 2 * CONFIG.NOTE_WIDTH,
            y: on_staff(line),
            w: CONFIG.NOTE_WIDTH * (CONFIG.LEDGER_WIDTH_MUL + slot.left_note + slot.mid_note + slot.right_note),
            h: 0
          });
        }
      }
      ;
    }
    function note_head_center_x(note, slot_x) {
      let slot = slots[note.begin];
      let x = slot_x + CONFIG.NOTE_WIDTH * (Number(note.stem_dir < 0) * slot.mid_note);
      if (note.stem_dir < 0) {
        if (note.twisted) {
          x += CONFIG.NOTE_WIDTH / 2;
        } else {
          x -= CONFIG.NOTE_WIDTH / 2;
        }
      } else {
        if (note.twisted) {
          x -= CONFIG.NOTE_WIDTH / 2;
        } else {
          x += CONFIG.NOTE_WIDTH / 2;
        }
      }
      return x;
    }
    function draw_note(note, slot_x, line) {
      let slot = slots[note.begin];
      let head_note = note;
      let tail_note = note;
      let modifier_x = slot_x + CONFIG.NOTE_WIDTH * (slot.mid_note + slot.right_note + 0.5);
      slot_x += note.slot_shift;
      modifier_x += note.modifier_shift;
      while (head_note.prev_in_chord != null) {
        head_note = notes[head_note.prev_in_chord];
      }
      while (tail_note.next_in_chord != null) {
        tail_note = notes[tail_note.next_in_chord];
      }
      if (note.id) {
        let x = slot_x + CONFIG.NOTE_WIDTH * (Number(note.stem_dir < 0) * slot.mid_note);
        let reg = {
          note,
          staff_idx,
          measure,
          row: null,
          col: null,
          chord_head_x: note_head_center_x(head_note, slot_x),
          chord_head_y: on_staff(head_note.staff_pos),
          head_x: note_head_center_x(note, slot_x),
          tail_x: x,
          head_y: on_staff(note.staff_pos),
          tail_y: null
        };
        let n = note;
        while (n.next_in_chord !== null) {
          n = staff.notes[n.next_in_chord];
        }
        let y1 = on_staff(n.staff_pos);
        y1 += n.stem_len * n.stem_dir * CONFIG.LINE_HEIGHT;
        reg.tail_y = y1;
        reg.chord_head_x += staff.coords.x;
        reg.chord_head_y += staff.coords.y;
        reg.head_x += staff.coords.x;
        reg.head_y += staff.coords.y;
        reg.tail_x += staff.coords.x;
        reg.tail_y += staff.coords.y;
        reg.row = staff.coords.row;
        reg.col = staff.coords.col;
        id_registry[note.id] = reg;
      }
      if (note.modifier) {
        result.push({
          tag: "dot",
          type: "modifier",
          x: modifier_x,
          y: on_staff(line % 2 ? line : line + (note.voice % 2 ? 1 : -1)),
          w: 0,
          h: 0
        });
      }
      if (note.articulation) {
        if (note.articulation != ARTICULATION.ARPEGGIATED) {
          let [xx, yy] = note.articulation_pos;
          let x = xx ? slot_x + CONFIG.NOTE_WIDTH * (Number(note.stem_dir < 0) * slot.mid_note) : note_head_center_x(note, slot_x);
          let y = on_staff(yy);
          result.push({
            tag: "articulation",
            type: note.articulation,
            dir: (xx ? -1 : 1) * note.stem_dir,
            x,
            y,
            w: CONFIG.NOTE_WIDTH,
            h: CONFIG.LINE_HEIGHT
          });
        } else {
          let lh = head_note.staff_pos;
          let lt = tail_note.staff_pos;
          let ya = on_staff(lh - note.stem_dir);
          let line_b = Math.round(lt + note.stem_dir);
          let yb = on_staff(line_b);
          let y0 = Math.min(ya, yb);
          let y1 = Math.max(ya, yb);
          result.push({
            tag: "squiggle",
            type: "arpeggiated_chord",
            x: slot_x - (slot.left_deco + slot.left_note + slot.left_squiggle / 2) * CONFIG.NOTE_WIDTH,
            y: y0,
            w: 0,
            h: y1 - y0
          });
        }
      }
      result.push({
        tag: "note_head",
        x: slot_x + CONFIG.NOTE_WIDTH * (Number(note.stem_dir < 0) * slot.mid_note),
        y: on_staff(line),
        w: CONFIG.NOTE_WIDTH,
        h: CONFIG.LINE_HEIGHT,
        twisted: note.twisted,
        stem_dir: note.stem_dir,
        duration: note.duration
      });
      if (!note.beamed && note.stem_len != 0 && note.duration < NOTE_LENGTH.WHOLE) {
        let y0 = note.stem_len * note.stem_dir;
        let y1 = 0;
        let y = y0;
        let h = y1 - y;
        result.push({
          tag: "line",
          type: "note_stem",
          x: slot_x + CONFIG.NOTE_WIDTH * (Number(note.stem_dir < 0) * slot.mid_note),
          y: on_staff(line + y * 2),
          w: 0,
          h: CONFIG.LINE_HEIGHT * h
        });
      }
      if (!note.beamed && note.flag_count) {
        let flagcnt = note.flag_count;
        for (let i = 0; i < flagcnt; i++) {
          let y = (note.stem_len - i * CONFIG.FLAG_SPACING) * note.stem_dir * 2;
          result.push({
            tag: "flag",
            x: slot_x + CONFIG.NOTE_WIDTH * (Number(note.stem_dir < 0) * slot.mid_note),
            y: on_staff(line + y),
            w: CONFIG.NOTE_WIDTH,
            h: CONFIG.LINE_HEIGHT,
            stem_dir: note.stem_dir,
            is_last: i == flagcnt - 1
          });
        }
      }
    }
    function draw_accidental(acc, slot_x, line) {
      result.push({
        tag: "accidental",
        type: acc,
        x: slot_x,
        y: on_staff(line),
        w: CONFIG.NOTE_WIDTH,
        h: CONFIG.LINE_HEIGHT
      });
    }
    function draw_rest(rest, slot_x) {
      let dur = rest.duration;
      if (rest.tuplet) {
        dur = rest.tuplet.display_duration;
      }
      let y = rest.staff_pos;
      if (CONFIG.WHOLE_HALF_REST_LEDGERS) {
        if (dur == NOTE_LENGTH.WHOLE) {
          let slot = slots[rest.begin];
          let line2 = y - 2;
          result.push({
            tag: "line",
            type: "ledger",
            x: slot_x - slot.left_note * CONFIG.NOTE_WIDTH - 0.5 * CONFIG.NOTE_WIDTH,
            y: on_staff(line2),
            w: CONFIG.NOTE_WIDTH * (1 + slot.left_note + slot.mid_note + slot.right_note),
            h: 0
          });
        } else if (dur == NOTE_LENGTH.HALF) {
          let slot = slots[rest.begin];
          let line2 = y;
          result.push({
            tag: "line",
            type: "ledger",
            x: slot_x - slot.left_note * CONFIG.NOTE_WIDTH - 0.5 * CONFIG.NOTE_WIDTH,
            y: on_staff(line2),
            w: CONFIG.NOTE_WIDTH * (1 + slot.left_note + slot.mid_note + slot.right_note),
            h: 0
          });
        }
      } else if (dur == NOTE_LENGTH.WHOLE || dur == NOTE_LENGTH.HALF) {
        y = Math.min(Math.max(y, 2), 8);
      }
      let line = on_staff(y);
      result.push({
        tag: "rest",
        x: slot_x + CONFIG.NOTE_WIDTH / 2,
        y: line,
        w: CONFIG.NOTE_WIDTH,
        h: CONFIG.LINE_HEIGHT * (CONFIG.LINES_PER_STAFF - 1),
        duration: dur
      });
    }
    function draw_beam(notes_spanned) {
      if (!notes_spanned.length) {
        return;
      }
      let beat_length = ~~(NOTE_LENGTH.WHOLE / staff.time_signature[1]);
      let stem_dir = notes_spanned[0].stem_dir;
      let flagcnts = [];
      for (let i = 0; i < notes_spanned.length; i++) {
        flagcnts.push(notes_spanned[i].flag_count);
      }
      let pts = notes_spanned.map((n) => {
        let stem_length = n.stem_len;
        let x = slot_pos(measure, n.begin) + CONFIG.NOTE_WIDTH * (Number(n.stem_dir < 0) * slots[n.begin].mid_note) + n.slot_shift;
        return {x, y: on_staff(2 * stem_dir * stem_length + n.staff_pos)};
      });
      let lengths = notes_spanned.map((x) => x.flag_count);
      let bins = new Array(pts.length * 2 - 2).fill(0);
      for (let i = 0; i < pts.length; i++) {
        let flagcnt = flagcnts[i];
        let last_len = lengths[i - 1];
        let next_len = lengths[i + 1];
        if (i == 0) {
          bins[i * 2] = flagcnt;
        } else if (i == pts.length - 1) {
          bins[i * 2 - 1] = flagcnt;
        } else {
          if (Math.abs(lengths[i] - last_len) <= Math.abs(lengths[i] - next_len)) {
            bins[i * 2 - 1] = flagcnt;
          } else {
            bins[i * 2] = flagcnt;
          }
          if (CONFIG.BEAM_POLICY == 3) {
            let same_beat_l = ~~(notes_spanned[i - 1].begin / beat_length) == ~~(notes_spanned[i].begin / beat_length);
            let same_beat_r = ~~(notes_spanned[i].begin / beat_length) == ~~(notes_spanned[i + 1].begin / beat_length);
            if (!same_beat_l && i != 1) {
              bins[i * 2 - 1] = 1;
            }
            if (!same_beat_r && i != pts.length - 2) {
              bins[i * 2] = 1;
            }
          }
        }
      }
      for (let i = 0; i < bins.length; i++) {
        if (bins[i] == 0) {
          let [i0, i1] = [~~(i / 2), ~~(i / 2) + 1];
          bins[i] = Math.min(lengths[i0], lengths[i1]);
        }
      }
      let runs = [[1, 0, bins.length]];
      let on = -1;
      for (let i = 2; i <= 4; i++) {
        for (let j = 0; j < bins.length; j++) {
          if (bins[j] >= i && on < 0) {
            on = j;
          }
          if (bins[j] < i && on >= 0) {
            runs.push([i, on, j]);
            on = -1;
          }
        }
        if (on >= 0) {
          runs.push([i, on, bins.length]);
          on = -1;
        }
      }
      for (let i = 0; i < runs.length; i++) {
        let [t0, t1] = [runs[i][1] / 2, runs[i][2] / 2];
        let [i0, i1] = [~~t0, ~~t1];
        let [f0, f1] = [t0 - i0, t1 - i1];
        if (f0 > 0) {
          f0 += 0.2;
        }
        if (f1 > 0) {
          f1 -= 0.2;
        }
        let [j0, j1] = [
          Math.min(i0 + 1, pts.length - 1),
          Math.min(i1 + 1, pts.length - 1)
        ];
        let p0 = [pts[i0].x, pts[i0].y];
        let p1 = [pts[j0].x, pts[j0].y];
        let q0 = [pts[i1].x, pts[i1].y];
        let q1 = [pts[j1].x, pts[j1].y];
        let p = [p0[0] * (1 - f0) + p1[0] * f0, p0[1] * (1 - f0) + p1[1] * f0];
        let q = [q0[0] * (1 - f1) + q1[0] * f1, q0[1] * (1 - f1) + q1[1] * f1];
        result.push({
          tag: "beam",
          x: p[0],
          y: p[1] - (runs[i][0] - 1) * stem_dir * CONFIG.LINE_HEIGHT * CONFIG.FLAG_SPACING,
          w: q[0] - p[0],
          h: q[1] - p[1],
          stem_dir
        });
      }
      for (let i = 0; i < bins.length; i++) {
        let [i0, i1] = [~~(i / 2), ~~(i / 2) + 1];
        let [x0, v0, y0] = [pts[i0].x, pts[i0].y, pts[i0].y];
        let [x1, v1, y1] = [pts[i1].x, pts[i1].y, pts[i1].y];
        if (i % 2 == 0) {
          let u0 = v0 - notes_spanned[i0].stem_len * notes_spanned[i0].stem_dir * CONFIG.LINE_HEIGHT;
          result.push({
            tag: "line",
            type: "note_stem",
            x: x0,
            y: y0,
            w: 0,
            h: u0 - y0
          });
        } else if (i == bins.length - 1) {
          let u1 = v1 - notes_spanned[i1].stem_len * notes_spanned[i1].stem_dir * CONFIG.LINE_HEIGHT;
          result.push({
            tag: "line",
            type: "note_stem",
            x: x1,
            y: y1,
            w: 0,
            h: u1 - y1
          });
        }
      }
    }
    function draw_clef() {
      result.push({
        tag: "clef",
        type: staff.clef,
        x: measure.pad.inter + CONFIG.NOTE_WIDTH * CONFIG.CLEF_WIDTH_MUL / 2,
        y: on_staff({
          [CLEF.TREBLE]: 6,
          [CLEF.BASS]: 2,
          [CLEF.ALTO]: 4,
          [CLEF.BARITONE]: 0,
          [CLEF.SOPRANO]: 8,
          [CLEF.TENOR]: 2,
          [CLEF.MEZZO_SOPRANO]: 6
        }[staff.clef]),
        w: CONFIG.CLEF_WIDTH_MUL * CONFIG.NOTE_WIDTH,
        h: CONFIG.LINE_HEIGHT * (CONFIG.LINES_PER_STAFF - 1)
      });
    }
    function draw_key_signature() {
      let {accidental, count} = staff.flags.need_keysig;
      let is_cancel = false;
      if (accidental == ~ACCIDENTAL.SHARP || accidental == ~ACCIDENTAL.FLAT) {
        is_cancel = true;
        accidental = ~accidental;
      }
      let targ_notes = Array.from(ORDER_OF_ACCIDENTALS[accidental].slice(0, count));
      let octs = accidental == ACCIDENTAL.SHARP ? [6, 6, 6, 6, 5, 6, 5] : [5, 6, 5, 6, 5, 6, 5];
      let x = measure.pad.inter + Number(staff.flags.need_clef) * (CONFIG.NOTE_WIDTH * CONFIG.CLEF_WIDTH_MUL + measure.pad.inter);
      for (let i = 0; i < targ_notes.length; i++) {
        let n;
        if (staff.clef == CLEF.TREBLE) {
          n = targ_notes[i] + "_" + octs[i];
        } else if (staff.clef == CLEF.BASS) {
          n = targ_notes[i] + "_" + (octs[i] - 2);
        } else if (staff.clef == CLEF.SOPRANO) {
          n = targ_notes[i] + "_" + (octs[i] - 1);
        } else if (staff.clef == CLEF.ALTO) {
          n = targ_notes[i] + "_" + (octs[i] - 1);
        } else if (staff.clef == CLEF.TENOR) {
          n = targ_notes[i] + "_" + (octs[i] - 1);
        } else if (staff.clef == CLEF.BARITONE) {
          n = targ_notes[i] + "_" + (octs[i] - 1);
        } else if (staff.clef == CLEF.MEZZO_SOPRANO) {
          n = targ_notes[i] + "_" + (octs[i] - 1);
        } else {
          n = targ_notes[i] + "_" + octs[i];
        }
        let line = note_name_to_staff_pos(n, staff.clef);
        result.push({
          tag: "accidental",
          type: is_cancel ? ACCIDENTAL.NATURAL : accidental,
          x: x + i * CONFIG.NOTE_WIDTH * CONFIG.KEYSIG_WIDTH_MUL + 3,
          y: on_staff(line),
          w: CONFIG.NOTE_WIDTH,
          h: CONFIG.LINE_HEIGHT
        });
      }
    }
    function draw_time_signature() {
      let x = measure.pad.inter + Number(staff.flags.need_clef) * (CONFIG.NOTE_WIDTH * CONFIG.CLEF_WIDTH_MUL + measure.pad.inter);
      if (staff.flags.need_keysig) {
        x += staff.flags.need_keysig.count * CONFIG.NOTE_WIDTH * CONFIG.KEYSIG_WIDTH_MUL + measure.pad.inter;
      }
      x += CONFIG.TIMESIG_WIDTH_MUL * CONFIG.NOTE_WIDTH / 2;
      function draw_digit(d, x2, line) {
        result.push({
          tag: "timesig_digit",
          value: d,
          x: x2,
          y: on_staff(line),
          w: CONFIG.TIMESIG_WIDTH_MUL * CONFIG.NOTE_WIDTH,
          h: CONFIG.LINE_HEIGHT * (CONFIG.LINES_PER_STAFF - 1) / 2
        });
      }
      function draw_num(n, x2, line) {
        let digits = Array.from(n.toString()).map(Number);
        let u = CONFIG.TIMESIG_WIDTH_MUL * CONFIG.NOTE_WIDTH * 0.5;
        for (let i = 0; i < digits.length; i++) {
          draw_digit(digits[i], x2 - digits.length * u / 2 + i * u + u / 2, line);
        }
      }
      if (CONFIG.TIMESIG_COMMON_TIME_C && (staff.time_signature[0] == 2 && staff.time_signature[1] == 2 || staff.time_signature[0] == 4 && staff.time_signature[1] == 4)) {
        result.push({
          tag: "timesig_c",
          type: staff.time_signature[0] - 2 ? "common" : "cut",
          x,
          y: on_staff(4),
          w: CONFIG.TIMESIG_WIDTH_MUL * CONFIG.NOTE_WIDTH,
          h: CONFIG.LINE_HEIGHT * (CONFIG.LINES_PER_STAFF - 1) / 2
        });
      } else {
        draw_num(staff.time_signature[0], x, 2);
        draw_num(staff.time_signature[1], x, 6);
      }
    }
    function draw_tuplets() {
      let tuplets = {};
      function register_note_or_rest(n, is_rest) {
        if (!n.tuplet) {
          return;
        }
        let r = tuplets[n.tuplet.id];
        if (!r) {
          r = tuplets[n.tuplet.id] = {label: n.tuplet.label, stem_dir: -1, xmin: Infinity, xmax: -Infinity, ymin: Infinity, ymax: -Infinity};
        }
        let slot = slots[n.begin];
        let slot_x = slot_pos(measure, n.begin);
        if (is_rest) {
          let rest = n;
          let y0 = on_staff(rest.staff_pos);
          r.xmin = Math.min(r.xmin, slot_x);
          r.xmax = Math.max(r.xmax, slot_x + slot.mid_note * CONFIG.NOTE_WIDTH);
          r.ymin = Math.min(r.ymin, y0 - CONFIG.LINE_HEIGHT * 2);
          r.ymax = Math.max(r.ymax, y0 + CONFIG.LINE_HEIGHT * 2);
        } else {
          let note = n;
          r.stem_dir = note.stem_dir;
          let y = on_staff(note.staff_pos);
          let y0 = y + CONFIG.LINE_HEIGHT / 2;
          let y1 = y + note.stem_len * note.stem_dir * CONFIG.LINE_HEIGHT + Math.max(0, note.flag_count - 1) * CONFIG.FLAG_SPACING * note.stem_dir * CONFIG.LINE_HEIGHT;
          if (note.stem_dir < 0) {
            r.xmin = Math.min(r.xmin, slot_x - (slot.left_note - 0.5) * CONFIG.NOTE_WIDTH);
            r.xmax = Math.max(r.xmax, slot_x + slot.mid_note * CONFIG.NOTE_WIDTH);
          } else {
            r.xmin = Math.min(r.xmin, slot_x);
            r.xmax = Math.max(r.xmax, slot_x + (slot.mid_note + slot.right_note - 0.5) * CONFIG.NOTE_WIDTH);
          }
          r.ymin = Math.min(r.ymin, y0, y1);
          r.ymax = Math.max(r.ymax, y0, y1);
        }
      }
      for (let i = 0; i < staff.notes.length; i++) {
        register_note_or_rest(staff.notes[i], false);
      }
      for (let i = 0; i < staff.rests.length; i++) {
        register_note_or_rest(staff.rests[i], true);
      }
      for (let k in tuplets) {
        let {label, stem_dir, ymin, ymax, xmin, xmax} = tuplets[k];
        let y = stem_dir < 0 ? ymin : ymax;
        result.push({
          tag: "tuplet_label",
          label,
          x: xmin,
          y: y + stem_dir * CONFIG.LINE_HEIGHT * CONFIG.TUPLET_LABEL_SPACING,
          w: xmax - xmin,
          h: stem_dir * CONFIG.LINE_HEIGHT / 2
        });
      }
    }
    function draw_lyric(note, slot_x) {
      let ymax_sans_lyric;
      ymax_sans_lyric = staff.coords.local_y_max - CONFIG.LYRIC_SPACING - CONFIG.LYRIC_SCALE * FONT_INHERENT_HEIGHT;
      result.push({
        tag: "lyric",
        text: note.lyric,
        x: slot_x,
        y: ymax_sans_lyric,
        w: get_text_width(note.lyric) * CONFIG.LYRIC_SCALE,
        h: FONT_INHERENT_HEIGHT * CONFIG.LYRIC_SCALE
      });
    }
    function draw_cue(nr, slot_x) {
      let slot = slots[nr.begin];
      let ymax_sans_cue;
      ymax_sans_cue = staff.coords.local_y_max - (staff.flags.need_lyric ? CONFIG.LYRIC_SPACING * 2 + CONFIG.LYRIC_SCALE * FONT_INHERENT_HEIGHT : 0) - CONFIG.CUE_HEIGHT;
      let x = slot_x;
      if (nr.cue.position == 0) {
        x += CONFIG.NOTE_WIDTH * slot.mid_note / 2;
      } else if (nr.cue.position == -1) {
        x -= CONFIG.NOTE_WIDTH * (slot.left_note + slot.left_deco + slot.left_squiggle + slot.left_grace) + measure.pad.inter / 2;
      } else if (nr.cue.position == 1) {
        x += CONFIG.NOTE_WIDTH * (slot.mid_note + slot.right_deco + slot.right_note) + measure.pad.inter / 2;
      }
      result.push({
        tag: "cue",
        text: nr.cue.data,
        x,
        y: ymax_sans_cue - (CONFIG.CUE_TEXT_SIZE - CONFIG.CUE_HEIGHT) / 2,
        w: CONFIG.NOTE_WIDTH,
        h: CONFIG.CUE_TEXT_SIZE
      });
    }
    if (CONFIG.DEBUG_BLOCKS) {
      ;
      (function draw_dbg() {
        for (let i = 0; i < slots.length; i++) {
          let slot_x = slot_pos(measure, i);
          result.push({
            tag: "dbg",
            color: ["red", "blue", "green"][~~(Math.random() * 3)],
            x: slot_x,
            y: staff.coords.local_y_min,
            w: slots[i].mid_note * CONFIG.NOTE_WIDTH,
            h: staff.coords.local_y_max - staff.coords.local_y_min
          });
        }
      })();
    }
    if (!no_staff_lines) {
      let measure_render_width = slot_pos(measure, measure.duration);
      for (let i = 0; i < CONFIG.LINES_PER_STAFF; i++) {
        result.push({
          tag: "line",
          type: "staff_line",
          x: 0,
          y: i * CONFIG.LINE_HEIGHT,
          w: measure_render_width,
          h: 0
        });
      }
    }
    if (staff.flags.need_clef) {
      draw_clef();
    }
    if (staff.flags.need_keysig) {
      draw_key_signature();
    }
    if (staff.flags.need_timesig) {
      draw_time_signature();
    }
    for (let i = 0; i < notes.length; i++) {
      let note = notes[i];
      let line = note.staff_pos;
      let slot_x = slot_pos(measure, note.begin);
      let slot = slots[note.begin];
      put_ledgers_as_necessary(note.begin, line);
      draw_note(note, slot_x, line);
      if (note.lyric) {
        draw_lyric(note, slot_x);
      }
      if (note.cue) {
        draw_cue(note, slot_x);
      }
      if (note.accidental !== null) {
        let x = slot.acc_pack.intervals[staff_idx].find((a) => a.idx == i).x;
        draw_accidental(note.accidental, slot_x - CONFIG.NOTE_WIDTH * slot.left_note - CONFIG.NOTE_WIDTH * CONFIG.ACCIDENTAL_WIDTH_MUL * 0.6 - CONFIG.NOTE_WIDTH * CONFIG.ACCIDENTAL_WIDTH_MUL * x * 0.8, line);
      }
    }
    let beams = staff.beams;
    for (let b of beams) {
      let notes_spanned = [];
      for (let i = 0; i < b.length; i++) {
        notes_spanned.push(notes[b[i]]);
      }
      if (!notes_spanned.length) {
        continue;
      }
      draw_beam(notes_spanned);
    }
    for (let i = 0; i < rests.length; i++) {
      let rest = rests[i];
      let slot_x = slot_pos(measure, rest.begin);
      draw_rest(rest, slot_x);
      if (rest.cue) {
        draw_cue(rest, slot_x);
      }
    }
    draw_tuplets();
    draw_ledgers();
    translate_elements(result, staff.coords.x, staff.coords.y);
    for (let i = 0; i < staff.grace.length; i++) {
      if (!staff.grace[i]) {
        continue;
      }
      let nw0 = CONFIG.NOTE_WIDTH;
      CONFIG.NOTE_WIDTH *= CONFIG.GRACE_WIDTH_MUL;
      let ret = draw_staff(staff.grace[i], 0, true);
      CONFIG.NOTE_WIDTH = nw0;
      ret.forEach((x) => {
        x.mini = true;
        result.push(x);
      });
    }
    return result;
  }
  function translate_elements(elts, x, y) {
    for (let i = 0; i < elts.length; i++) {
      elts[i].x += x;
      elts[i].y += y;
      if (elts[i].x1) {
        elts[i].x1 += x;
      }
      if (elts[i].y1) {
        elts[i].y1 += y;
      }
    }
  }
  function plan_measures(score) {
    let measures = score.measures;
    let measure_widths = [];
    for (let i = 0; i < measures.length; i++) {
      let w = [0, 0, 0];
      slot_pos(measures[i], measures[i].duration, w);
      w[0] += w[2] / CONFIG.NOTE_WIDTH;
      measure_widths.push(w);
    }
    let rows = [{count: 0, width: 0, num_inter: 0}];
    for (let i = 0; i < measures.length; i++) {
      if (!i) {
        measures[i].is_first_col = true;
        score.first_col_measure_indices.push(i);
      }
      let row = rows[rows.length - 1];
      if (row.width + measure_widths[i][0] <= (CONTENT_WIDTH() - (rows.length == 1 ? score.indent : 0)) / CONFIG.NOTE_WIDTH) {
        row.count++;
        row.width += measure_widths[i][0];
        row.num_inter += measure_widths[i][1];
      } else {
        if (i)
          measures[i - 1].is_last_col = true;
        measures[i].is_first_col = true;
        score.first_col_measure_indices.push(i);
        for (let j = 0; j < measures[i].staves.length; j++) {
          measures[i].staves[j].flags.need_clef = true;
          let [acc, num_acc] = measures[i].staves[j].key_signature;
          measures[i].staves[j].flags.need_keysig = {
            accidental: acc,
            count: num_acc
          };
        }
        let w = [0, 0, 0];
        slot_pos(measures[i], measures[i].duration, w);
        w[0] += w[2] / CONFIG.NOTE_WIDTH;
        measure_widths[i] = w;
        row = {count: 1, width: measure_widths[i][0], num_inter: measure_widths[i][1]};
        rows.push(row);
      }
    }
    let j0 = 0;
    let row_ybounds = [];
    let num_staves = measures.map((x) => x.staves.length).reduce((acc, x) => Math.max(acc, x), 0);
    for (let i = 0; i < rows.length; i++) {
      for (let k = 0; k < num_staves; k++) {
        let [has_cue, has_lyric] = [false, false];
        for (let j = j0; j < j0 + rows[i].count; j++) {
          if (!measures[j].staves[k]) {
            continue;
          }
          has_cue = has_cue || measures[j].staves[k].flags.need_cue;
          has_lyric = has_lyric || measures[j].staves[k].flags.need_lyric;
        }
        for (let j = j0; j < j0 + rows[i].count; j++) {
          if (!measures[j].staves[k]) {
            continue;
          }
          measures[j].staves[k].flags.need_cue = has_cue;
          measures[j].staves[k].flags.need_lyric = has_lyric;
        }
      }
      j0 += rows[i].count;
    }
    j0 = 0;
    for (let i = 0; i < rows.length; i++) {
      let extra = CONTENT_WIDTH() - (i == 0 ? score.indent : 0) - rows[i].width * CONFIG.NOTE_WIDTH;
      let nw = extra / rows[i].num_inter;
      for (let j = j0; j < j0 + rows[i].count; j++) {
        measures[j].pad.inter += i == rows.length - 1 && extra / CONTENT_WIDTH() > 1 - CONFIG.JUSTIFY_ALIGN_MIN ? 0 : nw;
      }
      j0 += rows[i].count;
    }
    for (let i = 0; i < measures.length; i++) {
      let measure = measures[i];
      for (let j = 0; j < measure.staves.length; j++) {
        plan_beams(measure, j);
        plan_articulations(measure, j);
      }
    }
    j0 = 0;
    for (let i = 0; i < rows.length; i++) {
      row_ybounds[i] = [];
      for (let k = 0; k < num_staves; k++) {
        let [ya, yb] = [0, 0, 0, 0];
        for (let j = j0; j < j0 + rows[i].count; j++) {
          if (!measures[j].staves[k]) {
            continue;
          }
          let [y0, y1] = estimate_staff_ybound(measures[j].staves[k], score.slurred_ids);
          ya = Math.min(y0, ya);
          yb = Math.max(y1, yb);
        }
        let ymin = ya;
        let ymax = yb;
        row_ybounds[i][k] = [ymin, ymax];
      }
      j0 += rows[i].count;
    }
    let xoff = score.indent;
    let yoff = -row_ybounds[0][0][0];
    let row_num = 0;
    let col_num = 0;
    if (rows[0] && rows[1] && rows[0].count == 0) {
      xoff = 0;
      yoff = -row_ybounds[1][0][0];
      row_num++;
    }
    for (let i = 0; i < measures.length; i++) {
      let yo = 0;
      let staves = measures[i].staves;
      let w = slot_pos(measures[i], measures[i].duration);
      for (let j = 0; j < staves.length; j++) {
        let sp = CONFIG.LINE_HEIGHT * (CONFIG.LINES_PER_STAFF - 1) + CONFIG.INTER_STAFF_HEIGHT;
        let r = row_ybounds[row_num][j][1];
        let staff_xoff = xoff;
        let staff_yoff = yoff + yo;
        if (j != staves.length - 1) {
          r -= row_ybounds[row_num][j + 1][0];
        }
        sp = Math.max(sp, r);
        if (j != staves.length - 1) {
          yo += sp;
        } else {
          yo += CONFIG.LINE_HEIGHT * (CONFIG.LINES_PER_STAFF - 1);
        }
        staves[j].coords.x = staff_xoff;
        staves[j].coords.y = staff_yoff;
        staves[j].coords.row = row_num;
        staves[j].coords.col = col_num;
        staves[j].coords.w = w;
        staves[j].coords.local_y_min = row_ybounds[row_num][j][0];
        staves[j].coords.local_y_max = row_ybounds[row_num][j][1];
        for (let k = 0; k < staves[j].grace.length; k++) {
          if (!staves[j].grace[k]) {
            continue;
          }
          let slot_x = slot_pos(measures[i], k);
          let slot = measures[i].slots[k];
          slot_x -= (slot.left_note + slot.left_deco + slot.left_squiggle + slot.left_grace) * CONFIG.NOTE_WIDTH + measures[i].pad.inter;
          staves[j].grace[k].staves[0].coords.x = staff_xoff + slot_x;
          staves[j].grace[k].staves[0].coords.y = staff_yoff;
          staves[j].grace[k].staves[0].coords.row = row_num;
          staves[j].grace[k].staves[0].coords.col = col_num;
          staves[j].grace[k].staves[0].coords.w = slot_pos(staves[j].grace[k], staves[j].grace[k].duration) * CONFIG.GRACE_WIDTH_MUL;
          staves[j].grace[k].staves[0].coords.local_y_min = row_ybounds[row_num][j][0];
          staves[j].grace[k].staves[0].coords.local_y_max = row_ybounds[row_num][j][1];
        }
      }
      xoff += w;
      col_num++;
      if (measures[i].is_last_col || i == measures.length - 1) {
        xoff = 0;
        let sp = row_ybounds[row_num][row_ybounds[row_num].length - 1][1];
        sp -= CONFIG.LINE_HEIGHT * (CONFIG.LINES_PER_STAFF - 1);
        row_num++;
        col_num = 0;
        if (row_ybounds[row_num]) {
          sp -= row_ybounds[row_num][0][0];
        }
        sp = Math.max(sp + 30, CONFIG.INTER_ROW_HEIGHT);
        yo += sp;
        yoff += yo;
      }
    }
  }
  function draw_measures(score) {
    var _a;
    let measures = score.measures;
    let result = [];
    let human_measure_count = 0;
    for (let i = 0; i < measures.length; i++) {
      let staves = measures[i].staves;
      if (CONFIG.SHOW_MEASURE_NUMBER) {
        if (staves[0] && measures[i].duration >= staves[0].time_signature[0] * (64 / staves[0].time_signature[1])) {
          human_measure_count++;
        } else if (staves[0] && measures[i + 1] && measures[i + 1].staves[0] && measures[i + 1].staves[0].key_signature[0] == staves[0].key_signature[0] && measures[i + 1].staves[0].key_signature[1] == staves[0].key_signature[1] && measures[i].duration + measures[i + 1].duration == staves[0].time_signature[0] * (64 / staves[0].time_signature[1])) {
          human_measure_count++;
        }
      }
      if (measures[i].is_first_col) {
        let staff_count2 = 0;
        for (let j = 0; j < score.instruments.length; j++) {
          if (!staves[staff_count2]) {
            break;
          }
          let y0 = staves[staff_count2].coords.y;
          let y1 = staves[staff_count2 + score.instruments[j].names.length - 1].coords.y + CONFIG.LINE_HEIGHT * (CONFIG.LINES_PER_STAFF - 1);
          if (!j && i && CONFIG.SHOW_MEASURE_NUMBER) {
            let t = human_measure_count.toString();
            let w = get_text_width(t, FONT.DUPLEX, -2) * CONFIG.MEASURE_NUMBER_TEXT_SIZE / FONT_INHERENT_HEIGHT;
            result.push({
              tag: "regular_text",
              type: "measure_number",
              text: t,
              x: staves[0].coords.x - w / 2,
              y: y0 - CONFIG.MEASURE_NUMBER_TEXT_SIZE - 14,
              w,
              h: CONFIG.MEASURE_NUMBER_TEXT_SIZE
            });
          }
          if (!i && score.indent) {
            if (new Set(score.instruments[j].names).size == 1) {
              let w = get_text_width(score.instruments[j].names[0], FONT.DUPLEX, -2) * CONFIG.INSTRUMENT_TEXT_SIZE / FONT_INHERENT_HEIGHT;
              result.push({
                tag: "regular_text",
                type: "instrument",
                text: score.instruments[j].names[0],
                x: staves[0].coords.x - w - CONFIG.INSTRUMENT_PAD_RIGHT,
                y: (y0 + y1) / 2 - CONFIG.INSTRUMENT_TEXT_SIZE / 2,
                w,
                h: CONFIG.INSTRUMENT_TEXT_SIZE
              });
            } else {
              for (let k = 0; k < score.instruments[j].names.length; k++) {
                let z0 = staves[staff_count2 + k].coords.y;
                let z1 = staves[staff_count2 + k].coords.y + CONFIG.LINE_HEIGHT * (CONFIG.LINES_PER_STAFF - 1);
                let w = get_text_width(score.instruments[j].names[k], FONT.DUPLEX, -2) * CONFIG.INSTRUMENT_TEXT_SIZE / FONT_INHERENT_HEIGHT;
                result.push({
                  tag: "regular_text",
                  type: "instrument",
                  text: score.instruments[j].names[k],
                  x: staves[0].coords.x - w - CONFIG.INSTRUMENT_PAD_RIGHT,
                  y: (z0 + z1) / 2 - CONFIG.INSTRUMENT_TEXT_SIZE / 2,
                  w,
                  h: CONFIG.INSTRUMENT_TEXT_SIZE
                });
              }
            }
          }
          if (score.instruments[j].bracket != BRACKET.NONE) {
            result.push({
              tag: "bracket",
              type: score.instruments[j].bracket,
              x: staves[0].coords.x,
              y: y0,
              w: 0,
              h: y1 - y0
            });
          }
          staff_count2 += score.instruments[j].names.length;
        }
        if (staves.length > 1) {
          result.push({
            tag: "line",
            type: "barline",
            x: staves[0].coords.x,
            y: staves[0].coords.y,
            w: 0,
            h: staves[staves.length - 1].coords.y + CONFIG.LINE_HEIGHT * (CONFIG.LINES_PER_STAFF - 1) - staves[0].coords.y
          });
        }
        if (CONFIG.JOIN_STAFF_LINES) {
          let last_measure_of_row = ((_a = score.first_col_measure_indices[staves[0].coords.row + 1]) != null ? _a : measures.length) - 1;
          let x1 = measures[last_measure_of_row].staves[0].coords.x + measures[last_measure_of_row].staves[0].coords.w;
          for (let j = 0; j < staves.length; j++) {
            let y0 = staves[j].coords.y;
            for (let k = 0; k < CONFIG.LINES_PER_STAFF; k++) {
              result.push({
                tag: "line",
                type: "staff_line",
                x: staves[0].coords.x,
                y: y0 + k * CONFIG.LINE_HEIGHT,
                w: x1 - staves[0].coords.x,
                h: 0
              });
            }
          }
        }
      }
      for (let j = 0; j < staves.length; j++) {
        let ret = draw_staff(measures[i], j, CONFIG.JOIN_STAFF_LINES);
        ret.forEach((x) => result.push(x));
      }
      if (!score.instruments.length) {
        result.push({
          tag: "line",
          type: "barline",
          x: staves[0].coords.x + staves[0].coords.w,
          y: staves[0].coords.y,
          w: 0,
          h: staves[staves.length - 1].coords.y + CONFIG.LINE_HEIGHT * (CONFIG.LINES_PER_STAFF - 1) - staves[0].coords.y
        });
      }
      let staff_count = 0;
      for (let j = 0; j < score.instruments.length; j++) {
        for (let k = 0; k < score.instruments[j].names.length; k++) {
          let z0 = staves[staff_count + k].coords.y;
          let z1 = staves[staff_count + k].coords.y + CONFIG.LINE_HEIGHT * (CONFIG.LINES_PER_STAFF - 1);
          let z2 = staves[staff_count + k + 1] ? staves[staff_count + k + 1].coords.y : z1;
          if (measures[i].barline == BARLINE.SINGLE || measures[i].barline == BARLINE.REPEAT_BEGIN) {
            result.push({
              tag: "line",
              type: "barline",
              x: staves[staff_count + k].coords.x + staves[staff_count + k].coords.w,
              y: z0,
              w: 0,
              h: (score.instruments[j].connect_barlines[k] ? z2 : z1) - z0
            });
          }
          if (measures[i].barline == BARLINE.DOUBLE) {
            result.push({
              tag: "line",
              type: "barline",
              x: staves[staff_count + k].coords.x + staves[staff_count + k].coords.w,
              y: z0,
              w: 0,
              h: (score.instruments[j].connect_barlines[k] ? z2 : z1) - z0
            });
            result.push({
              tag: "line",
              type: "barline",
              x: staves[staff_count + k].coords.x + staves[staff_count + k].coords.w - 4,
              y: z0,
              w: 0,
              h: (score.instruments[j].connect_barlines[k] ? z2 : z1) - z0
            });
          }
          if (measures[i].barline == BARLINE.END || measures[i].barline == BARLINE.REPEAT_END || measures[i].barline == BARLINE.REPEAT_END_BEGIN) {
            for (let l = 0; l < 4; l++) {
              result.push({
                tag: "line",
                type: "barline",
                x: staves[staff_count + k].coords.x + staves[staff_count + k].coords.w - l,
                y: z0,
                w: 0,
                h: (score.instruments[j].connect_barlines[k] ? z2 : z1) - z0
              });
            }
            result.push({
              tag: "line",
              type: "barline",
              x: staves[staff_count + k].coords.x + staves[staff_count + k].coords.w - 8,
              y: z0,
              w: 0,
              h: (score.instruments[j].connect_barlines[k] ? z2 : z1) - z0
            });
            if (measures[i].barline != BARLINE.END) {
              result.push({
                tag: "dot",
                type: "barline_repeat",
                x: staves[staff_count + k].coords.x + staves[staff_count + k].coords.w - 12,
                y: z0 + CONFIG.LINE_HEIGHT * 1.5,
                w: 0,
                h: 0
              });
              result.push({
                tag: "dot",
                type: "barline_repeat",
                x: staves[staff_count + k].coords.x + staves[staff_count + k].coords.w - 12,
                y: z0 + CONFIG.LINE_HEIGHT * 2.5,
                w: 0,
                h: 0
              });
            }
          }
          if (measures[i].barline == BARLINE.REPEAT_BEGIN || measures[i].barline == BARLINE.REPEAT_END_BEGIN) {
            let x0 = measures[i + 1].staves[staff_count + k].coords.x + slot_pos(measures[i + 1], -1);
            let y0 = measures[i + 1].staves[staff_count + k].coords.y;
            let xl = staves[staff_count + k].coords.x + staves[staff_count + k].coords.w;
            let adj = measures[i].barline == BARLINE.REPEAT_END_BEGIN && Math.abs(x0 - xl) < 0.01;
            if (!adj) {
              for (let l = 1; l < 4; l++) {
                result.push({
                  tag: "line",
                  type: "barline",
                  x: x0 + l,
                  y: y0,
                  w: 0,
                  h: (score.instruments[j].connect_barlines[k] ? z2 : z1) - z0
                });
              }
            }
            result.push({
              tag: "line",
              type: "barline",
              x: x0 + 8 - 3 * Number(adj),
              y: y0,
              w: 0,
              h: (score.instruments[j].connect_barlines[k] ? z2 : z1) - z0
            });
            result.push({
              tag: "dot",
              type: "barline_repeat",
              x: x0 + 12 - 3 * Number(adj),
              y: y0 + CONFIG.LINE_HEIGHT * 1.5,
              w: 0,
              h: 0
            });
            result.push({
              tag: "dot",
              type: "barline_repeat",
              x: x0 + 12 - 3 * Number(adj),
              y: y0 + CONFIG.LINE_HEIGHT * 2.5,
              w: 0,
              h: 0
            });
          }
        }
        staff_count += score.instruments[j].names.length;
      }
    }
    return result;
  }
  function draw_slurs(score) {
    let result = [];
    let row_yoffsets = score.measures.filter((x) => x.is_first_col).map((x) => x.staves[0].coords.y);
    for (let i = 0; i < score.slurs.length; i++) {
      let notes_ybounds = function(notes) {
        if (!notes.length) {
          return null;
        }
        let ymin2 = Infinity;
        let ymax2 = -Infinity;
        for (let i2 = 0; i2 < notes.length; i2++) {
          let y02 = on_staff(notes[i2].staff_pos);
          let y12 = y02 + notes[i2].stem_dir * notes[i2].stem_len * CONFIG.LINE_HEIGHT;
          if (notes[i2].accidental != null) {
            y02 -= CONFIG.LINE_HEIGHT;
            y12 += CONFIG.LINE_HEIGHT;
          }
          ymin2 = Math.min(y02, y12, ymin2);
          ymax2 = Math.max(y02, y12, ymax2);
        }
        return [ymin2, ymax2];
      }, share_measure_ybound_in_slur = function() {
        let m0 = score.first_col_measure_indices[lreg.row] + lreg.col;
        let m1 = score.first_col_measure_indices[rreg.row] + rreg.col;
        if (m0 != m1) {
          return null;
        }
        let b0 = get_begin(lreg);
        let b1 = get_begin(rreg);
        let notes = score.measures[m0].staves[lreg.staff_idx].notes.filter((x) => b0 < x.begin && x.begin < b1);
        return notes_ybounds(notes);
      }, get_begin = function(reg) {
        let m = score.first_col_measure_indices[reg.row] + reg.col;
        if (score.measures[m] != reg.measure) {
          for (let i2 = 0; i2 < score.measures[m].staves[reg.staff_idx].grace.length; i2++) {
            if (score.measures[m].staves[reg.staff_idx].grace[i2] == reg.measure) {
              return i2;
            }
          }
        }
        return reg.note.begin;
      }, self_measure_ybound_in_slur = function(reg, sign) {
        let m = score.first_col_measure_indices[reg.row] + reg.col;
        let begin = reg.note.begin;
        if (score.measures[m] != reg.measure) {
          for (let i2 = 0; i2 < score.measures[m].staves[reg.staff_idx].grace.length; i2++) {
            if (score.measures[m].staves[reg.staff_idx].grace[i2] == reg.measure) {
              begin = i2;
              break;
            }
          }
        }
        let notes = score.measures[m].staves[reg.staff_idx].notes.filter((x) => Math.sign(x.begin - begin) == sign);
        return notes_ybounds(notes);
      }, inter_ybound_in_slur = function(situation) {
        let m0 = score.first_col_measure_indices[lreg.row] + lreg.col;
        let m1 = score.first_col_measure_indices[rreg.row] + rreg.col;
        if (situation == 1) {
          if (score.first_col_measure_indices[lreg.row + 1] && score.first_col_measure_indices[lreg.row + 1] < m1) {
            m1 = score.first_col_measure_indices[lreg.row + 1];
          }
        } else if (situation == 2) {
          if (score.first_col_measure_indices[rreg.row] && score.first_col_measure_indices[rreg.row] > m0) {
            m0 = score.first_col_measure_indices[rreg.row] - 1;
          }
        }
        if (m0 + 1 >= m1) {
          return null;
        }
        let ymin2 = Infinity;
        let ymax2 = -Infinity;
        for (let i2 = m0 + 1; i2 < m1; i2++) {
          let [ya, yb] = notes_ybounds(score.measures[i2].staves[lreg.staff_idx].notes);
          if (ya == null) {
            ya = 0;
            yb = CONFIG.LINE_HEIGHT * 4;
          }
          ymin2 = Math.min(ymin2, ya);
          ymax2 = Math.max(ymax2, yb);
        }
        return [ymin2, ymax2];
      }, compute_slur = function(situation) {
        dy = null;
        ymin = ymax = null;
        if (!is_tie && lreg.staff_idx == rreg.staff_idx) {
          let m0 = score.first_col_measure_indices[lreg.row] + lreg.col;
          let m1 = score.first_col_measure_indices[rreg.row] + rreg.col;
          if (m0 <= m1) {
            if (m0 == m1) {
              let ret = share_measure_ybound_in_slur();
              if (ret)
                [ymin, ymax] = ret;
            } else {
              let rets;
              if (situation == 0) {
                rets = [
                  self_measure_ybound_in_slur(lreg, 1),
                  inter_ybound_in_slur(0),
                  self_measure_ybound_in_slur(rreg, -1)
                ];
                if (rreg.measure.staves[rreg.staff_idx].flags.need_clef) {
                  rets.push([CONFIG.LINE_HEIGHT, CONFIG.LINE_HEIGHT * (CONFIG.LINES_PER_STAFF - 1)]);
                }
              } else if (situation == 1) {
                rets = [
                  self_measure_ybound_in_slur(lreg, 1),
                  inter_ybound_in_slur(1)
                ];
              } else if (situation == 2) {
                rets = [
                  inter_ybound_in_slur(2),
                  self_measure_ybound_in_slur(rreg, -1)
                ];
              }
              for (let i2 = 0; i2 < rets.length; i2++) {
                if (rets[i2] == null) {
                  continue;
                }
                if (ymin === null) {
                  [ymin, ymax] = rets[i2];
                } else {
                  ymin = Math.min(rets[i2][0], ymin);
                  ymax = Math.max(rets[i2][1], ymax);
                }
              }
            }
            if (ymin !== null) {
              let yl = y0 - lreg.measure.staves[lreg.staff_idx].coords.y;
              let yr = y1 - rreg.measure.staves[rreg.staff_idx].coords.y;
              let ya;
              let yb;
              if (situation == 0) {
                ya = yl;
                yb = yr;
              } else if (situation == 1) {
                ya = yb = yl;
              } else if (situation == 2) {
                ya = yb = yr;
              }
              if (dir == -1) {
                dy = (Math.max(ya, yb) + (ya + yb) / 2) / 2 - ymin;
              } else {
                dy = ymax - (Math.min(ya, yb) + (ya + yb) / 2) / 2;
              }
              dy *= 1.2;
              dy = Math.max(dy, 0);
              dy += CONFIG.LINE_HEIGHT * 2;
            }
          }
        }
      };
      let {left, right, is_tie} = score.slurs[i];
      let lreg = id_registry[left];
      let rreg = id_registry[right];
      let x0, y0, x1, y1, dir;
      let sh_lh = lreg.note.articulation ? 4 : 7;
      let sh_lt = lreg.note.articulation ? 2 : 5;
      let sh_rh = rreg.note.articulation ? 4 : 7;
      let sh_rt = rreg.note.articulation ? 2 : 5;
      let l_is_grace = score.measures[score.first_col_measure_indices[lreg.row] + lreg.col] != lreg.measure;
      if (is_tie) {
        if (lreg.note.voice == 0 && rreg.note.voice == 0 && lreg.measure.staves[lreg.staff_idx].voices == 1 && rreg.measure.staves[rreg.staff_idx].voices == 1 && lreg.note.stem_dir == rreg.note.stem_dir) {
          if (lreg.note.next_in_chord == null && lreg.note.prev_in_chord != null && rreg.note.next_in_chord == null && rreg.note.prev_in_chord != null) {
            dir = lreg.note.stem_dir;
          } else {
            dir = -lreg.note.stem_dir;
          }
          [x0, y0] = [lreg.head_x, lreg.head_y + sh_lh * dir];
          [x1, y1] = [rreg.head_x, rreg.head_y + sh_rh * dir];
        } else {
          if (Math.max(lreg.note.voice, rreg.note.voice) % 2) {
            dir = 1;
            [x0, y0] = [lreg.head_x, lreg.head_y + sh_lh];
            [x1, y1] = [rreg.head_x, rreg.head_y + sh_rh];
          } else {
            dir = -1;
            [x0, y0] = [lreg.head_x, lreg.head_y - sh_lh];
            [x1, y1] = [rreg.head_x, rreg.head_y - sh_rh];
          }
        }
      } else {
        sh_lh = lreg.note.articulation ? lreg.note.articulation == ARTICULATION.STACCATO ? Math.abs(lreg.note.articulation_pos[1] * CONFIG.LINE_HEIGHT / 2 - (lreg.chord_head_y - lreg.measure.staves[lreg.staff_idx].coords.y)) + 5 : 4 : 7;
        sh_rh = rreg.note.articulation ? rreg.note.articulation == ARTICULATION.STACCATO ? Math.abs(rreg.note.articulation_pos[1] * CONFIG.LINE_HEIGHT / 2 - (rreg.chord_head_y - rreg.measure.staves[rreg.staff_idx].coords.y)) + 5 : 4 : 7;
        if ((lreg.measure.staves[lreg.staff_idx].voices > 1 || rreg.measure.staves[rreg.staff_idx].voices > 1) && lreg.note.stem_dir == rreg.note.stem_dir) {
          if (lreg.note.stem_dir == 1) {
            dir = 1;
            [x0, y0] = [lreg.tail_x, lreg.tail_y + sh_lt];
            [x1, y1] = [rreg.tail_x, rreg.tail_y + sh_rt];
          } else {
            dir = -1;
            [x0, y0] = [lreg.tail_x, lreg.tail_y - sh_lt];
            [x1, y1] = [rreg.tail_x, rreg.tail_y - sh_rt];
          }
        } else {
          let head_to_tail_better = Math.abs(lreg.chord_head_y - rreg.tail_y) < Math.abs(lreg.tail_y - rreg.chord_head_y) + 5;
          let tail_to_tail_better = Math.abs(lreg.tail_y - rreg.tail_y) < Math.abs(lreg.chord_head_y - rreg.chord_head_y) - 40;
          if (lreg.note.stem_dir < 0 && rreg.note.stem_dir < 0) {
            if (tail_to_tail_better) {
              dir = -1;
              [x0, y0] = [lreg.tail_x, lreg.tail_y - sh_lt];
              [x1, y1] = [rreg.tail_x, rreg.tail_y - sh_rt];
            } else {
              dir = 1;
              [x0, y0] = [lreg.chord_head_x, lreg.chord_head_y + sh_lh];
              [x1, y1] = [rreg.chord_head_x, rreg.chord_head_y + sh_rh];
            }
          } else if (lreg.note.stem_dir < 0 && rreg.note.stem_dir > 0) {
            if (head_to_tail_better) {
              dir = 1;
              [x0, y0] = [lreg.chord_head_x, lreg.chord_head_y + sh_lh];
              [x1, y1] = [rreg.tail_x, rreg.tail_y + sh_rt];
            } else {
              dir = -1;
              [x0, y0] = [lreg.tail_x, lreg.tail_y - sh_lt];
              [x1, y1] = [rreg.chord_head_x, rreg.chord_head_y - sh_rh];
            }
          } else if (lreg.note.stem_dir > 0 && rreg.note.stem_dir > 0) {
            if (tail_to_tail_better) {
              dir = 1;
              [x0, y0] = [lreg.tail_x, lreg.tail_y + sh_lt];
              [x1, y1] = [rreg.tail_x, rreg.tail_y + sh_rt];
            } else {
              dir = -1;
              [x0, y0] = [lreg.chord_head_x, lreg.chord_head_y - sh_lh];
              [x1, y1] = [rreg.chord_head_x, rreg.chord_head_y - sh_rh];
            }
          } else {
            if (head_to_tail_better) {
              dir = -1;
              [x0, y0] = [lreg.chord_head_x, lreg.chord_head_y - sh_lh];
              [x1, y1] = [rreg.tail_x, rreg.tail_y - sh_rt];
            } else {
              dir = 1;
              [x0, y0] = [lreg.tail_x, lreg.tail_y + sh_lt];
              [x1, y1] = [rreg.chord_head_x, rreg.chord_head_y + sh_rh];
            }
          }
        }
      }
      if (is_tie) {
        x0 += 3;
        x1 -= 3;
      } else {
        x0 += 2;
        x1 -= 2;
      }
      let dy = null;
      let ymin = null;
      let ymax = null;
      if (lreg.row == rreg.row) {
        compute_slur(0);
        let h = Math.min(CONFIG.LINE_HEIGHT * (lreg.measure == rreg.measure ? 4.5 : 6.5), Math.max(CONFIG.LINE_HEIGHT * 1.5, dy != null ? 0 : Math.abs(x1 - x0) * 0.05, dy != null ? 0 : Math.abs(y1 - y0) * 0.5, dy == null ? 0 : dy));
        if (is_tie) {
          h *= 0.6;
        }
        result.push({
          tag: "slur",
          x: x0,
          y: y0,
          w: x1 - x0,
          h: h * CONFIG.SLUR_ARC_MUL,
          y1,
          dir,
          adjacent: dy == null
        });
      } else {
        let get_row_left = function(row) {
          let k = score.first_col_measure_indices[row];
          let slot = score.measures[k].slots[0];
          let xz2 = slot_pos(score.measures[k], -1);
          ;
          return Math.max(xz2, 0);
        };
        compute_slur(1);
        let h = Math.min(CONFIG.LINE_HEIGHT * 6.5, Math.max(CONFIG.LINE_HEIGHT * 1.5, dy != null ? 0 : Math.abs(CONTENT_WIDTH() - x0) * 0.16, dy == null ? 0 : dy));
        if (is_tie) {
          h *= 0.6;
        }
        let y_1 = y0 + dir * h / 4;
        if (ymin != null) {
          y_1 = y_1 * 0.5 + (lreg.measure.staves[lreg.staff_idx].coords.y + (dir < 0 ? ymin - CONFIG.LINE_HEIGHT / 2 : ymax + CONFIG.LINE_HEIGHT / 2)) * 0.5;
        }
        result.push({
          tag: "slur",
          x: x0,
          y: y0,
          w: CONTENT_WIDTH() - x0,
          h: h * CONFIG.SLUR_ARC_MUL,
          y1: y_1,
          dir
        });
        for (let j = lreg.row + 1; j < rreg.row; j++) {
          let h2 = Math.min(CONFIG.LINE_HEIGHT * 7, Math.max(CONFIG.LINE_HEIGHT * 1.5, CONTENT_WIDTH() * 0.16));
          let xz2 = get_row_left(j);
          let notes = score.measures.slice(score.first_col_measure_indices[j], score.first_col_measure_indices[j + 1] || Infinity).map((x) => x.staves[lreg.staff_idx]).map((x) => x.notes).flat();
          let bd = notes_ybounds(notes);
          result.push({
            tag: "slur",
            x: xz2,
            y: row_yoffsets[j] + (dir < 0 ? bd[0] : bd[1]),
            w: CONTENT_WIDTH() - xz2,
            h: h2 * CONFIG.SLUR_ARC_MUL * 3 / 4,
            y1: row_yoffsets[j] + (dir < 0 ? bd[0] : bd[1]),
            dir
          });
        }
        let xz = get_row_left(rreg.row);
        compute_slur(2);
        h = Math.min(CONFIG.LINE_HEIGHT * 6.5, Math.max(CONFIG.LINE_HEIGHT * 1.5, dy != null ? 0 : x1 * 0.16, dy == null ? 0 : dy));
        y_1 = y1 + dir * h / 4;
        if (ymin != null) {
          y_1 = y_1 * 0.5 + (rreg.measure.staves[rreg.staff_idx].coords.y + (dir < 0 ? ymin - CONFIG.LINE_HEIGHT / 2 : ymax + CONFIG.LINE_HEIGHT / 2)) * 0.5;
        }
        result.push({
          tag: "slur",
          x: xz,
          y: y_1,
          w: x1 - xz,
          h: h * CONFIG.SLUR_ARC_MUL,
          y1,
          dir
        });
      }
    }
    return result;
  }
  function draw_crescs(score) {
    let result = [];
    for (let i = 0; i < score.crescs.length; i++) {
      let {left, right, val_left, val_right} = score.crescs[i];
      let lreg = id_registry[left];
      let rreg = id_registry[right];
      let x0 = lreg.head_x + 3;
      let x1 = rreg.head_x - 3;
      let staff0 = lreg.measure.staves[lreg.staff_idx];
      let staff1 = rreg.measure.staves[rreg.staff_idx];
      let ch = CONFIG.CUE_TEXT_SIZE;
      let y0 = staff0.coords.y + staff0.coords.local_y_max - (staff0.flags.need_lyric ? 2 * CONFIG.LYRIC_SPACING + CONFIG.LYRIC_SCALE * FONT_INHERENT_HEIGHT : 0) - CONFIG.CUE_HEIGHT / 2;
      let y1 = staff1.coords.y + staff1.coords.local_y_max - (staff1.flags.need_lyric ? 2 * CONFIG.LYRIC_SPACING + CONFIG.LYRIC_SCALE * FONT_INHERENT_HEIGHT : 0) - CONFIG.CUE_HEIGHT / 2;
      if (lreg.row == rreg.row) {
        let u0 = y0 - ch / 2 * val_left;
        let u1 = y0 + ch / 2 * val_left;
        let v0 = y1 - ch / 2 * val_right;
        let v1 = y1 + ch / 2 * val_right;
        result.push({
          tag: "cresc",
          x: x0,
          y: u0,
          w: x1 - x0,
          h: v0 - u0,
          x1: x0,
          y1: u1,
          w1: x1 - x0,
          h1: v1 - u1
        });
      } else {
        let wa = CONTENT_WIDTH() - x0;
        let ws = [0, wa];
        for (let j = lreg.row + 1; j < rreg.row; j++) {
          ws.push(wa += CONTENT_WIDTH());
        }
        ws.push(wa += x1);
        for (let j = 0; j < rreg.row - lreg.row + 1; j++) {
          let is_first = j == 0;
          let is_last = j == rreg.row - lreg.row;
          let t0 = ws[j] / wa;
          let t1 = ws[j + 1] / wa;
          let xl = is_first ? x0 : 0;
          let xr = is_last ? x1 : CONTENT_WIDTH();
          let y;
          if (is_first) {
            y = y0;
          } else if (is_last) {
            y = y1;
          } else {
            for (let k = 0; k < score.measures.length; k++) {
              if (score.measures[k].staves[lreg.staff_idx].coords.row == lreg.row + j) {
                let staff = score.measures[k].staves[lreg.staff_idx];
                y = staff.coords.y + staff.coords.local_y_max - (staff.flags.need_lyric ? 2 * CONFIG.LYRIC_SPACING + CONFIG.LYRIC_SCALE * FONT_INHERENT_HEIGHT : 0) - CONFIG.CUE_HEIGHT / 2;
                break;
              }
            }
          }
          let l = val_left * (1 - t0) + val_right * t0;
          let r = val_left * (1 - t1) + val_right * t1;
          let u0 = y - ch / 2 * l;
          let u1 = y + ch / 2 * l;
          let v0 = y - ch / 2 * r;
          let v1 = y + ch / 2 * r;
          result.push({
            tag: "line",
            type: "cresc_top",
            x: xl,
            y: u0,
            w: xr - xl,
            h: v0 - u0
          });
          result.push({
            tag: "line",
            type: "cresc_bottom",
            x: xl,
            y: u1,
            w: xr - xl,
            h: v1 - u1
          });
        }
      }
    }
    return result;
  }
  function draw_tempo(tempo) {
    let result = [];
    let dx = 0;
    if (tempo.duration != null && tempo.bpm != null) {
      if (tempo.duration < NOTE_LENGTH.WHOLE) {
        let num_flags = calc_num_flags(tempo.duration, tempo.modifier);
        result.push({
          tag: "note_head",
          x: CONFIG.NOTE_WIDTH,
          y: CONFIG.TEMPO_COMPOSER_TEXT_SIZE,
          w: CONFIG.NOTE_WIDTH,
          h: CONFIG.LINE_HEIGHT,
          twisted: false,
          stem_dir: -1,
          duration: tempo.duration
        });
        dx += CONFIG.NOTE_WIDTH;
        let eh = (num_flags + 1) * CONFIG.FLAG_SPACING * CONFIG.LINE_HEIGHT;
        result.push({
          tag: "line",
          type: "note_stem",
          x: CONFIG.NOTE_WIDTH,
          y: -eh,
          w: 0,
          h: CONFIG.TEMPO_COMPOSER_TEXT_SIZE + eh
        });
        if (tempo.modifier) {
          result.push({
            tag: "dot",
            type: "modifier",
            x: CONFIG.NOTE_WIDTH * 1.5,
            y: CONFIG.TEMPO_COMPOSER_TEXT_SIZE - CONFIG.LINE_HEIGHT / 2,
            w: 0,
            h: 0
          });
        }
        if (tempo.modifier || num_flags) {
          dx += CONFIG.NOTE_WIDTH;
        }
        for (let i = 0; i < num_flags; i++) {
          result.push({
            tag: "flag",
            x: CONFIG.NOTE_WIDTH,
            y: -eh + i * CONFIG.FLAG_SPACING * CONFIG.LINE_HEIGHT,
            w: CONFIG.NOTE_WIDTH,
            h: CONFIG.LINE_HEIGHT,
            stem_dir: -1,
            is_last: i == num_flags - 1
          });
        }
      } else {
        result.push({
          tag: "note_head",
          x: CONFIG.NOTE_WIDTH,
          y: CONFIG.TEMPO_COMPOSER_TEXT_SIZE / 2,
          w: CONFIG.NOTE_WIDTH,
          h: CONFIG.LINE_HEIGHT,
          twisted: false,
          stem_dir: -1,
          duration: tempo.duration
        });
        dx += CONFIG.NOTE_WIDTH;
      }
      let t = " = " + tempo.bpm;
      let tw = get_text_width(t, FONT.DUPLEX, -2) * CONFIG.TEMPO_COMPOSER_TEXT_SIZE / FONT_INHERENT_HEIGHT;
      result.push({
        tag: "regular_text",
        type: "tempo",
        text: t,
        x: dx,
        y: 0,
        w: tw,
        h: CONFIG.TEMPO_COMPOSER_TEXT_SIZE
      });
      dx += tw + CONFIG.TEMPO_COMPOSER_TEXT_SIZE;
    }
    if (tempo.text != null) {
      let tw = get_text_width(tempo.text, FONT.TRIPLEX, -2) * CONFIG.TEMPO_COMPOSER_TEXT_SIZE / FONT_INHERENT_HEIGHT;
      result.push({
        tag: "bold_text",
        type: "tempo",
        text: tempo.text,
        x: dx,
        y: 0,
        w: tw,
        h: CONFIG.TEMPO_COMPOSER_TEXT_SIZE
      });
    }
    return result;
  }
  function get_content_yoffset(score) {
    let dy = CONFIG.PAGE_MARGIN_Y;
    for (let i = 0; i < score.title.length; i++) {
      let h = i ? CONFIG.SUBTITLE_TEXT_SIZE : CONFIG.TITLE_TEXT_SIZE;
      dy += h + CONFIG.TITLE_LINE_SPACING;
    }
    if (score.tempo || score.composer.length) {
      dy += CONFIG.TITLE_LINE_SPACING;
      if (score.composer.length) {
        let h = CONFIG.TEMPO_COMPOSER_TEXT_SIZE;
        for (let i = 0; i < score.composer.length; i++) {
          dy += CONFIG.TEMPO_COMPOSER_TEXT_SIZE + 4;
        }
        dy -= CONFIG.TEMPO_COMPOSER_TEXT_SIZE + 4;
      }
      dy += CONFIG.TEMPO_COMPOSER_TEXT_SIZE;
    }
    dy += CONFIG.TITLE_LINE_SPACING * 1.2;
    return dy;
  }
  function draw_score(score) {
    id_registry = {};
    let ret = draw_measures(score);
    ret.push(...draw_slurs(score));
    ret.push(...draw_crescs(score));
    let last_staff = score.measures[score.measures.length - 1].staves[score.measures[score.measures.length - 1].staves.length - 1];
    let H = last_staff.coords.y + Math.max(last_staff.coords.local_y_max, CONFIG.LINE_HEIGHT * (CONFIG.LINES_PER_STAFF + 1));
    let result = [];
    let dy = CONFIG.PAGE_MARGIN_Y;
    for (let i = 0; i < score.title.length; i++) {
      let h = i ? CONFIG.SUBTITLE_TEXT_SIZE : CONFIG.TITLE_TEXT_SIZE;
      let w = get_text_width(score.title[i], i ? FONT.DUPLEX : FONT.TRIPLEX, -2) * h / FONT_INHERENT_HEIGHT;
      result.push(__objSpread(__objSpread({}, i ? {tag: "regular_text", type: "subtitle"} : {tag: "bold_text", type: "title"}), {
        text: score.title[i],
        x: CONFIG.PAGE_WIDTH / 2 - w / 2,
        y: dy,
        w,
        h
      }));
      dy += h + CONFIG.TITLE_LINE_SPACING;
    }
    if (score.tempo || score.composer.length) {
      dy += CONFIG.TITLE_LINE_SPACING;
      if (score.composer.length) {
        let h = CONFIG.TEMPO_COMPOSER_TEXT_SIZE;
        for (let i = 0; i < score.composer.length; i++) {
          let w = get_text_width(score.composer[i], FONT.DUPLEX, -2) * h / FONT_INHERENT_HEIGHT;
          result.push({
            tag: "regular_text",
            type: "composer",
            text: score.composer[i],
            x: CONFIG.PAGE_WIDTH - CONFIG.PAGE_MARGIN_X - w,
            y: dy,
            w,
            h
          });
          dy += CONFIG.TEMPO_COMPOSER_TEXT_SIZE + 4;
        }
        dy -= CONFIG.TEMPO_COMPOSER_TEXT_SIZE + 4;
      }
      if (score.tempo) {
        let r = draw_tempo(score.tempo);
        translate_elements(r, CONFIG.PAGE_MARGIN_X + score.indent, dy);
        r.forEach((x) => result.push(x));
      }
      dy += CONFIG.TEMPO_COMPOSER_TEXT_SIZE;
    }
    dy += CONFIG.TITLE_LINE_SPACING * 1.2;
    translate_elements(ret, CONFIG.PAGE_MARGIN_X, dy);
    ret.forEach((x) => result.push(x));
    return [result, H + CONFIG.PAGE_MARGIN_Y + dy];
  }
  function render_score(score, {compute_polylines = true} = {}) {
    let [elements, h] = draw_score(score);
    let ret = {
      w: CONFIG.PAGE_WIDTH,
      h,
      elements,
      polylines: null
    };
    if (CONFIG.SLUR_EVADE) {
      slur_evade_note(elements);
    }
    if (CONFIG.CUE_EVADE) {
      cue_evade_slur(elements);
    }
    if (compute_polylines) {
      ret.polylines = hf_drawing_polylines(elements, ret.w, ret.h);
    }
    return ret;
  }
  function playhead_coords(score, time_in_64th) {
    let time = Math.max(0, time_in_64th);
    let T = 0;
    let i;
    for (i = 0; i < score.measures.length; i++) {
      if (time < T + score.measures[i].duration) {
        break;
      }
      T += score.measures[i].duration;
    }
    if (i >= score.measures.length) {
      return playhead_coords(score, T - 0.01);
    }
    let measure = score.measures[i];
    let t = time - T;
    let it = ~~t;
    let ft = t - it;
    let x0 = slot_pos(measure, it);
    let x1;
    if (measure.slots[it + 1]) {
      x1 = slot_pos(measure, it + 1);
    } else if (score.measures[i + 1] && !score.measures[i + 1].is_first_col) {
      x1 = measure.staves[0].coords.w + slot_pos(score.measures[i + 1], 0);
    } else {
      x1 = measure.staves[0].coords.w;
    }
    let xf = x0 * (1 - ft) + x1 * ft;
    let x = measure.staves[0].coords.x + xf + CONFIG.PAGE_MARGIN_X;
    let dy = get_content_yoffset(score);
    let y0 = dy + measure.staves[0].coords.y;
    let y1 = dy + measure.staves[measure.staves.length - 1].coords.y + CONFIG.LINE_HEIGHT * (CONFIG.LINES_PER_STAFF - 1);
    return [x, y0, x, y1];
  }
  return main_exports;
})();
;(typeof module == 'object')?(module.exports=legumes):0;
